[
    {"name": "Home", "namespace": "", "shortDesc": "Home", "longDesc": "<p>\nWelcome to documentation of Hm.js. All the document entries are both edited and displayed in this single page application. It is still being edited.  Your are welcomed to edit them as well, \"Click on the pen icon\" on the top right corner\".  You change will effect your only. You can send your change to me by following the following steps.\n</p>\n<ol>\n<li>Fork the project in <a href=\"http://github.com/fredyang/Hm.js\">GitHub</a>.</li>\n<li>Open console of chrome developers tools, type <code>copy(hm(\"api.entries\").toJSON())</code>\n</li>\n<li>Paste the content to the file <code>doc/doc-json.js</code> in source code.\n</li>\n<li>Commit, push change, and send me a pull request.</li>\n</ol>\n\n<p>\nThe documentation is organize as a tree, some of the interesting topics might not be well exposed. The following topics might be interesting to you.\n</p>\n<ol>\n<li><a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub\">Declarative subscriptions</a> become very powerful with used the finalize activity <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Template.activities.parseSubs\">parseSubs</a>\n</li>\n\n<li>\nDeclarative subscription use a lot of convention in <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Model.Path\">path calculations </a> and <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Handler.string\">string format calucation.</a>\n</li>\n\n<li>\nYou can build Single Page Application with the <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=plugins.App\">App</a> plugin. The page you are viewing is single page app. The source code is <a href=\"/Hm.js/assets/app/api.js\">here</a>.</li>\n\n\n<li>The library support asynchronous \"get\" activity and \"set\" activity, so that the handler can be asynchronous  For more refer <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Async+handler\">here</a>.\n</li>\n\n<li>You can use <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Utilities.newJqEvent\">newJqEvent</a> to easily create some special event in jQuery. The library use it create some events such as \"enter\", \"esc\", you can subscribe this events just like \"click\".\n</li>\n\n<li>\nYou can use <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.catch-all+event+*\">catch-all event  *</a> to filter model event. Only the the event match the filter will be send to subscriber.\n</li>\n\n<li>You can put complex declarative into \n<a href=\"http://localhost/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.child+behavior\">child group</a> to greatly shrink the declarative embedded in the markup.\n</li>\n\n<li>\nYou can use <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.child+behavior.Dynamic+group\">dynamic group</a> to subscribe programmatically with the benefit of declarative subscription.\n</li>\n\n</ol>", "signatures": []},
    {"name": "Constructor", "type": "method", "namespace": "Node", "shortDesc": "Constructor", "signatures": [
        {"name": "hm(path[, value])", "returns": "Node", "shortDesc": "Accepts a string of path and create a node pointing to a node in the repository. ", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm(path)", "parameters": [
                {"name": "path", "type": "String", "desc": "A string of path in the repository"},
                {"name": "value", "type": "object", "desc": "A optional value to be set to model at the path"}
            ]}
        ], "examples": [
            {"desc": "Create a node and use it to access model in repository", "code": "//create a root node\nvar root = hm();\n\nroot.set(\"firstName\", \"Tom\");\nhm.log(root.get(\"firstName\"));\n\n//create a node with path\nvar firstName = hm(\"firstName\");\nfirstName.set(\"Jerry\");\nhm.log(firstName.get());\n\n//create a node with default value\nvar lastName = hm(\"lastName\", \"Yang\");\nhm.log(lastName.get());\n", "url": "http://jsbin.com/iconaLo/1", "jsbin": true}
        ]}
    ], "longDesc": "<p>hm is the constructor to build a node.</p>"},
    {"name": "Node", "type": "category", "namespace": "", "shortDesc": "Node", "signatures": [], "longDesc": "<p>In Hm.js, the models are public accessible data and functions. They are saved in a singleton object called <strong>repository</strong>. <strong>Repository</strong> is a JSON object and it is tree-like structure. Rather than accessing the model directly, we use a node object to access them. The main reason is to create model event so that we can implement publisher subscriber pattern. When node method is called, model events can be triggered.</p>\n\n<p>A node is associated with a path, such as \"mailApp.contacts.0.phones.1\" which pinpoint the location of a data  in the repository. If the data at the path does not exists,  for example the mailApp has only one contact, calling the read method of the node will return undefined. Calling some manipulation method can trigger exception like \"invalid access model\"</p>\n\n<p>In the following, it demonstrate the difference between updating model directly and updating model using node method.</p>\n\n\n<pre  data-sub=\"prettyprint:.;preview:_|http://jsbin.com/ucisep/6\">\n  var person = {\n    firstName: \"\",\n    lastName: \"\"\n  };\n  \n  hm.set(\"person\", person);\n  \n  hm.handle(\"person\", \"afterUpdate.*\", function (e) {\n    \n    hm.log(\"event triggered for update via node: \" + e.originalPublisher.path + \" is changed\"+ \" from \" + e.removed+  \" to \" + e.proposed);\n  \n  });\n  \n  //update model directly, the following will not trigger \n  //model event\n  hm.log(\"----updating model directly----\");\n  person.firstName = \"John\";\n  person.lastName = \"Doe\";\n hm.log(\"no event triggered for direct update\"); \n  \n  //update model using node method, and it will trigger events\n  var personNode = hm(\"person\");\n  hm.log(\"----updating model using node method----\");\n  personNode.set(\"firstName\", \"Jane\");\n  personNode.set(\"lastName\", \"Roe\");\n</pre>\n\n<p>Sometimes, we do need to update model directly for reason such as performance, raising custom event. The following example demonstrate how to access model directly and raising custom events.</p>\n\n<pre  data-sub=\"prettyprint:.;preview:_|http://jsbin.com/iwonad/3\">\n$(function () {\n\n  hm.set(\"person\", {\n    firstName: \"\",\n    lastName: \"\",\n    changeName: function (firstName, lastName) {\n      \n      var person = this.get();\n      var oldPerson = hm.util.clone(person);\n      person.firstName = firstName;\n      person.lastName = lastName;\n      //raised a custom event\n      this.trigger(\"nameChanged\", person, oldPerson);\n    }\n  });\n  \n  hm.handle(\"person\", \"nameChanged\", function (e) {\n    hm.log(\"person is changed from \" + JSON.stringify(e.removed) + \" to \" + JSON.stringify(e.proposed));\n    \n  });\n  \n  hm(\"person\").set(\"changeName\", \"John\", \"Doe\");\n});\n</pre>"},
    {"name": "Unified Subscription", "type": "", "namespace": "", "shortDesc": "Unified Subscription", "signatures": [], "longDesc": "<p>A subscription consist of four elements, subscriber, publisher, events, and event handler.  As far as hm.js is concerned, there are two kinds of objects, model and view. Model is about data, it is implemented as model node, and view is anything other than model, it is implemented as jQuery object.  <b>Unified subscription</b> means that both model and view can be act as the role of publisher or subscriber in a subscription. We can use the same api to create subscription for different objects regardless whether they are view or model.\n</p>\n"},
    {"name": "Template", "type": "", "namespace": "", "shortDesc": "Template", "longDesc": "<h3>Template handler and actvities</h3>\n\n<p>In Hm.js, a child view is rendered by its parent view. And the &lt;html/&gt; element can render the whole page by hierarchically child views.  If a parent view want to render a child view as simple DOM element, or it can be trunk of html, in this case we need to use template handler. </p>\n\n<p>Beside the normal \"get\" activity and \"set\" activity,  this handler has three special activities. It has a \"convert\" activity named <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Template.activities.template\">template</a>. This activity can convert the data in the markup. It also has an \"initialize\" activity <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Template.activities.templateOptions\">tempalteOptions</a>, and finalize activity <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Template.activities.parseSubs\">parseSubs</a>. The following is skeleton of a template handler or template workflow.</p>\n\n<pre prettyprint>\n{\n  initialize: \"*templateOptions\",\n  get: \"get\", //&lt-- your get activity, e.g \"get\"\n  convert: \"*template\",\n  set: \"html\", //&lt-- your set activity, e.g \"html\"\n  finalize: \"*parseSubs\"\n}\n</pre>\n\n<h3>Template types</h3>\n\n<p>We have <a href=\"http://www.w3schools.com/cssref/css3_pr_background-size.asp\">three way to insert CSS</a>, inline style, internal, external style sheet. Similar to this,  we have three types of templates, inline, internal,  and external template.\n</p>\n\n<h4>Inline template</h4>\n<p>Inline template does not have any id, so you don't need have a template options when use template workflow. The following is an example. </p>\n\n<pre prettyprint preview=\":_|http://jsbin.com/EgeZodA/2\">\n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;tbody tmpl=\"app.contacts\"&gt;\n      &lt;tr&gt;\n\t\t&lt;td&gt;\n          {{:firstName}}\n\t\t&lt;/td&gt;\n\t\t&lt;td&gt;\n          {{:lastName}}\n\t\t&lt;/td&gt;\n\t&lt;/tr&gt;\n\t&lt;/tbody&gt;\n  &lt;/table&gt;\n</pre>\n\n<pre prettyprint>\nhm(\"app\", {\n  \"contacts\": [{\n    firstName: \"John\",\n    lastName: \"Doe\"\n  }, {\n    firstName: \"Jane\",\n    lastName: \"Roe\"\n  }]\n\n});\n</pre>\n\n<p>The content inside of of the <code>tbody</code> is the template itself. This is simple to use, but the template can not has inner template, and it can not be reused.\n</p>\n\n<h3>Internal template</h3>\n<p>Internal template has an id, it can be used across the the page like the following.</p>\n<pre prettyprint preview=\"_|http://jsbin.com/efEcarE/2\">\n  &lt;script id=\"contactsTemplate\" type=\"jsrender\"&gt;\n    &lt;tr&gt;\n\t\t&lt;td&gt;\n          {{:firstName}}\n\t\t&lt;/td&gt;\n\t\t&lt;td&gt;\n          {{:lastName}}\n\t\t&lt;/td&gt;\n\t&lt;/tr&gt;\n  &lt;/script&gt;\n  \n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;tbody tmpl=\"app.contacts|contactsTemplate\"&gt;\n\t&lt;/tbody&gt;\n  &lt;/table&gt;\n</pre>\n\n<h3>External template</h3>\n\n<p>\nExternal templates is placed into external files. You can put one or more templates into a file. When hm.js find that the template is not defined inside the page like inline template or embedded template, it will convert the template id into a url, and try to load the the template file. In the following example, the template  with id \"contactsTemplate\", is mapped to url of \"contactsTemplate.html\" which contains the template. Please note that, you reference internal template and external template in exactly the same way, the only difference is that internal template is embedded in the page, while an external template is in an external file.\n</p>\n\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/YhiNMQ/preview\">\n  &lt;body&gt;\n   &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;tbody tmpl=\"app.contacts|contactsTemplate.html\"&gt;\n\t&lt;/tbody&gt;\n  &lt;/table&gt;\n  &lt;/body&gt;\n</pre>\n<pre prettyprint>\n&lt;!-- the content of contactsTemplate.html --&gt;\n&lt;tr&gt;\n  &lt;td&gt;\n  {{:firstName}}\n  &lt;/td&gt;\n  &lt;td&gt;\n   {{:lastName}}\n  &lt;/td&gt;\n&lt;/tr&gt;\n</pre>\n\n<h3>Template engine and adpater</h3>\n\n<p>\nHm.js itself does not have a template engine.  Instead, it leverage third party template engines by using a template engine adapter. Hm.js has an adapter for <a href=\"https://github.com/BorisMoore/jsrender\">jsrender</a>, and  an adapter for <a href=\"http://handlebarsjs.com/\">handlebarsjs</a>. You can create a your own <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Template.template+engine+adapter\">template engine adapter</a> to use other template engine. In the following, we use \"jsrender\" as template engine.\n</p>", "signatures": []},
    {"name": "get", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.get()", "longDesc": "The method retrieve model value. If  the node is a function, it will call the function with optional parameter, and return the result of function call. Inside the function, the \"this\" context refer to the parent node, \"this.previous\" refer to current node.", "signatures": [
        {"name": "node.get(subPath, [parameter1, [parameter2], ..]", "returns": "object", "shortDesc": "get model value", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.get(subPath)", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node's path"}
            ]}
        ], "examples": [
            {"desc": "use node.get to retrieve value in repository", "code": "  var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    fullName: function () {\n      \n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\");\n    },\n    message: function(greeting) {\n      hm.log(\"'this' refers to parent node, this.path == \" + this.path);\n      hm.log(\"'this.previous' refers to current node, this.pervious.path == \" + this.previous.path);\n      return greeting + \", \" + this.get(\"fullName\");\n    }\n  });\n  \n  \n  hm.log(person.get(\"firstName\"));\n  hm.log(person.get(\"fullName\"));\n  hm.log(person.get(\"message\", \"Hello\"));", "url": "http://jsbin.com/ePOxUrIQ/1", "jsbin": true}
        ]},
        {"name": "hm.get(fullPath, [ paramter1, [parameter2, [..]] ]", "returns": "object", "shortDesc": "a shortcut to hm().get", "desc": "This is equivalent to hm().get(fullPath, [ paramter1, [parameter2, [..]] ]", "overloads": [
            {"versionAdded": "0.1", "name": "hm.get(fullPath, [ paramter1, [parameter2, [..]] ]", "parameters": [
                {"name": "fullPath", "type": "string", "desc": "a absolute path"}
            ]}
        ], "examples": []}
    ]},
    {"name": "set", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.set()", "longDesc": "<p>\nSet value to a node in repository.  If the node already exist, the method will call node.update() method, and raise events \"beforeUpdate\", \"afterUpdate\". If the workflow of the subscription to \"beforeCreate\" or \"beforeUpdate\" event signal error, then the set operation will be aborted. \n</p>\n\n<p>\nIf the node does not exist, the method will call node.create() method and raise events \"beforeCreate\" and \"afterCreate\".\n</p>\n\n<p>\n If the value of the node is a function, the method will call the function in the context of parent node.\n\n</p>", "signatures": [
        {"name": "node.set(subPath, value, value2, ..)", "returns": "Node", "shortDesc": "set value to a node in repository", "desc": "set a value to a node in repository. If current value of the node is a function, it will call the function. Inside the function, the \"this\" context refer the node pointing to the parent node.", "overloads": [
            {"versionAdded": "0.1", "name": "node.set([subPath,] value, value2, ..)", "parameters": [
                {"name": "subPath", "type": "string", "desc": "sub-path relative to the path of node"}
            ]}
        ], "examples": [
            {"desc": "The following show how to use \"set\" method to change value of a node or call the function of node, it also show what events will be trigger in the set method.", "code": "  var person = hm( \"person\", {\n\tfirstName: \"\",\n\t//lastName: \"\",\n\tchangeName: function( firstName, lastName ) {\n\t\t//this point to the current model object\n\t\tthis.set( \"firstName\", firstName );\n\t\tthis.set( \"lastName\", lastName );\n\t}\n  });\n  \n  person.handle(\"*\", function (e) {\n    hm.log(\"path '\" + e.originalPublisher.path + \"' trigger event '\" + e.originalType, \"red\");\n  });\n  \n  person.set(\"firstName\", \"John\");\n  \n  hm.log(\"firstName: \" + person.get(\"firstName\"));\n  \n  person.set(\"lastName\", \"Doe\");\n  hm.log(\"lastName: \" + person.get(\"lastName\"));\n  \n  hm.log(\"---calling changeName---\");\n  \n  person.set(\"changeName\", \"Jane\", \"Roe\");\n  hm.log(\"firstName: \" + person.get(\"firstName\"));\n  hm.log(\"lastName: \" + person.get(\"lastName\"));", "url": "http://jsbin.com/UHeFadiD/1", "jsbin": true}
        ]},
        {"name": "node.set(force, [subPath,] value)", "returns": "Node", "shortDesc": "set a value to node in repository", "desc": "If force is true, and the workflow of the susbcription to \"beforeXxx\" event signal error,  error will be ignored.", "overloads": [
            {"versionAdded": "0.1", "name": "node.set(force, [subPath,] value)", "parameters": [
                {"name": "force", "type": "boolean", "desc": "is the operation by force"},
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"},
                {"name": "value", "type": "object", "desc": "value to set"}
            ]}
        ], "examples": [
            {"desc": "The following show how to set by force to suppress error in beforeCreate and beforeUpdate event", "code": "\n\n hm.handle(\"length\", \"beforeCreate beforeUpdate\", function (e) {\n    if (e.proposed > 100) {\n      hm.log(\"error happen in event '\" + e.type + \"'\", \"red\");\n      e.error(); \n    }\n  });\n  \n  //create\n  hm(\"length\", 200);\n  hm.log(\"the value is unchanged: \" + hm.get(\"length\"), \"green\");\n  hm(\"length\").set(true, 200);\n  hm.log(\"the value is changed to \" + hm.get(\"length\"));\n  \n  //update\n  hm(\"length\", 300);\n  hm.log(\"the value is unchanged: \" + hm.get(\"length\"), \"green\");\n  hm(\"length\").set(true, 300);\n  hm.log(\"the value is changed to \" + hm.get(\"length\"));", "url": "http://jsbin.com/uMeCelE/1", "jsbin": true}
        ]},
        {"name": "hm.set(fullPath, value, value2, ..)", "returns": "Node", "shortDesc": "it is shortcut to hm().set(fullPath, value, value2, ..)", "desc": "", "overloads": [], "examples": []},
        {"name": "hm.set(force, [subPath,] value)", "returns": "node", "shortDesc": "it is shortcut to hm().set(force, [subPath,] value)", "desc": "", "overloads": [], "examples": []}
    ]},
    {"name": "getJson", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.getJson()", "longDesc": "", "signatures": [
        {"name": "node.getJson([subPath,] [[parameter1, [parameter2], ..])", "returns": "string", "shortDesc": "Get the value of node and transform it to a json format string", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.getJson([subPath,] [[parameter1, [parameter2], ..])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "raw", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.raw()", "longDesc": "<p>Similar to the \"get\" or \"set\" method, you can use it to get or set a value to node in repository. Unlike these two methods, if the value of the node is an function, it will not call the function, instead it will just get a function or set the function.</p>", "signatures": [
        {"name": "node.raw([subPath])", "returns": "object.", "shortDesc": "get a value to a node in repository without conversion", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.raw([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to node"}
            ]}
        ], "examples": [
            {"desc": "", "code": " var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    fullName: function () {\n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\");\n    },\n    message: function(greeting) {\n      return greeting + \", \" + this.get(\"fullName\");\n    }\n  });\n  hm.log(\"---get---\");\n  hm.log(person.get(\"firstName\"));\n  hm.log(person.get(\"fullName\"));\n  hm.log(person.get(\"message\", \"Hello\"));\n  \n  \n  hm.log(\"---raw---\");\n  hm.log(person.raw(\"firstName\"));\n  hm.log(person.raw(\"fullName\"));\n  hm.log(person.raw(\"message\"));", "url": "http://jsbin.com/arUWOhO/1", "jsbin": true}
        ]},
        {"name": "node.raw(subPath, value)", "returns": "node", "shortDesc": "set a value to node in repository without conversion", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.raw(subPath, value)", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a sub-path relative to node "},
                {"name": "value", "type": "object", "desc": "the value to be set to the node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  var person = hm( \"person\", {\n\tfirstName: \"\",\n\tlastName: \"\",\n\tchangeName: function( firstName, lastName ) {\n\t\t//this point to the current model object\n\t\tthis.set( \"firstName\", firstName );\n\t\tthis.set( \"lastName\", lastName );\n\t}\n  });\n  \n  hm.log(\"----use 'set' to invoke function----\");\n  person.set(\"changeName\", \"John\", \"Doe\");\n  hm.log(person.get(\"firstName\"));\n  hm.log(person.get(\"lastName\"));\n  \n  \n  hm.log(\"----use 'raw' to overwrite function----\");\n  person.raw(\"changeName\", \"overwrite function value\");\n  hm.log(person.raw(\"changeName\"));\n", "url": "http://jsbin.com/IcaMoVIR/1", "jsbin": true}
        ]}
    ]},
    {"name": "accessor", "type": "", "namespace": "Node.Manipulation", "shortDesc": "naviagor.accessor()", "longDesc": "<p>This is low level api to access node in repository. It is normally internally used by node method, such as \"get\", \"set\". You can create custom node method with this method.</p>\n\n", "signatures": [
        {"name": "node.accessor()", "returns": "accessor object", "shortDesc": "get the accessor object of a model node.", "desc": "<p>It return an object like below.</p>\n\n<pre data-sub=\"prettyprint:._\">\n{\n  physicalPath: physicalPath,\n  hostObj: hostObj,\n  index: index\n}\n</pre>\n\n<p>\nThe hostObj points to the parent of the node which is being accessed.\n</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.accessor( [subPath], [readOnly])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a optional sub-path of model node"},
                {"name": "readOnly", "type": "boolean", "desc": "set to true, if you only use the accessor to read the model node. By default it is false"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  hm.fn.double = function () {\n    \n    var accessor  = this.accessor();    \n    \n    var items = accessor.hostObj[accessor.index];\n    var oldItems = hm.util.clone(items);\n    \n    for (var i = 0; i < items.length; i++) {\n        items[i] = items[i] * 2; \n    }\n    \n    this.trigger(\"doubled\", items, oldItems);\n    return this;\n    \n  };\n    \n  var items = hm(\"items\", [1, 2, 3]);\n  \n  items.handle(\"doubled\", function (e) {\n    hm.log(\"----doubled event dump-----\");\n    hm.log(\"items change from \" + JSON.stringify(e.removed) + \" to \" + JSON.stringify(e.proposed));  \n  });\n  \n  items.double();", "url": "http://jsbin.com/OFATEKUt/1", "jsbin": true}
        ]}
    ]},
    {"name": "create", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.create()", "longDesc": "insert a node at the path in repository. Most of time, you should use node.set method, it will this method if the  node does not exist.", "signatures": [
        {"name": "node.create( [force,] subPath, value)", "returns": "node", "shortDesc": "", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.create( [force,] subPath, value)", "parameters": [
                {"name": "force", "type": "boolean", "desc": "set to true if you want to skip triggering beforeCreate event"},
                {"name": "subPath", "type": "string", "desc": "sub-path relative to the node"},
                {"name": "value", "type": "object", "desc": "value to inserted"}
            ]}
        ], "examples": []}
    ]},
    {"name": "update", "type": "method", "namespace": "Node.Manipulation", "shortDesc": "node.update()", "longDesc": "update a node at the path in repository. Most of time, you should use node.set method, it will this method if the node already exists.", "signatures": [
        {"name": "node.update( [force,] subPath, value )", "returns": "node", "shortDesc": "", "desc": "\n", "overloads": [
            {"versionAdded": "0.1", "name": "node.update( [force,] [subPath,] value )", "parameters": [
                {"name": "force", "type": "boolean", "desc": "optional, by default it is false, set to true if you want to skip triggering \"beforeUpdate\" event."},
                {"name": "subPath", "type": "string", "desc": "optional, sub-path relative the node"},
                {"name": "value", "type": "object", "desc": "the value to set"}
            ]}
        ], "examples": []}
    ]},
    {"name": "extend", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.extend()", "longDesc": "", "signatures": [
        {"name": "node.extend(object)", "returns": "node", "shortDesc": "extend a model node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.extend(object)", "parameters": [
                {"name": "object", "type": "object", "desc": "an property bag to be extended to a model node"}
            ]}
        ], "examples": [
            {"desc": "", "code": " var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\"\n    \n  });\n  \n  person.extend({\n    fullName: function () {\n       return this.get(\"firstName\") + \",\" + this.get(\"lastName\"); \n    },\n    \n    greet: function () {\n      return \"hi\";  \n    }\n  \n  });\n  \n  \n  hm.log(person.get(\"fullName\"));\n  hm.log(person.get(\"greet\"));", "url": "http://jsbin.com/AFibaFe/1", "jsbin": true}
        ]}
    ]},
    {"name": "del", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.del()", "longDesc": "", "signatures": [
        {"name": "node.del([subPath])", "returns": "object", "shortDesc": "delete a node in repository, and return the deleted value", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.del([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative the node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  var name = hm(\"name\", \"John\");\n  \n  hm.log(name.del());\n  \n  hm.log(name.get());\n", "url": "http://jsbin.com/aVAwAMI/1", "jsbin": true}
        ]},
        {"name": "hm.del(subPath)", "returns": "object", "shortDesc": "a shortcut to hm().del(subPath), return the deleted value", "desc": "", "overloads": [], "examples": []}
    ]},
    {"name": "createIfUndefined", "type": "", "namespace": "Node.Manipulation", "shortDesc": "node.createIfUndefined()", "longDesc": "", "signatures": [
        {"name": "node.createIfUndefined(subPath, value)", "returns": "node", "shortDesc": "insert a node to repository if the node is not defined", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.createIfUndefined(subPath, value);", "parameters": [
                {"name": "subPath", "type": "string", "desc": "sub-path relative to the node"},
                {"name": "value", "type": "object", "desc": "a value to be inserted to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "pushStack", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.pushStack()", "longDesc": "", "signatures": [
        {"name": "node.pushStack(newNode)", "returns": "node", "shortDesc": "save the node to the new node's previous property, this method is used for traversal.", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.pushStack(newNode)", "parameters": [
                {"name": "newNode", "type": "node", "desc": "the new navgator"}
            ]}
        ], "examples": [
            {"desc": "", "code": "$(function () {\n\n  var first = hm(\"first\");\n  var second = hm(\"second\");\n  var secondCopy = first.pushStack(second);\n  hm.log(\"secondCopy == second : \" + (secondCopy === second));\n  hm.log(\"secondCopy.previous == first : \" + (secondCopy.previous === first));\n\n});", "url": "http://jsbin.com/iQAtAKuB/1", "jsbin": true}
        ]}
    ]},
    {"name": "Shadow Node", "type": "", "namespace": "Node", "shortDesc": "Shadow Node", "longDesc": "<p>In repository each node (main node) can have a shadow node.  They are normally use in <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=plugins\">plugins development</a>.\n</p>", "signatures": []},
    {"name": "cd", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.cd([subPath])", "longDesc": "", "signatures": [
        {"name": "node.cd([subPath])", "returns": "node", "shortDesc": "create new node at the path relative to the current node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.cd([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a optional sub-path relative to the current node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "$(function () {\n\n  var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\"\n  });\n  \n  hm.log('person.cd(\"firstName\").path == \"person.firstName\" : ' + (person.cd(\"firstName\").path == \"person.firstName\"));\n  \n  var firstName = person.cd(\"firstName\");\n  \n  hm.log('firstName.previous.path == \"person\": ' + (firstName.previous.path == \"person\"));\n  \n  hm.log('firstName.cd(\"..\").path == \"person\" : ' + (firstName.cd(\"..\").path == \"person\") );\n  \n  hm.log('firstName.cd(\"/\").path === \"\"' + (firstName.cd(\"/\").path === \"\"));\n  \n  hm.log('firstName.cd(\"...\").path === \"\"' + (firstName.cd(\"...\").path === \"\"));\n  \n  hm.log('firstName.cd(\"*\").path == hm(\"person.firstName*\").path) : ' + (firstName.cd(\"*\").path == hm(\"person.firstName*\").path));\n\n  var firstNameShadow = firstName.cd(\"*\");\n  \n  hm.log('firstName.main().path == \"person.firstName\" : ' + (firstName.main().path == \"person.firstName\"));\n  \n  hm.log('firstName.shadow().path === firstNameShadow.path : ' + (firstName.shadow().path === firstNameShadow.path));\n  });", "url": "http://jsbin.com/agIFEYa/1", "jsbin": true}
        ]}
    ]},
    {"name": "parent", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.parent()", "longDesc": "this is equivalent  to node.cd(\"..\")", "signatures": []},
    {"name": "sibling", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.sibling(path)", "longDesc": "This is a shortcut to node.cd(\"..\" + path);", "signatures": []},
    {"name": "Manipulation", "type": "", "namespace": "Node", "shortDesc": "Manipulation", "longDesc": "", "signatures": []},
    {"name": "Navigation", "type": "", "namespace": "Node", "shortDesc": "Navigation", "longDesc": "", "signatures": []},
    {"name": "main", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.main()", "longDesc": "", "signatures": [
        {"name": "node.main()", "returns": "node", "shortDesc": "If current node is a shadow object, return its main object", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.main()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "$(function () {\n\n  hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\"\n  });\n \n  hm.log(hm(\"person.firstName*x\").main().logicalPath());\n  hm.log(hm(\"person.firstName*x*y\").main().logicalPath());\n  hm.log(hm(\"person.firstName*x*y*z\").main().logicalPath());\n  \n});", "url": "http://jsbin.com/ozerUbi/1", "jsbin": true}
        ]}
    ]},
    {"name": "shadow", "type": "", "namespace": "Node.Navigation", "shortDesc": "node.shadow()", "longDesc": "This is a shortcut of node.cd(\"*\"), it return the shadow node of the current node.", "signatures": []},
    {"name": "Path", "type": "", "namespace": "Node", "shortDesc": "Path", "longDesc": "<p>There two kind of path, absolute path, and sub-path (relative path).  The absolute path start from root, sub-path start from current node. In the following, you use absolute path.</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm(\"person.firstName\", \"John\");\nhm.get(\"person.firstName\");\nhm.subscribe(\"person.firstName\", $(\"#txtFirstName\"), handler);\n$(\"#lable\").sub(\"person.firstName\", \"afterUpdate\", handler);\n</pre>\n\n<p>The following code use sub-path.\n<p>\n\n<pre data-sub=\"prettyprint:_\">\nnode.cd(\"..\");\nnode.set(\"firstName\", \"John\");\nnode.getPath(\"firstName\");\n</pre>\n\n<p>The following is summary of path calculation.  One special path is subPath is \"_\", it is used in subscription when subscriber is \"_\", it means subscriber is null. For demo, please see <a target=\"_blank\" href=\"http://jsbin.com/ItELEMa/1/edit\">this</a>.\n</p>\n\n<table class=\"code\"><tbody><tr><th>context path</th><th>sub path</th><th>merge path</th></tr><tr><td>person</td><td>firstName</td><td>person.firstName</td></tr><tr><td>person</td><td>.firstName</td><td>person.firstName</td></tr><tr><td>person.firstName</td><td>..</td><td>person</td></tr><tr><td>app.person.firstName</td><td>...</td><td>app</td></tr><tr><td>person</td><td>phone.home</td><td>person.phone.home</td></tr><tr><td>person</td><td>*validations</td><td>person*validations</td></tr><tr><td>person</td><td>*validations.1</td><td>person*validations.1</td></tr><tr><td>person.firstName</td><td>/</td><td></td></tr><tr><td>person</td><td>/addresses.0</td><td>addresses.0</td></tr><tr><td>person</td><td>_</td><td>_</td></tr><tr><td>person*edit.item</td><td>&lt;</td><td>person</td></tr><tr><td>person*edit.item</td><td>&lt;*edit.selectedIndex</td><td>person*edit.selectedIndex</td></tr><tr><td>person*edit.item</td><td>&lt;firstName</td><td>person.firstName</td></tr></tbody></table>", "signatures": []},
    {"name": "getPath", "type": "", "namespace": "Node.Path", "shortDesc": "node.getPath([subPath])", "longDesc": "", "signatures": [
        {"name": "node.getPath([subPath])", "returns": "string", "shortDesc": "combine node.path and sub-path in to a full path", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.getPath([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a optional sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "logicalPath", "type": "", "namespace": "Node.Path", "shortDesc": "node.logicalPath([subPath])", "longDesc": "<p>We use \"*\" to access shadow object, Hm.js will convert the shadow path in to a physical path, which is not user friendly. for example logical path \"a*b*c*d\" will be converted to \"__hm.__hm#__hm##a##b#c.d\" . For debugging purpose, we want to use convert the physical path into a logical path which is user friendly.\n</p>", "signatures": [
        {"name": "node.logicalPath([subPath])", "returns": "string", "shortDesc": "get a logical path from node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.logicalPath([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a optional sub-path relative to the node"}
            ]}
        ], "examples": []},
        {"name": "hm.util.toLogicalPath(path)", "returns": "string", "shortDesc": "convert a path into logicalPath", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.util.toLogicalPath(path)", "parameters": [
                {"name": "path", "type": "string", "desc": "a full path"}
            ]}
        ], "examples": []}
    ]},
    {"name": "physicalPath", "type": "", "namespace": "Node.Path", "shortDesc": "node.physicalPath([subPath])", "longDesc": "", "signatures": [
        {"name": "node.physicalPath([subPath])", "returns": "string", "shortDesc": "combine sub-path with node's path and return a physical path", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.physicalPath([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "a optional sub-path relative to node"}
            ]}
        ], "examples": []},
        {"name": "hm.util.toPhysicalPath(fullPath)", "returns": "string", "shortDesc": "convert a path to physical path", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.util.toPhysicalPath(fullPath)", "parameters": [
                {"name": "fullPath", "type": "string", "desc": "a full path"}
            ]}
        ], "examples": []}
    ]},
    {"name": "pathContext", "type": "", "namespace": "Node.Path", "shortDesc": "node.pathContext()", "longDesc": "", "signatures": [
        {"name": "node.pathContext()", "returns": "string", "shortDesc": "return the context part of path", "desc": "If a path is \"a.b.c\", the the context part is \"a.b\"", "overloads": [], "examples": []}
    ]},
    {"name": "pathIndex", "type": "", "namespace": "Node.Path", "shortDesc": "node.pathIndex()", "longDesc": "", "signatures": [
        {"name": "node.pathIndex()", "returns": "string", "shortDesc": "return the index part of path", "desc": "If node's path is \"a.b.c\", it returns \"c\"", "overloads": [], "examples": []}
    ]},
    {"name": "Array Node", "type": "", "namespace": "Node", "shortDesc": "Array Node", "longDesc": "These section contains the node methods specific for array node.  These methods should be used for array nodes only. If they are used for non-array nodes, exception will be throw.", "signatures": []},
    {"name": "indexOf", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.indexOf(item)", "longDesc": "", "signatures": [
        {"name": "node.indexOf(item)", "returns": "number", "shortDesc": "return the index of the item in the array", "desc": "If the item is in the array, return the index of the item in the array, otherwise return -1.", "overloads": [
            {"versionAdded": "0.1", "name": "node.indexOf(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "the object to be searched inside the array."}
            ]}
        ], "examples": [
            {"desc": "", "code": "  hm(\"items\", [1, 2, 3]);\n  hm.log(items.indexOf(3));\n", "url": "http://jsbin.com/aNuteMeJ/1", "jsbin": true}
        ]}
    ]},
    {"name": "contains", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.contains(item)", "longDesc": "", "signatures": [
        {"name": "node.contains(item)", "returns": "boolean", "shortDesc": "", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.contains(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "the object to be searched in the array"}
            ]}
        ], "examples": [
            {"desc": "", "code": " var items = hm(\"items\", [1, 2, 3]);\n  hm.log(items.contains(3));\n  hm.log(items.contains(4));", "url": "http://jsbin.com/aNuteMeJ/1", "jsbin": true}
        ]}
    ]},
    {"name": "first", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.first()", "longDesc": "", "signatures": [
        {"name": "node.first()", "returns": "object", "shortDesc": "return the first item of the array", "desc": "", "overloads": [], "examples": [
            {"desc": "", "code": "hm(\"items\", [1, 2, 3]);\nhm.log(\"the first item is \" + items.first());", "url": "http://jsbin.com/ODuJexun/1", "jsbin": true}
        ]}
    ]},
    {"name": "last", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.last()", "longDesc": "", "signatures": [
        {"name": "node.last()", "returns": "object", "shortDesc": "return the last item of array node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.last()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "var items =  hm(\"items\", [1, 2, 3]);\n hm.log(\"the last items is \" + items.last());\n", "url": "http://jsbin.com/AhiLiSIR/1", "jsbin": true}
        ]}
    ]},
    {"name": "push", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.push(item)", "longDesc": "", "signatures": [
        {"name": "node.push(item)", "returns": "node", "shortDesc": "push an item into array node", "desc": "<p>This method will raise an event \"afterCreate.x\" (x is the index of last item in the array, if current array length is 3, then x is 3).</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.push(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "array item"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  var items = hm(\"items\", [1, 2, 3]);\n  \n  items.handle(\"*\", function (e) {\n    hm.log(\"item '\" + e.proposed + \"' is created at path '\" + e.originalPublisher.path + \"'\");\n  });\n \n  items.push(4, 5);\n  hm.log(\"the last item is \" + items.toJSON());", "url": "http://jsbin.com/oMaZoWO/1", "jsbin": true}
        ]}
    ]},
    {"name": "pushUnique", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.pushUnique(item)", "longDesc": "", "signatures": [
        {"name": "node.pushUnique(item)", "returns": "node", "shortDesc": "push an item into an array node if it does not exists in the array", "desc": "This might trigger and \"afterCreate\" event", "overloads": [
            {"versionAdded": "0.1", "name": "node.pushUnique(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "an object to be pushed into the array node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  var items = hm(\"items\", [1, 2, 3]);\n\n  items.pushUnique(1); \n  \n  hm.log(items.toJSON());\n  \n  items.pushUnique(4);\n  \n  hm.log(items.toJSON());\n", "url": "http://jsbin.com/InEzEzAW/1", "jsbin": true}
        ]}
    ]},
    {"name": "pop", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.pop()", "longDesc": "", "signatures": [
        {"name": "node.pop()", "returns": "object", "shortDesc": "remove the item from tail of an array node, and return the item", "desc": "This make trigger \"beforeDel\" and \"afterDel\" event.", "overloads": [
            {"versionAdded": "0.1", "name": "navgiator.pop()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": " var items = hm(\"items\", [1, 2, 3]);\n  \n  items.handle(\"*\", function (e) {\n    hm.log(\"event: \" + e.originalType  + \" triggered at path: \" + e.originalPublisher.path + \", removing item \" + e.removed);\n  });\n  \n  items.pop();\n  hm.log(items.toJSON());", "url": "http://jsbin.com/unUPIdUQ/1", "jsbin": true}
        ]}
    ]},
    {"name": "invokeUnwrapped", "type": "", "namespace": "Node.Manipulation", "shortDesc": "invokeUnwrapped", "longDesc": "We can call a function node in repository using <code>node.set()</code> method. Inside the method,  the \"this\" variable refer to the parent of the node. Another way to call a function node is to use <code>node.invokeUnwrapped</code>, the  \"this\" variable in the function refer to the parent of raw object.", "signatures": [
        {"name": "node.invokeUnwrapped(methodName, [p1, [p2, ..]]", "returns": "object", "shortDesc": "call a function node in repository in the context of parent node.", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.invoke(methodName, [p1, [p2, ..]]", "parameters": [
                {"name": "methodName", "type": "string", "desc": "the function name of the node"}
            ]}
        ], "examples": [
            {"desc": "This example compare the difference between calling a function use \"set\" method and \"invoke\" method.", "code": "var person = hm(\"person\", {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  changeName: function (firstName, lastName) {\n    this.set(\"firstName\", firstName);\n    this.set(\"lastName\", lastName);\n  },\n  directChangeName: function (firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    person.trigger(\"nameChanged\");\n  }\n});\n\nperson.handle(\"*\", function (e) {\n   hm.log(\"event: \" + e.originalType + \" path: \" + e.originalPublisher.path);\n});\n  \n  hm.log(\"---call node function using node.set ----\");\nperson.set(\"changeName\", \"Jane\", \"Roe\");\n  \n  hm.log(\"---call node function using node.invokeUnwrapped ----\");\nperson.invokeUnwrapped(\"directChangeName\", \"Mark\", \"Moe\");", "url": "http://jsbin.com/orenIjiz/1", "jsbin": true}
        ]}
    ]},
    {"name": "shift", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.shift()", "longDesc": "", "signatures": [
        {"name": "node.shift()", "returns": "object", "shortDesc": "remove an item from the head of an array node. and return the value of the item.", "desc": "This will trigger \"beforeDel\" and \"afterDel\" event.", "overloads": [
            {"versionAdded": "0.1", "name": "node.shift()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \n  items.handle(\"*\", function (e) {\n    hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", removing item \" + e.removed);\n});\n  \n\n  var item = items.shift();\n  hm.log(item);\n  hm.log(items.toJSON());\n  ", "url": "http://jsbin.com/OpeCisu/1", "jsbin": true}
        ]}
    ]},
    {"name": "unshift", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.unshift(item)", "longDesc": "", "signatures": [
        {"name": "node.unshift(item)", "returns": "node", "shortDesc": "prepend an item to an array node.", "desc": "This will trigger \"beforeCreate\" and \"afterCreate\" event", "overloads": [
            {"versionAdded": "0.1", "name": "node.unshift(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "the item be added to the array"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", removing item \" + e.removed);\n});\n  \nitems.unshift(4);\n  ", "url": "http://jsbin.com/eqAKikIs/1", "jsbin": true}
        ]}
    ]},
    {"name": "insertAt", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.insertAt(index, item)", "longDesc": "", "signatures": [
        {"name": "node.insertAt(index, item)", "returns": "node", "shortDesc": "insert an item to the array node", "desc": "This will trigger \"afterDel\" and \"beforeDel\" event", "overloads": [
            {"versionAdded": "0.1", "name": "node.insertAt(index, item)", "parameters": [
                {"name": "index", "type": "number", "desc": "the index in the array for the item to be inserted at"},
                {"name": "item", "type": "object", "desc": "the object to add to the array node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", value: \" + e.proposed);\n});\n  \nitems.insertAt(2, 4);\n  ", "url": "http://jsbin.com/UvAVeXiD/1", "jsbin": true}
        ]}
    ]},
    {"name": "updateAt", "type": "", "namespace": "Node.Array Node", "shortDesc": "hm.updateAt(index, item)", "longDesc": "", "signatures": [
        {"name": "hm.updateAt(index, item)", "returns": "node", "shortDesc": "update an item in array node at an index position", "desc": "<p>\nThis will trigger \"beforeUpdate\" and \"afterUpdate\" method\n</p>", "overloads": [
            {"versionAdded": "0.1", "name": "hm.updateAt(index, item)", "parameters": [
                {"name": "index", "type": "number", "desc": "the index in array node where an item should be updated at"},
                {"name": "item", "type": "object", "desc": "the new value to be updated with"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.updateAt(1, 4);", "url": "http://jsbin.com/gikiw/1", "jsbin": true}
        ]}
    ]},
    {"name": "removeAt", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.removeAt(index)", "longDesc": "", "signatures": [
        {"name": "node.removeAt(index)", "returns": "object", "shortDesc": "remove the item at the index in an array node", "desc": "<p>\nThis will trigger \"beforeDel\" and \"afterDel\" event\n</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.removeAt(index)", "parameters": [
                {"name": "index", "type": "number", "desc": "the index of item to be removed from array node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.removeAt(1);", "url": "http://jsbin.com/mesar/1", "jsbin": true}
        ]}
    ]},
    {"name": "move", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.move(fromIndex, toIndex)", "longDesc": "", "signatures": [
        {"name": "node.move(fromIndex, toIndex)", "returns": "node", "shortDesc": "move a item in an array from one slot to another slot", "desc": "<p>What the method does is to delete an item at a index, and create an item at a new index. This will trigger events like \"beforeDel\", \"afterDel\", \"beforeCreate\", \"afterCreate\", and \"move\". \n</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.move(fromIndex, toIndex)", "parameters": [
                {"name": "fromIndex", "type": "number", "desc": "the index of the item to be moved"},
                {"name": "toIndex", "type": "number", "desc": "the new index of the item to be moved to"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.move(0, 2);", "url": "http://jsbin.com/yagag/1", "jsbin": true}
        ]}
    ]},
    {"name": "replaceItem", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.replaceItem(oldItem, newItem)", "longDesc": "", "signatures": [
        {"name": "node.replaceItem(oldItem, newItem)", "returns": "node", "shortDesc": "This will find the old item in a array node, and replace it with a new item. If the old item is not found, no change will be make", "desc": "<p>This will trigger \"beforeUpdate\" and \"afterUpdate\".</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.replaceItem(oldItem, newItem)", "parameters": [
                {"name": "oldItem", "type": "object", "desc": "the item to be updated in array"},
                {"name": "newItem", "type": "object", "desc": "the new item to updated to."}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.replaceItem(3, 4);", "url": "http://jsbin.com/wuwuy/1", "jsbin": true}
        ]}
    ]},
    {"name": "removeItem", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.removeItem(item)", "longDesc": "", "signatures": [
        {"name": "node.removeItem(item)", "returns": "node", "shortDesc": "find an item in an array node, and delete it. If item is not found, no change will be made.", "desc": "<p>This may trigger \"beforeDel\" and \"afterDel\"</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.removeItem(item)", "parameters": [
                {"name": "item", "type": "object", "desc": "the item to be remove"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.removeItem(3);", "url": "http://jsbin.com/togok/1", "jsbin": true}
        ]}
    ]},
    {"name": "removeItems", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.removeItems(items)", "longDesc": "", "signatures": [
        {"name": "node.removeItems(items)", "returns": "node", "shortDesc": "This remove a set of items from the array.", "desc": "<p>This may trigger a series of \"beforeDel\" and \"afterDel\"</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.removeItems(items)", "parameters": [
                {"name": "items", "type": "Array", "desc": "an array of items to be removed from an array node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + e.proposed + \" old value: \" + e.removed);\n});\n  \nitems.removeItems([1, 3]);", "url": "http://jsbin.com/terik/1", "jsbin": true}
        ]}
    ]},
    {"name": "clear", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.clear()", "longDesc": "", "signatures": [
        {"name": "node.clear()", "returns": "node", "shortDesc": "remove all item in a array node", "desc": "<p>This will remove all items in the array, and trigger \"afterCreate\" event.</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.clear()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\n  \nitems.handle(\"*\", function (e) {\n  hm.log(\"event: \" + e.originalType + \" triggered at path: \" + e.originalPublisher.path + \", new value: \" + JSON.stringify(e.proposed) + \" old value: \" + JSON.stringify(e.removed));\n});\n  \nitems.clear();\n  ", "url": "http://jsbin.com/beqec/1", "jsbin": true}
        ]}
    ]},
    {"name": "count", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.count()", "longDesc": "", "signatures": [
        {"name": "node.count()", "returns": "number", "shortDesc": "return the count of items in array node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.count()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 2, 3]);\nhm.log(items.count());\n", "url": "http://jsbin.com/deguc/1", "jsbin": true}
        ]}
    ]},
    {"name": "filter", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.filter(fn)", "longDesc": "", "signatures": [
        {"name": "node.filter(fn)", "returns": "array", "shortDesc": "filter the items in an array node, return the filtered result", "desc": "<p>\nThe function is like\n</p>\n\n<pre data-sub=\"prettyprint:.\">\nfunction (index, item) {\n  //return true or false;\n}\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "node.filter(fn)", "parameters": [
                {"name": "fn", "type": "Function", "desc": "filtered function"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var items = hm(\"items\", [1, 12, 2, 3, 7, 6]);\n\nvar over3Items = items.filter(function (index, item) {\n    return (item > 3);\n});\n\nhm.log(JSON.stringify(over3Items));\n", "url": "http://jsbin.com/vomof/1", "jsbin": true}
        ]}
    ]},
    {"name": "each", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.each(fn)", "longDesc": "", "signatures": [
        {"name": "node.each(fn)", "returns": "node", "shortDesc": "process each items in an array node with a function", "desc": "<p>The function is like: </p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (index, currentNode, parentNode) {\n  //this == currentNode\n  //parentNode.path == currentNode.parent().path\n  //process item like\n  // this.set(this.get()*2);\n   //or\n   //this.del();\n}\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "node.each(fn)", "parameters": [
                {"name": "fn", "type": "Function", "desc": "the process function"}
            ]}
        ], "examples": [
            {"desc": "The following update each items individually, each update will trigger its own events.", "code": "var items = hm(\"items\", [1, 2, 3]);\n\nitems.handle(\"*\", function (e) {\n  hm.log(\"node: \" + e.originalPublisher.path  + \" event: \" + e.originalType);\n});\n  \nitems.each(function (index, currentNode, parentNode) {\n  this.set(this.get()*2);\n});", "url": "http://jsbin.com/zibiw/1", "jsbin": true}
        ]},
        {"name": "node.each(directAccess, fn)", "returns": "node", "shortDesc": "process the items in array in a function, where you change the items directly, so that no event will be triggered for each item", "desc": "<p>You can improve the efficiency by process item directly. For example, instead of updating each item individually, you can batch update the items. The function is like:</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (index, item, items) {\n  //process items, such as items[index] = item * 2;\n  //return true if you have change the item, and afterUpdate \n  //event will be trigger for array node\n  //return false when you want to stop processing in remaining item\n  //otherwise, return undefined\n});\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "node.each(directAccess, fn)", "parameters": [
                {"name": "directAccess", "type": "Boolean", "desc": "true if the fn process the item directly, otherwise false"},
                {"name": "fn", "type": "Function", "desc": "the process function"}
            ]}
        ], "examples": [
            {"desc": "The follow batch update the items, only one event is triggered.", "code": "var items = hm(\"items\", [1, 2, 3]);\n\nitems.handle(\"*\", function (e) {\n  hm.log(\"node: \" + e.originalPublisher.path  + \" event: \" + e.originalType);\n});\n  \nitems.each(true, function (index, item, items) {\n  items[index] = item * 2;\n  return true;\n});\n", "url": "http://jsbin.com/hifor/1", "jsbin": true}
        ]}
    ]},
    {"name": "sort", "type": "", "namespace": "Node.Array Node", "shortDesc": "node.sort()", "longDesc": "", "signatures": [
        {"name": "node.sort()", "returns": "node", "shortDesc": "sort an array node", "desc": "<p>\nThis method can sort the items (either object or primitive type). The method call will trigger \"afterUpdate\" event on the array items.\n</p>", "overloads": [
            {"versionAdded": "0.1", "name": "node.sort([asc])", "parameters": [
                {"name": "asc", "type": "boolean", "desc": "true of sort by asc, otherwise false. The default is true"}
            ]},
            {"versionAdded": "0.1", "name": "node.sort(propertyName[, asc])", "parameters": [
                {"name": "propertyName", "type": "string", "desc": "the name of a property of item object"},
                {"name": "asc", "type": "boolean", "desc": "true of sort by asc, otherwise false. The default is true"}
            ]}
        ], "examples": [
            {"desc": "The following sort a array of simple type, such as number", "code": "var items = hm(\"items\", [5, 2, 9, 4, 2, 7]);\n\n\nitems.handle(\"*\", function (e) {\n  hm.log(\"node: \" + e.originalPublisher.path  + \" event: \" + e.originalType + \" value: \" + e.publisher.getJson());\n});\n\nhm.log(\"--sorting primitive number---\", \"red\");  \nitems.sort(); //by default sort by asc\nitems.sort(false);  \n  \n  var objItems = hm(\"objItems\", [\n    { id: 5, name: \"John\" },\n    { id: 2, name: \"Tom\" },\n    { id: 9, name: \"Amy\" },\n    { id: 4, name: \"Zoe\" }\n  ]);\n\nobjItems.handle(\"*\", function (e) {\n  hm.log(\"node: \" + e.originalPublisher.path  + \" event: \" + e.originalType + \" value: \" + e.publisher.getJson());\n});\n\nhm.log(\"--sorting objects---\", \"red\");\nobjItems.sort(\"id\");  \nobjItems.sort(\"id\", false); \nobjItems.sort(\"name\");  \nobjItems.sort(\"name\", false);", "url": "http://jsbin.com/jatan/1", "jsbin": true}
        ]}
    ]},
    {"name": "Utilities", "type": "", "namespace": "Node", "shortDesc": "Utilities", "longDesc": "", "signatures": []},
    {"name": "isEmpty", "type": "", "namespace": "Node.Utilities", "shortDesc": "node.isEmpty()", "longDesc": "", "signatures": [
        {"name": "node.isEmpty([subPath])", "returns": "Boolean", "shortDesc": "check if the value of the node is emtpy", "desc": "If the node does not exists, or its value is undefined, false, empty string, it will return true, otherwise false", "overloads": [
            {"versionAdded": "0.1", "name": "node.isEmpty([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  hm.log(hm().isEmpty(\"unExistNode\"));\n  //\n  hm(\"emptyString\", \"\");\n  hm.log(hm(\"emptyString\").isEmpty());\n  //\n  hm(\"booleanValue\", false);\n  hm.log(hm(\"booleanValue\").isEmpty());\n  //\n  hm.set(\"undefinedValue\", undefined);\n  hm.log(hm(\"undefinedValue\").isEmpty());", "url": "http://jsbin.com/zahup/1", "jsbin": true}
        ]}
    ]},
    {"name": "isShadow", "type": "", "namespace": "Node.Utilities", "shortDesc": "node.isShadow()", "longDesc": "", "signatures": [
        {"name": "node.isShadow()", "returns": "Boolean", "shortDesc": "determine if the node is a shadow object.", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.isShadow()", "parameters": []}
        ], "examples": [
            {"desc": "", "code": "  var notShadow = hm(\"test\", {});\n  hm.log(notShadow.isShadow());\n  //\n  var shadow = notShadow.cd(\"*\");\n  hm.log(shadow.isShadow());", "url": "http://jsbin.com/pinor/1", "jsbin": true}
        ]}
    ]},
    {"name": "toJSON", "type": "", "namespace": "Node.Utilities", "shortDesc": "node.toJSON([subPath])", "longDesc": "", "signatures": [
        {"name": "node.toJSON([subPath])", "returns": "String", "shortDesc": "return JSON format for the value of the node", "desc": "<p>This is shortcut to JSON.stringify( this.get( subPath ) )</p>", "overloads": [], "examples": []}
    ]},
    {"name": "compare", "type": "", "namespace": "Node.Utilities", "shortDesc": "node.compare(expression)", "longDesc": "", "signatures": [
        {"name": "node.compare([expression])", "returns": "Boolean", "shortDesc": "compare the value of the node with an optional expression", "desc": "<p>If the expression is missing, be behave like node.isEmpty(). If the expression is string, it will try to convert the string into a typed object then compare whether they are equal. You can also specify operator in the expression. </p>\n", "overloads": [
            {"versionAdded": "0.1", "name": "node.compare([expression])", "parameters": [
                {"name": "expression", "type": "object", "desc": "optional expression to be compared"}
            ]}
        ], "examples": [
            {"desc": "", "code": "var number = hm(\"number\", 5);\nvar string = hm(\"string\", \"abc\");\n\nhm.log(\"--the following return true --\", \"red\");\n//\n//behave like noexistNode.isEmpty()\nhm.log(hm(\"noexistNode\").compare());\n//use \"==\"\nhm.log(number.compare(5));\nhm.log(number.compare('5'));\nhm.log(string.compare(\"abc\"));\n//use eval\nhm.log(number.compare(\">3\"));\nhm.log(number.compare(\"==4+1\"));\nhm.log(number.compare(\"==5\"));\nhm.log(number.compare(\"=='5'\"));\nhm.log(string.compare(\"=='abc'\"));\n//\nhm.log(\"--the following return false --\", \"red\");\n//\n//behave like number.isEmpty()\nhm.log(number.compare()); \nhm.log(string.compare());\n//use \"==\"\nhm.log(number.compare(\"abc\"));\nhm.log(number.compare(7));\nhm.log(number.compare(\"7\"));\nhm.log(string.compare(\"abd\"));\n//use eval\nhm.log(number.compare(\"==='5'\"));\nhm.log(string.compare(\"=='abd'\"));\nhm.log(number.compare(\"4+1\"));", "url": "http://jsbin.com/nareb/1", "jsbin": true}
        ]}
    ]},
    {"name": "LocalStorage", "type": "", "namespace": "Node", "shortDesc": "LocalStorage", "longDesc": "<p>In this category, there are a couple of method that help to save data in repository to local storage,and restore them from local storage. Here some example.</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/ujowoh/3\">\nvar person = hm(\"person\", {\n  firstName: \"John\",\n  lastName: \"Doe\"\n});\n\n\nhm.log(\"initially there is no data in local storage\", \"red\");\nhm.log(JSON.stringify(person.getLocal()));\n\nhm.log(\"save the node to localStorage\", \"red\");\nperson.saveLocal();\nhm.log(\"retrieve it from localStorage\", \"red\");\nhm.log(JSON.stringify(person.getLocal()));\n\nhm.log(\"del the node\", \"red\");\nperson.del();\nhm.log(\"now the node is empty\", \"red\");\nhm.log(person.toJSON());\n\nhm.log(\"restore the node from local storage\", \"red\");\nperson.restoreLocal();\nhm.log(\"now the node is restored\");\nhm.log(person.toJSON());\n\nhm.log(\"clear the storage\", \"red\");\nperson.clearLocal();\n\nhm.log(\"now the local storage is gone\", \"red\");\nhm.log(JSON.stringify(person.getLocal()));\n</pre>", "signatures": []},
    {"name": "saveLocal", "type": "", "namespace": "Node.LocalStorage", "shortDesc": "node.saveLocal([subPath])", "longDesc": "", "signatures": [
        {"name": "node.saveLocal([subPath])", "returns": "node", "shortDesc": "save the node value to localStorage in browser", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.saveLocal([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "getLocal", "type": "", "namespace": "Node.LocalStorage", "shortDesc": "node.getLocal([subPath])", "longDesc": "", "signatures": [
        {"name": "node.getLocal([subPath])", "returns": "object", "shortDesc": "get the data from local storage of browser for the node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.getLocal([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "restoreLocal", "type": "", "namespace": "Node.LocalStorage", "shortDesc": "node.restoreLocal([subPath])", "longDesc": "", "signatures": [
        {"name": "node.restoreLocal([subPath])", "returns": "node", "shortDesc": "restore the data in local storage in browser to the the node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.restoreLocal([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "clearLocal", "type": "", "namespace": "Node.LocalStorage", "shortDesc": "node.clearLocal([subPath])", "longDesc": "", "signatures": [
        {"name": "node.clearLocal([subPath])", "returns": "node", "shortDesc": "remove the data in local storage of the node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.clearLocal([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "Model Event", "type": "", "namespace": "Unified Subscription", "shortDesc": "Model Event", "longDesc": "<p>\nThe model events are triggered during model is manipulated via node method.  They can be propagated vertically from bottom to top in repository, this is called event propagation or  event bubbling. They can also be cascaded from horizontally in repository, this is called event cascading.\n</p>", "signatures": []},
    {"name": "View Event", "namespace": "Unified Subscription", "shortDesc": "View Event", "longDesc": "View Event is handled by <a href=\"http://api.jquery.com/category/events/\">jQuery events</a>.", "signatures": []},
    {"name": "Event Bubbling", "type": "", "namespace": "Unified Subscription.Model Event", "shortDesc": "Event Bubbling", "longDesc": "<p>When a model node trigger an event, the event can be bubbled up to its parents, until reach the root of repository. The following is an example.\n</p>\n\n<pre  prettyprint preview=\".|http://jsbin.com/losak/1\">\n  var person = hm(\"person\", {\n    firstName: \"Jone\",\n    lastName: \"Doe\",\n    phones: [\n      { number: \"444-4444\", type: \"home\" },\n      { number: \"888-8888\", type: \"cell\" }\n    ]\n  });\n  \n  //bind a handler to the person node, which can handle \n  //all the events of itself and its sub-nodes\n  person.handle(\"*\", function (e) {\n    hm.log(\"e.type: \" + e.type + \", e.orginalType: \" + e.originalType + \"e.publisher.path: \" + e.publisher.path + \", e.originalPublisher.path: \" + e.originalPublisher.path);\n  });\n  \n  hm.log(\"--event triggered inside of node method--\", \"red\");\n  //person.set(\"firstName\", \"Jane\");\n  person.set(\"phones.0.number\", \"333-3333\");\n  \n  hm.log(\"--explicitly trigger custom events --\", \"red\");\n  person.cd(\"phones.1.number\").trigger(\"myEvent\");\n</pre>\n\n\n", "signatures": []},
    {"name": "Event Cascading", "type": "", "namespace": "Unified Subscription.Model Event", "shortDesc": "Event Cascading", "longDesc": "<p>When an event is triggered to a model node (A) which is referenced by another node (B),  the event will be triggered to the node (B), and this is called event cascading. In the following example, the \"fullName\" node is a function. </p>\n\n<p>In the following example,  a person node is added to the repository, hm.js automatically infer that \"fullName\" node references \"firstName\" node and \"lastName\" by parsing the source code of the function.  When an event is triggered to \"firstName\" or \"lastName\", this event will be cascaded to the \"fullName\" node. \n</p>\n\n<pre  prettyprint preview=\"_|http://jsbin.com/dudos/1\">\n  var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    fullName: function () {\n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\"); \n    }\n  });\n  \n  //handler bind to fullName node\n  person.cd(\"fullName\").handle(\"afterUpdate\", function (e) {\n    hm.log(\"fullName is changed caused by \" + e.originalPublisher.path + \" and is now \" + e.publisher.get());\n  });\n  \n  person.set(\"firstName\", \"Jane\");\n \n</pre>\n<h3>Combine event bubbling and event cascading</h3>\n<p>\nHm.js can support event bubbling and cascading at the same time. In the following the event cascade from \"firstName\" node to \"fullName\" node, and bubble up from \"fullName\" node to \"person\" node. The event handler is attached person node, and it can handle \"afterUpdate\" event of its children.\n</p>\n\n<pre  prettyprint preview=\"_|http://jsbin.com/qapen/1\">\n var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    fullName: function () {\n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\"); \n    }\n  });\n  \n  //handler bind to person node\n  person.handle(\"afterUpdate.*\", function (e) {\n    hm.log(\"original publisher \" + e.originalPublisher.path + \" and its value is \" + e.originalPublisher.get());\n  });\n  \n \n  //event trigger on \"firstName\"\n  person.set(\"firstName\", \"Jane\");\n</pre>\n\n", "signatures": []},
    {"name": "Special Events", "namespace": "Unified Subscription.Model Event", "shortDesc": "Special Events", "longDesc": "<h3>catch-all event *</h3>\n<p>Normally, when we want to capture a event, we use the exact name of the event, like the following, \"click\" and \"dblclick\" is the exact name of the events.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n$(\"#button\").bind(\"click dblclick\", function () { });\n</pre>\n\n<p>\nIn repository event, we can use wildcard character \"*\" to capture multiple events. For example\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/vatam/1\">\n var person = hm(\"person\", {\n    firstName: \"Jone\",\n    lastName: \"Doe\",\n    fullName: function () {\n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\");\n    },\n    phones: [\n      { number: \"444-4444\", type: \"home\" },\n      { number: \"888-8888\", type: \"cell\" }\n    ]\n  });\n  \n  //bind a handler to the person node, which can handle \n  //all the events of itself and its sub-nodes\n  person.handle(\"*\", function (e) {\n    hm.log(\n      \"type: \" + e.type + \n      \", orginal type: \" + e.originalType + \n      \", path: \" + e.publisher.path + \n      \", original path: \" + e.originalPublisher.path + \n      \", original value: \" + e.originalPublisher.get()\n      );\n  });\n  \n  \n  person.set(\"firstName\", \"Jane\");\n  person.set(\"phones.0.number\", \"333-3333\");\n  person.cd(\"phones.1.number\").trigger(\"myEvent\");\n</pre>\n\n<p>\nThe match pattern of \"*\" event name is same as the pattern in matching file names in DOS. The following shows the match pattern.\n</p>\n<table>\n<col width=\"120px\">\n\t\t<tbody><tr>\n\t\t\t<td>Match pattern</td>\n\t\t\t<td>Event matched</td>\n\t\t\t<td>Event not matched</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>*</td>\n\t\t\t<td>all events of the node, and its descendant</td>\n\t\t\t<td>none(see remark below)</td>\n\t\t</tr>\n\t        <tr>\n\t\t\t<td>after*</td>\n\t\t\t<td>afterUpdate, afterUpdate.1, afterCreate, afterCreate.1</td>\n\t\t\t<td>beforeDel</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>after*.</td>\n\t\t\t<td>afterUpdate, afterCreate, afterDel</td>\n\t\t\t<td>afterUpdate.1, beforeUpdate</td>\n\t\t</tr>\n\n\t\t<tr>\n\t\t\t<td>afterUpdate*</td>\n\t\t\t<td>afterUpdate , afterUpdate.1, afterUpdate.2</td>\n\t\t\t<td>beforeUpdate</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>afterUpdate.*</td>\n\t\t\t<td>afterUpdate.1, afterUpdate.2</td>\n\t\t\t<td>afterUpdate , beforeUpdate</td>\n\t\t</tr>\n\t\n\t\t<tr>\n\t\t\t<td>afterUpdate</td>\n\t\t\t<td>afterUpdate</td>\n\t\t\t<td>every event other than \"afterUpdate\"</td>\n\t\t</tr>\n\t</tbody></table>\n\n<p>\n\"init\" is the only event which \"*\" can not capture, it has to be explicitly captured\n</p>\n\n<h3>init event</h3>\n\n<p>\"init\" event is special event, it works for both for mode node and jQuery object. When an object subscribe an \"init\" event, the \"init\" event will be self triggered immediately, which means the handler will be invoke at the time when subscription is created. and this event will be triggered once. The following example, shows the difference between <code>afterUpdate</code> and <code>init afterUpdate</code> event.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/kibex/1\">\nvar time = hm(\"time\", new Date());\n\ntime.sub(\"$#updateTime\", \"click\", function (e) {\n  this.set(new Date());\n});\n\n//showTime1 does not subcribe init event, \n//so initially, showTime1 is blank\n$(\"#showTime1\").sub(time, \"afterUpdate\", function (e) {\n  this.text(e.publisher.get());\n});\n\n//showTime2 subcribe init event, \n//so initially, showTime2 has a time stamp\n$(\"#showTime2\").sub(time, \"init afterUpdate\", function (e) {\n  this.text(e.publisher.get());\n});\n</pre>", "signatures": []},
    {"name": "Subscription", "type": "", "namespace": "Unified Subscription", "shortDesc": "Subscription", "longDesc": "<p>\nA subscription is between a publisher and subscriber, the they can be either model node or any other object such as jQuery object object, DOM element or event a plain old JavaScript object. When publisher trigger an event, subscriber will be notified by hm.js, and a handler will be executed in the context of subscriber, which means the \"this\" variable inside handler refers to subscriber. A subscription object consist of the following element.</p>\n<ol>\n<li>subscriber</li>\n<li>publisher</li>\n<li>publisher's event names</li>\n<li>handler (optional)</li>\n<li>options (optional)</li>\n<li>delegate (optional)</li>\n</ol>\n<p>\n\nThere are two ways to define a subscriptions, by JavaScript code( Programmatic subscription) or by html markup (declarative subscription). Both of them use the same API and achieve the same result, but declarative has some advantage over programmatic subscription, it is more reusable, maintainable, and easier to use.\n</p>", "signatures": []},
    {"name": "Programmatic", "type": "", "namespace": "Unified Subscription.Subscription", "shortDesc": "Programmatic Subscription", "longDesc": "", "signatures": [
        {"name": "hm.sub()", "returns": "hm", "shortDesc": "create a subscription between a publisher, and subscriber", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.sub(subscriber, publisher, eventTypes[, handler[, handlerOptions[, delegateSelector]]])", "parameters": [
                {"name": "subscriber", "type": "string, DOM element, jQuery object, or Node", "desc": "the object subscribe the event, It can be null, \"_\", \"null\", meaning that there is no subscriber."},
                {"name": "publisher", "type": "string, DOM element,  jQuery object or repository node", "desc": "the object which publish event"},
                {"name": "eventTypes", "type": "string", "desc": "event names separated by string"},
                {"name": "handler", "type": "string, function, object", "desc": "optional handler which will be executed when event trigger, it is optional when the subscriber it is a handler function"},
                {"name": "handlerOptions", "type": "object", "desc": "optional options to initialize a instance of handler"},
                {"name": "delegateSelector", "type": "string", "desc": "optional delegate selector to enable jQuery delegate event"}
            ]}
        ], "examples": []},
        {"name": "subscriber.sub()", "returns": "subscriber", "shortDesc": "a subscriber subscribe events published by another object, the subscriber is either a jQuery object or a repository node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "subscriber.sub(publisher, events[, handler[, handlerOptions [, delegateSelector]]])", "parameters": [
                {"name": "publisher", "type": "string, DOM object, jQuery object, or repository node", "desc": "the object that publish event"},
                {"name": "events", "type": "string", "desc": "event names separated by string"},
                {"name": "handler", "type": "string, function, object", "desc": "optional handler which will be executed when event trigger, it is optional when the subscriber it is a handler function"},
                {"name": "handlerOptions", "type": "object", "desc": "optional object to initialize an special instance of a handler"},
                {"name": "delegateSelector", "type": "string", "desc": "optional delegateSelector to enable jQuery delegate event"}
            ]}
        ], "examples": [
            {"desc": "", "code": "  var myapp = hm(\"myapp\", {\n    message: \"hello\",\n    time: null,\n    color:null,\n    setTime: function (e) {\n      //\"this\" == e.subscriber (myapp.setTime)\n      hm.log(\"'this' is \" + this);\n      e.subscriber.set(\"..time\", new Date()); \n    }  \n  });\n\n  //model subcribe view event with a handler in string form\n  myapp.cd(\"message\").sub(\"$#btnLogHello\", \"click\", \"*log\");\n  \n  //model subscribe view event with no explicit handler\n  //because the subscriber is the handler\n  myapp.cd(\"setTime\").sub( \"$#btnChangeTime\", \"click\");\n  \n  //view subscribe model event with a handler in string form\n  $(\"#showTime\").sub(myapp.cd(\"time\"), \"afterUpdate\", \"text\");\n  \n  //model subscribe view event a handler in string form, with a delegate selector\n  myapp.cd(\"color\").sub(\"$#controlPanel\", \"click\", \"val\", null, \".color\");\n  \n  //view subscribe model event a handler in string form\n  $(\"#controlPanel\").sub(myapp.cd(\"color\"), \"afterUpdate\", \"css*background-color\");", "url": "http://jsbin.com/poyez/1", "jsbin": true}
        ]}
    ]},
    {"name": "Declarative", "type": "", "namespace": "Unified Subscription.Subscription", "shortDesc": "Declarative Subscription", "longDesc": "<p>\nIn Hm.js, we can declare subscription in html markup (DOM)\nWhen DOM is initially loaded or manipulated by template engine, Hm.js will automatically parse the DOM and extract the subscriptions embedded in DOM.\n</p>\n\n<p>Declarative subscriptions depends on <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Node.Path\">path calculation</a> and <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression\">handler expression</a>. It is important to understand them before using declarative subscription.</p>\n\n\n<p>\nThere are four types of <b>subscription attributes</b> used in declarative subscription, <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Declarative.ns\">ns</a>, \n\n<a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Declarative.!events\">!events</a>, \n\n<a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Declarative.%24events\">$events</a>, and \n\n<a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Declarative.binding\">bindings</a>.  \n</p>\n<ol>\n<li>The \"<strong>ns</strong>\" attribute is used to calculate the model path. </li>\n\n<li>The \"<strong>$events</strong>\" attribute is used to declare the subscription between contextual element as the publisher and other objects as subscriber. </li>\n\n<li>The \"<strong>!events</strong>\" attribute is used to declare subscription between contextual element as subscriber and other object as publisher.</li>\n\n<li>The \"<strong>binding</strong>\" attribute is used to as container of  subscriptions or other dynamic behaviors. </li>\n</ol>\n\n\n<p>Technically, there is no difference between declarative subscription and programmatic subscription, because they are created using the same API. The advantage to use declarative subscription is that it is more expressive and reusable.</p>\n\n<p>Hm.js has a debugging tool to see what the subscriptions are created for an element. This tool itself is also a binding. You can attach a \"debug\" attribute to an element like the following example. \n</p>\n\n<pre prettyprint preview=\":_|http://jsbin.com/licor/1\">\n&lt;input type=\"text\" val=\"name|keyup\" debug /&gt;\n&lt;div dump=\"name\" debug&gt;&lt;/div&gt;\n&lt;div log-panel&gt;&lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "Null subscriber", "type": "", "namespace": "Unified Subscription.Subscription.Programmatic", "shortDesc": "Null subscriber", "longDesc": "<p>In most case,  a subscription is between a publisher and a subscriber, and the handler of subscription is executed in the context of subscriber, which means the \"this\" variable in the handler refers to the subscriber.  However, in some situation, a subscription does not have an explicit subscriber context, this is the similar to traditional event binding.  The \"this\" variable in the handler will be the global object in non-strict mode, or undefined in strict mode.</p>", "signatures": [
        {"name": "hm.handle()", "returns": "hm", "shortDesc": "bind a handler to events of publisher, which is either a jQuery object or node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.handle(publisher, eventTypes,  handler,  [handlerOptions, [delegateSelector]])", "parameters": [
                {"name": "publisher", "type": "string, jQuery object, node", "desc": "The object which triggers the event"},
                {"name": "eventTypes", "type": "string", "desc": "combination of event names separated by space"},
                {"name": "handler", "type": "string, object, function", "desc": "handler to handle the event"},
                {"name": "handlerOptions", "type": "string, object", "desc": "optional options to initialize a handler instance"},
                {"name": "delegateSelector", "type": "string", "desc": "a selector used in jQuery delegate event"}
            ]}
        ], "examples": [
            {"desc": "The following example use various forms of parameter, and comments describe how these parameters are used.", "code": "  \"use strict\";\n  \n  //use \"$\" jquery selector as publisher\n  //use handler in string form  \n  //use options \"hello\" to intialize an instance of \"*log\" workflow\n  hm.handle(\"$#btnLogHello\", \"click\", \"*log\", \"hello\");\n  \n  \n  //use DOM element as publisher\n  //use handler in function form  \n  hm.handle( document.getElementById(\"btnChangeTime\"), \"click\", function (e) {\n     hm(\"time\", new Date());\n  });\n \n  //use string selector of repository node as publisher\n  //use wildcarded repository event\n  hm.handle(\"time\", \"after*\", function (e) {\n    hm.log(this);\n    $(\"#showTime\").text(e.publisher.get());\n  });\n  \n  //use \"$\" selector to select dom nodes as publisher\n  //use handler in function form\n  //use delegate selector to enable jQuery delegate event\n  hm.handle(\"$#controlPanel\", \"click\", function (e) {\n    hm.set(\"color\", e.originalPublisher.val());\n  }, null, \".color\");\n  \n  //use navigator as publisher\n  //use wildcarded repository event\n  //use handler in object form \n  hm.handle( hm(\"color\"), \"after*\", \n    {\n      get: function (e) {\n        $(\"#controlPanel\").css(\"background-color\", e.publisher.get());\n      }\n    }\n  );", "url": "http://jsbin.com/xofip/1", "jsbin": true}
        ]},
        {"name": "publisher.handle()", "returns": "jQuery object or Node", "shortDesc": "bind a handler to events of publisher, which is either a jQuery object or node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "publisher.handle(eventTypes, handler, [handlerOptions, [delegateSelector]])", "parameters": [
                {"name": "eventTypes", "type": "string", "desc": "event names separated by space"},
                {"name": "handler", "type": "function, string, object", "desc": "the handler to handle the event"},
                {"name": "handlerOptions", "type": "object", "desc": "optional options to initialize an instance of workflow"},
                {"name": "delegateSelector", "type": "string", "desc": "optional jQuery selector to enable delegate event"}
            ]}
        ], "examples": [
            {"desc": "This is a refactory of above example, the difference is that \"hm.handle\" is changed to \"publisher.handle\"", "code": " \"use strict\";\n  \n  //use \"$\" jquery selector as publisher\n  //use handler in string form  \n  //use options \"hello\" to intialize an instance of \"*log\" workflow\n  hm.handle(\"$#btnLogHello\", \"click\", \"*log\", \"hello\");\n  \n  \n  //use DOM element as publisher\n  //use handler in function form  \n  hm.handle( document.getElementById(\"btnChangeTime\"), \"click\", function (e) {\n     hm(\"time\", new Date());\n  });\n \n  //use string selector of repository node as publisher\n  //use wildcarded repository event\n  hm.handle(\"time\", \"after*\", function (e) {\n    hm.log(\"'this' is \" + this);\n    $(\"#showTime\").text(e.publisher.get());\n  });\n  \n  //use \"$\" selector to select dom nodes as publisher\n  //use handler in function form\n  //use delegate selector to enable jQuery delegate event\n  hm.handle(\"$#controlPanel\", \"click\", function (e) {\n    hm.set(\"color\", e.originalPublisher.val());\n  }, null, \".color\");\n  \n  //use navigator as publisher\n  //use wildcarded repository event\n  //use handler in object form \n  hm.handle( hm(\"color\"), \"after*\", \n    {\n      get: function (e) {\n        $(\"#controlPanel\").css(\"background-color\", e.publisher.get());\n      }\n    }\n  );\n  ", "url": "http://jsbin.com/noyad/1", "jsbin": true}
        ]}
    ]},
    {"name": "Handler", "type": "", "namespace": "Unified Subscription.Subscription", "shortDesc": "Handler", "longDesc": "<p> In Hm.js,  there are three forms of subscription handler.</p>\n<ol>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+object\">handler object</a></li>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+function\">handler function</a></li>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression\">handler expression</a></li>\n</ol>\n\n<p>Handler object is native form, it is an object with multiple <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Activity\">activity functions</a>. Handler  function and handler expression are simplified forms of handler object, and they are converted handler objects during when subscription is created. </p>\n", "signatures": []},
    {"name": "Disable inference", "type": "", "namespace": "Unified Subscription.Model Event.Event Cascading", "shortDesc": "Disable Inference", "longDesc": "<p>Most of time, this automatic dependencies inference works well, and you don't need to do anything. However, if you want to disable this automatic inference for whatever reason, you can do that like the following. \n</p>\n\n<h3>rename model function with \"_\" prefix.</h3>\n<p>\nGive the function node a name begin with \"_\" . In the following, the full name is named \"__\", so that the inferencing will be disabled.\n</p>\n<pre  prettyprint preview=\"_|http://jsbin.com/hopog/1\">\n  var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    //the function name \"__\" will disable automatic dependencies inference\n    fullName: function __ () {\n      return this.get(\"firstName\") + \",\" + this.get(\"lastName\"); \n    }\n  });\n  \n  var triggered = false;\n  //handler bind to fullName\n  person.cd(\"fullName\").handle(\"afterUpdate\", function (e) {\n    triggered = true;\n  });\n  \n  \n  if (triggered) {\n    hm.log(\"inferenc is enabled\");\n  } else {\n    hm.log(\"inferenc is disabled\");\n  }\n</pre>\n\n<h3>rename \"this\" variable</h3>\n<p>Hm.js use \"this\" variable to infer the reference, you can also rename \"this\" variable to fool hm.js so that referenced can not be inferred. The following example make \"fullName\" node reference \"firstName\" but not \"lastName\".\n</p>\n\n<pre  prettyprint preview=\"_|http://jsbin.com/numon/1\">\n   var person = hm(\"person\", {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    //now the fullName reference firstName, but not lastName\n    fullName: function () {\n      var me = this;\n      return this.get(\"firstName\") + \",\" + me.get(\"lastName\"); \n    }\n  });\n  \n  //handler bind to fullName\n  person.cd(\"fullName\").handle(\"afterUpdate\", function (e) {\n    hm.log(e.originalPublisher.path  + \" cascade change to fullName, now it is \" + e.publisher.get());\n  });\n  \n \n  person.set(\"firstName\", \"Jane\");\n  person.set(\"lastName\", \"Roe\");\n</pre>\n", "signatures": []},
    {"name": "Explicit reference", "type": "", "namespace": "Unified Subscription.Model Event.Event Cascading", "shortDesc": "Explicit Reference", "longDesc": "<p>The automatic inference depends of the usage of \"this.get(xxx)\" token, if your source codes does not have this token presence,  and you still want to create the reference between two nodes, you have the following options.\n</p>\n\n<h3>Add reference as string literals</h3>\n<p>\nYou can add source code to hint the Hm.js about the reference. In the following example, two string literals are added as statement, this approach is safe because it will not create any side effect and and string literal will not be removed by javascript minifiers.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/pepah/1\">\n  var rawPerson;\n  \n  var person = hm(\"person\", rawPerson = {\n    firstName: \"Jone\",\n    lastName: \"Doe\",\n    fullName: function () {\n      \"this.get('firstName')\";\n      \"this.get('lastName')\";\n      return rawPerson.firstName + \",\" + rawPerson.lastName;\n    }\n  });\n  \n  //handler bind to fullName\n  person.cd(\"fullName\").handle(\"afterUpdate\", function (e) {\n    hm.log(e.originalPublisher.path + \" cascade change to fullName, the current value is \" + e.publisher.get());\n  });\n  \n \n  person.set(\"firstName\", \"Jane\");\n  person.set(\"lastName\", \"Roe\");\n</pre>\n\n<h3>Add reference by code</h3>\n<p>\nAnother solution is you write code to explicitly to add references like the following.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/detiy/1\">\n  var rawPerson;\n  \n  var person = hm(\"person\", rawPerson = {\n    firstName: \"Jone\",\n    lastName: \"Doe\",\n    fullName: function __ () {\n      return rawPerson.firstName + \",\" + rawPerson.lastName;\n    }\n  });\n\n  //add references explicitly\n  person.cd(\"fullName\").watch(\n    person.getPath(\"firstName\"), \n    person.getPath(\"lastName\")\n  );\n  \n  \n  //handler bind to fullName\n  person.cd(\"fullName\").handle(\"afterUpdate\", function (e) {\n    hm.log(e.originalPublisher.path + \" cascade change to fullName, the current value is \" + e.publisher.get());\n  });\n  \n \n  person.set(\"firstName\", \"Jane\");\n  person.set(\"lastName\", \"Roe\");\n</pre>", "signatures": [
        {"name": "node.reference( targetPath1[, targetPath2, ...] )", "returns": "node", "shortDesc": "add reference to the current node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.reference( targetPath1[, targetPath2, ...] )", "parameters": [
                {"name": "targetPath1", "type": "string", "desc": "the path of the node that current node will reference"}
            ]}
        ], "examples": []}
    ]},
    {"name": "handler object", "type": "", "namespace": "Unified Subscription.Subscription.Handler", "shortDesc": "handler object", "longDesc": "\n<p>A handler object consists of one or more activities like the following:\n</p>\n\n<pre prettyprint>\nvar handlerObject = {                                                 \n                                                                      \n\tinitialize:function(publisher, subscriber,workflow,options ) {   \n\t\t//this == undefined  //strict mode                                  \n\t\t//this = global object //non-strict mode                            \n\t},                                                                   \n                                                                      \n\tget: function( e ) {                                                 \n\t\t//this == e.subscriber                                              \n\t},                                                                   \n                                                                      \n\tconvert: function( valueReturnedFromGetActivity, e ) {               \n\t\t//this == e.subscriber                                              \n\t},                                                                   \n                                                                      \n\tset: function( valueReturnedFromSetActivity, e ) {                   \n\t\t//this == e.subscriber                                              \n\t},                                                                   \n                                                                      \n\tfinalize: function( valueReturnedFromSetActivity, e ) {              \n\t\t//this == e.subscriber                                              \n\t}                                                                    \n                                                                      \n}                                                                     \n</pre>\n\n<h3>Difference between activity function and jQuery handler function</h3>\n<p>\nInside these functions, <code>this</code> is equal to <code>e.subscriber</code>, which is the subscriber of the subscription. In the case of jQuery handler, <code>this</code> refer to <code>e.currentTarget </code>.\n</p>\n\n<p>\nIn jQuery handler, you can use <code>return false</code>  as a combination of <code>e.preventDefault</code> and <code>e.stopPropagation</code>. In activity functions, you can not use this shortcut, because the return value of an activity is used to feed the input of next activity. You need to explicitly call <code>e.preventDefault</code> and <code>e.stopPropagation</code> in activity functions.\n</p>\n\n<h3>Common members of event argument of model subscription and jQuery(view) subscription</h3>\n\n<p>Hm.js normalize the event argument for both jQuery event and model event, so that have some common members like the following.\n</p>\n\n<table>\n\t\t<colgroup><col style=\"width:220px\">\n\t\t<col style=\"width:auto;\">\n\t\t<col style=\"width:220px\">\n\t\t</colgroup><tbody><tr>\n\t\t\t<td>event members<br>\n\t\t\t</td>\n\t\t\t<td>model event (type of hm.Event)</td>\n\t\t\t<td>jQuery event (type of $.Event)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>subscriber</td>\n\t\t\t<td colspan=\"2\">\n\t\t\t\ta model node or a jQuery object\n\t\t\t</td>\n\n\t\t</tr>    \n\t\t<tr>\n\t\t\t<td>publisher</td>\n\t\t\t<td>\n\t\t\t\tmodel node\n\t\t\t</td>\n\t\t\t<td>$(e.currentTarget)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>originalPublisher</td>\n\t\t\t<td>\n\t\t\t\tmodel node\n\t\t\t</td>\n\t\t\t<td>$(e.target)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>workflow</td>\n\t\t\t<td>\n\t\t\t\tcurrent workflow object\n\t\t\t</td>\n\t\t\t<td>current workflow object</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>type</td>\n\t\t\t<td>\n\t\t\t\tstring, such as \"afterUpdate\"\n\t\t\t</td>\n\t\t\t<td>\n\t\t\t\tstring, such as \"click\"\n\t\t\t</td>\n\n\t\t</tr>\n\n\t\t<tr>\n\t\t\t<td>stopPropagation()</td>\n\t\t\t<td colspan=\"2\">\n\t\t\t\tPrevents other event handlers from being called.\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>stopImmediatePropagation()</td>\n\t\t\t<td colspan=\"2\">\nPrevents the event from bubbling up the DOM tree or repository, preventing any parent handlers from being notified of the event.\n\t\t\t</td>\n\t\t</tr>\n<tr>\n<td>isPropagationStopped()</td>\n<td colspan=\"2\">Returns whether event.stopPropagation() was ever called on this event object.</td>\n</tr>\n\n<tr>\n<td>isImmediatePropagationStopped()</td>\n<td colspan=\"2\">Returns whether event.stopImmediatePropagation() was ever called on this event object.</td>\n</tr>\n\n\n\t</tbody></table>\n\n<h3>Specific members of event object of model event</h3>\n\n<p>But because the implementations of jQuery event and model event are inherently different, the event objects of two type have their unique members as well. All the existing members of jQuery event are still present, the detailed reference is <a href=\"http://api.jquery.com/category/events/event-object/\">here</a>.  Model event's own unique members are as following. \n</p>\n<dl>\n  <dt>originalType</dt>\n   <dd>Because model event support event wildcard capture, the \"type\" property change when bubble, such as \"afterUpdate.1\", \"afterUpdate.2\",  however the originalType does not change, such as \"afterUpdate\".</dd>\n\n  <dt>isDepedent()</dt>\n   <dd>Model event support event cascading, so firstName's event will cascade to fullName, in the event handler of fullName, the isDependen() will return true.</dd>\n\n<dt>stopCascade()</dt>\n<dd>If you call stopCascade() inside firstName's event handler, that even will not be cascade to fullName.</dd>\n\n<dt>isCascadeStopped()</td>\n<dd>It tells you whether the cascade is stop.</dd>\n\n<dt>level</dt>\n<dd>If a events of \"person\" node is bubbled from firstName, then it is level will be 1, this level will increment when it bubble up every level.</dd>\n\n<dt>error()</dt>\n\n<dd>Inside beforeCreate.* , beforeUpdate.*, beforeDel.* event handler, if you call this method,  the create, update, del method will stop operations.</dd>\n\n<dt>hasError()</dt>\n<dd>It will return true, if error() has called.</dd>\n\n</dl>\n\n<h3>Examples</h3>\n\n<p>In the following demo, the same handler object is used in two subscriptions. When a subscription is created, an new object is cloned from this object, and initialized with different state, so the subscription behaviors are different.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/xicep/1\">\n  var id = 0;\n  var handlerObject = {\n    \n    initialize: function( publisher, subscriber, handler, options ) {\n      handler.id = id++;\n      handler.started = new Date();\n      //save option as a property of handler object\n      handler.unit = options;\n      hm.log(\"initialize activity called, subscriber:\" + subscriber[0].id + \n             \", publisher: \" + publisher[0].id, \"red\");\n       \n    },\n    \n    get: function (e) {\n      hm.log(\"\");\n      hm.log(\"get activity called for handler: \" + e.handler.id, \"red\");\n      return new Date();\n    },\n    \n    convert: function (value, e) {\n      hm.log(\"convert activity called for handler: \" + e.handler.id, \"red\");\n     var now = value.getHours() + \":\" + \n       value.getMinutes() + \":\" + \n         value.getSeconds() + \".\" + \n           value.getMilliseconds(); \n      \n      var duration = (value - e.handler.started) / 1000;\n      \n      if (e.handler.unit == \"second\") {\n        \n        return \"Now: \" + now + \n          \", Time elapsed since subscription: \" + \n            ((value - e.handler.started) / 1000) + \n              \" seconds has passed\";\n        \n      } else {\n       \n        return \"Now: \" + now + \n          \", Time elapsed since subscription: \" + \n            (value - e.handler.started) + \n              \" mini-seconds has passed\";\n      }\n    },\n\n    set: function (value, e) {\n      \n      hm.log(\"set activity called for handler: \" + e.handler.id, \"red\");\n      this.text(value);\n      \n    },\n    \n    finalize: function (value, e) {\n      \n      hm.log(\n        \"finalize activity called for handler: \" + e.handler.id, \"red\");\n    } \n    \n  };\n  \n  $(\"#lableOne\").sub(\"$#buttonOne\", \"click\", handlerObject, \"second\");\n  \n  //delay subscription by 1 second, so that the initialized state of this handler is \n  //different from previous handler\n  setTimeout(function () {\n    $(\"#lableTwo\").sub(\"$#buttonOne\", \"click\", handlerObject); \n  }, 1000);\n</pre>", "signatures": []},
    {"name": "handler function", "type": "", "namespace": "Unified Subscription.Subscription.Handler", "shortDesc": "handler function", "longDesc": "<p>\nHandler function is simplified form of handler object, it is equivalent to a handler object with a single get activity, which is the handler function. If a handler object does not have a initialize function, the options parameter in the subscription will be populated to handler object. In the following example, two subscription use a same handler function and different options, so that the behavior of subscription is different.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/bafox/1\">\n\n var handlerFunction = function (e) {\n     var value =  new Date(); \n     var now = value.getHours() + \":\" + \n       value.getMinutes() + \":\" + \n         value.getSeconds() + \".\" + \n           value.getMilliseconds(); \n\n      var options = e.handler.options;\n      \n      var duration = (value - options.started) / 1000;\n      \n      var message;\n      if (options.unit == \"second\") {\n        \n        message = \"Now: \" + now + \n          \", Time elapsed since subscription: \" + \n            ((value - options.started) / 1000) + \n              \" seconds has passed\";\n        \n      } else {\n       \n        message = \"Now: \" + now + \n          \", Time elapsed since subscription: \" + \n            (value - options.started) + \n              \" mini-seconds has passed\";\n      }\n      \n      this.text(message);\n      \n    }; \n    \n  \n  $(\"#lableOne\").sub(\"$#buttonOne\", \"click\", handlerFunction, { started: new Date(), unit: \"second\" });\n  \n  setTimeout(function () {\n    $(\"#lableTwo\").sub(\"$#buttonOne\", \"click\", handlerFunction, {started: new Date() }); \n  }, 1000);\n</pre>", "signatures": []},
    {"name": "handler expression", "type": "", "namespace": "Unified Subscription.Subscription.Handler", "shortDesc": "handler expression", "longDesc": "<p>\nThe handler expression is mainly designed to be used in declarative subscription, although it can be also used in programmatic subscriptions. Because handler expression is a string, it can be easily embedded in markup. The goal is to allow user to easily compose a handler with activities and workflow, or a model function using just string.\n</p>\n\n<p>There are three kind of handler expression.</p>\n\n<ol>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression.activity+expression\">activity expression</a></li>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression.path+expression\">path expression</a></li>\n<li><a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression.workflow+expression\">workflow expression</a></li>\n</ol>\n\n</p>", "signatures": []},
    {"name": "Activity", "type": "", "namespace": "Unified Subscription.Subscription", "shortDesc": "Activity", "longDesc": "<p>Activities are building block of handler and workflow. A handler or workflow can have one to five activities. They are executed by the order of \"initialize\", \"get\", \"convert\", \"set\", \"finalize\".  The \"initialize\" activity is optional, it is executed only when a subscription is created with the handler or workflow, it will not be executed when events of a subscription fire. Other for activities executed if they are present in the handler when the events trigger. The \"get\" activity is required, the \"convert\", \"set \", \"finalize\" activity are optional. There are two kinds of activity, ad-hoc activity and and well-known activity.</p>\n\n<h3>Ad-hoc activity</h3>\n<p>\nAd-hoc activity is a function, if it is embedded as model function, it can be reference by model path. The following are an example of ad-hoc activity.\n</p>\n<pre prettyprint  preview=\"_|http://jsbin.com/yohaq/1\">\nvar model = hm(\"helloApp\", {\n  name: \"\",\n  message: function () {\n    var name = this.get(\"name\").trim();\n    return name ? \"Hello, \" + name : \"\";\n  }\n});\n\nmodel.cd(\"name\").sub($(\"#txt1\"), \"keyup\", {\n  get: function (e) {\n    return e.publisher.val();\n  },\n  set: function (value, e) {\n    this.set(value);\n  }\n});\n\n$(\"#label1\").sub(model.cd(\"message\"), \"afterUpdate\", {\n  get: function (e) {\n    return e.publisher.get();      \n  },\n  set: function (value, e) {\n    this.text(value);\n  }\n});\n</pre>\n\n<p>\nIn the following example,  the functions are in embedded in model, so they can be reference using path expression.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/avIMAgI/1\">\n  var model = hm(\"helloApp\", {\n    name: \"\",\n    message: function () {\n      var name = this.get(\"name\").trim();\n      return name ? \"Hello, \" + name : \"\";\n    },\n    getElemValue: function (e) {\n      return e.publisher.val();\n    },\n    setModelValue: function (value, e) {\n      this.set(value);\n    },\n    getModelValue: function (e) {\n      return e.publisher.get();      \n    },\n    setElemText: function (value, e) {\n      this.text(value);\n    }\n  });\n  \n  model.cd(\"name\").sub($(\"#txt1\"), \"keyup\", {\n    get: \"#..getElemValue\" ,\n    set: \"#..setModelValue\"\n  });\n  \n  $(\"#label1\").sub(model.cd(\"message\"), \"afterUpdate\", {\n    get: \"#..getModelValue\",\n    set: \"#..setElemText\"\n  });\n</pre>\n\n\n<p>\nOr you can use activity expression like\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/okuRiJa/2\">\n\n\nmodel.cd(\"name\").sub($(\"#txt1\"), \"keyup\",\n           \"#..getElemValue #..setModelValue\");  \n\n$(\"#label1\").sub(model.cd(\"message\"), \"afterUpdate\", \n         \"#..getModelValue #..setElemText\");\n</pre>\n\n<p>or</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/arAGAwA/2\">\n\n\n&lt;input type=\"text\" $keyup=\"name|#..getElemValue #..setModelValue\"  &gt;\n&lt;div !afterupdate=\"message|#..getModelValue #..setElemText\"&gt;&lt;/div&gt;\n</pre>\n\n\n<h3>Well-known activity</h3>\n<p>\n Well-known activity is also function, but it is reusable and can be referenced by a string key. \nTo create them, we can put \"get\" activity under hm.activity.get object, \"set\" activity under hm.activity.set object, and do the same for \"convert\", \"finalize\" activity.  Then we reference them by name, like \"*activityName\". \n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/usikup/2\">\nvar activity = hm.activity;\nvar get = activity.get;\nvar set = activity.set;\n\nget.getTextValue = function (e) {\n  return e.publisher.val();\n};\n\nget.getNodeValue = function (e) {\n  return e.publisher.get();\n};\n\nset.setLabelText = function (value, e) {\n  this.text(value);\n};\n\nset.setNodeValue = function (value, e) {\n  this.set(value);\n};\n  \n\nvar model = hm(\"helloApp\", {\n  name: \"\",\n  message: function () {\n    var name = this.get(\"name\").trim();\n    return name ? \"Hello, \" + name : \"\";\n  }\n});\n\n//reference activity by \"*activityName\"\nmodel.cd(\"name\").sub($(\"#txt1\"), \"keyup\", {\n  get: \"*getTextValue\",\n  set: \"*setNodeValue\"\n});\n\n$(\"#label1\").sub(model.cd(\"message\"), \"afterUpdate\", {\n  get: \"*getNodeValue\",\n  set: \"*setLabelText\"\n});\n</pre>\n\n\n<h3>Member activities</h3>\n<p>\nHm.js also has two special well-known activities \"getMember\" and \"setMember\", which can use the method name of publisher and subscriber as activity, like the following.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/EhOnig/2\">\nvar model = hm(\"helloApp\", {\n  name: \"\",\n  message: function () {\n    var name = this.get(\"name\").trim();\n    return name ? \"Hello, \" + name : \"\";\n  }\n});\n\n//reference activity by \"*activityName\"\nmodel.cd(\"name\").sub($(\"#txt1\"), \"keyup\", {\n  get: \"*getMember\",\n  getName: \"val\", //val is method jQuery object\n  set: \"*setMember\",\n  setName: \"set\" //set is method of model node\n});\n\n$(\"#label1\").sub(model.cd(\"message\"), \"afterUpdate\", {\n  get: \"*getMember\",\n  getName: \"get\", //get is a method of model node\n  set: \"*setMember\",\n  setName: \"text\" //'text' is method of jQuery object\n});\n</pre>\n\n<p>\nInstead of using these two well-known activities directly,  we can use member activity expression which will be converted to these two well-known activities by Hm.js. Using member activity you don't need any prefix. The following is an example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/ofedaz/3\">\n\n &lt;div&gt;Your name:&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"name|val\"  &gt;\n  \n  \n  &lt;div&gt;background color: (try type 'red', 'yellow\", '#eee')&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"color|val\" !init=\"color|val\"&gt;\n  \n  &lt;div !afterUpdate=\"message|text\"\n       !init_afterUpdate=\"color|css*background-color\"&gt;&lt;/div&gt;\n  \n  &lt;div log-panel&gt;&lt;/div&gt;\n</pre>\n\n<p>\nYou can find more information in <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression.activity+expression\">activity expression</a>\n</p>", "signatures": []},
    {"name": "Workflow", "type": "", "namespace": "Unified Subscription.Subscription", "shortDesc": "Workflow", "longDesc": "<p>Essentially, workflow is just a well-known handler which can be cloned as a handler object during subscription.  We can use it as prototype to create special version of it as subscription handler.</p>", "signatures": [
        {"name": "hm.workflow(name, handler)", "returns": "hm", "shortDesc": "", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.workflow(name, workflow)", "parameters": [
                {"name": "name", "type": "string", "desc": "the name workflow"},
                {"name": "workflowPrototype", "type": "string, function, object", "desc": "the workflow to be cloned"}
            ]}
        ], "examples": [
            {"desc": "<p>\nThe following create a simple workflow, and use it in two event binding. Each binding use the create special version of the handler from the workflow\n</p>", "code": "  hm(\"name\", \"John\");\n  \n  hm.workflow(\"greet\", function(e) {\n    hm.log(e.handler.options + \",\" + e.subscriber.get());\n  });", "url": "http://jsbin.com/EbEwekI/2", "jsbin": true},
            {"desc": "", "code": "<input type=\"button\" value=\"hello\" $click=\"name|*greet|hello\">\n  <input type=\"button\" value=\"bye\" $click=\"name|*greet|bye\">", "url": ""},
            {"desc": "The following example, it is refactory of previous one. It uses \"initialize\" activity to make sure that the option can not be missing, and than create an message based on options.", "code": "\n hm(\"name\", \"John\");\n  \n  hm.workflow(\"greet\", {\n    initialize: function (publisher, subscriber, handler, options) {\n      if (!options) {\n        hm.log(\"options cannot be null\", \"red\");\n        // throw \"workflow 'greet' expect an options\"; \n        handler.message = \"missing message\";\n      } else {\n      //modify the handler\n        handler.message = options;  \n      }\n      \n    },\n    get: function(e) {      \n       hm.log(e.handler.message + \",\" + e.subscriber.get());\n    }\n  });", "url": "http://jsbin.com/AcEQoS/2", "jsbin": true},
            {"desc": "", "code": "<input type=\"button\" value=\"hello\" $click=\"name|*greet|hello\">\n  <input type=\"button\" value=\"bye\" $click=\"name|*greet|bye\">\n  <input type=\"button\" value=\"missing options\" $click=\"name|*greet\">\n  \n  <div log-panel></div>", "url": ""}
        ]},
        {"name": "hm.workflow(name)", "returns": "object", "shortDesc": "", "desc": "return a workflow type object with the name", "overloads": [
            {"versionAdded": "0.1", "name": "hm.workflow(name)", "parameters": [
                {"name": "name", "type": "string", "desc": "the name of the workflow"}
            ]}
        ], "examples": []},
        {"name": "hm.workflow()", "returns": "Object", "shortDesc": "", "desc": "return a hash table object of all the workflow type", "overloads": [], "examples": []}
    ]},
    {"name": "initialize", "type": "", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "initialize", "longDesc": "<p>This activity is a optional, and it is called when subscription is created. The purpose of this activity is to customize the subscription handler. The following show how to defined a initialize activity called \"myinitialize\"\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n//add a common initialize function like the following\nhm.activity.initialize.myinitialize =  function (publisher, subscriber, handler,  initializeOptions) {\n\n}\n</pre>\n\n<p>In the following example, greet workflow has a initialize activity. And two subscriptions create an handler from of the workflow,  and two handler are initialized with their own options.\n</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/ahegeYO/2\">\nhm(\"name\", \"John\");\n\nhm.workflow(\"greet\", {    \n  initialize: function (publisher, subscriber, handler, options) { \n    handler.greeting = options;\n  },\n  \n  get: function (e) {\n    return e.handler.greeting + \", \" + e.publisher.get();\n  },\n    \n  set: \"text\" \n});\n</pre>\n\n<pre prettyprint>\n&lt;div !init=\"name|*greet|Hello\"&gt;&lt;/div&gt;\n&lt;div !init=\"name|*greet|Bye\"&gt;&lt;/div&gt;\n</pre>\n", "signatures": []},
    {"name": "get", "type": "", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "get", "longDesc": "<p>\nThe \"get\" activity is the only required activity in handler or workflow. It is a function like the following:\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (e) {\n//\"this\" refer to e.subscriber\n//return a value \n}\n</pre>\n\n<p>The purpose of \"get\" activity function is to get a value from publisher, and return it, which will be passed along into next activity as an input parameter.  Normally, this function should not be read ohly and does not cause any state change. But if you have only one activity in the handler, this function can change state.  </p>\n<p>\nAfter the \"get\" activity returns, the execution pipeline will continue to execute  \"convert\" activity, if it is available. If convert activity is not available, workflow will call \"set\" activity. </p>\n\n<p>The \"get\" activity function can be asynchronous by returning a jQuery promise, which will resolve a value. When value is resolved, it is passed into next activity function such as \"convert\" activity or \"set\" activity.\n</p>\n\n\n<p>If this activity is the only activity in a handler, you can do everything in this activity, such as get the value from publisher, and modify the state of subscriber, and you don't need to return a value because there is no following activity in the execution pipeline.</p>\n\n<p>\nYou can create well-known get activity like the following:\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.activity.get.myget = function (e) {\n\n};\n</pre>", "signatures": []},
    {"name": "convert", "type": "", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "convert", "longDesc": "<p>The \"convert\" activity is an optional, it be must used with a \"get\" activity and a \"set\" activity. It is a function like the following, the value parameter is returned value of \"get\" activity or its resolved value.</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (value, e) {\n//\"this\" refer to the e.subscriber\n//return a value \n}\n</pre>\n\n<p> Its purpose is to convert the result of get activity into a value which is passed into \"set\" activity. For example, you can convert a string into number, or an object,  you can convert a data into a markup using template engine. This activity should be readonly, not causing any side effect.\n</p>\n\n<p>\nThis activity can be also asynchronous by returning a jQuery promise which return a value. When a value is resolved,  it will be passed into \"set\" activity for execution.  You can add a well-known activity like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.activity.convert.myconvert = function (value, e) {\n\n//return a value \n}\n</pre>", "signatures": []},
    {"name": "set", "type": "", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "set", "longDesc": "<p>The \"set\" activity is optional, it follow a \"get\" activity or a \"convert\" activity. It is like the following functions. The value parameter is either return from get activity or set activity, or their promised value.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (value, e) {\n\n}\n</pre>\n\n<p>The purpose of the activity is to change the state of subscriber. It should not have any other side effect. You can add a well-known \"set\" activity like below\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.activity.set.myset = function (value, e) {\n\n}\n</pre>", "signatures": []},
    {"name": "finalize", "type": "", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "finalize", "longDesc": "<p>This activity is optional,  it follows \"set\" activity. It is like a function below. \n<p>\n\n<pre prettyprint>\nfunction (value, e) {\n//this == e.subscriber\n}\n\n// to create a well-known \"finalize\" activity,\nhm.activity.finalize.myfinalize = function (value, e) {\n\n}\n</pre>\n\n<p>It does the work which has not been done in \"set\" activity. In hm.js, there well-know activity called \"*parseSubs\",  it build declarative subscription from the markup generated by the template after the markup as been merged into the DOM. \n</p>\n\n", "signatures": []},
    {"name": "Utilities", "type": "", "namespace": "", "shortDesc": "Utilites", "longDesc": "", "signatures": []},
    {"name": "mapEvent", "type": "", "namespace": "Utilities", "shortDesc": "obj.mapEvent", "longDesc": "When an object publish (either a model node or a jQuery object) event, this event can be mapped to another event based on a condition.", "signatures": [
        {"name": "publisher.mapEvent(sourceEvent, targetEvent[, condition])", "returns": "the publisher", "shortDesc": "", "desc": "<p>The condition is a function like</p>\n<pre data-sub=\"prettyprint:_\">\nfunction (e) { \n   //e.publisher == model node, or jQuery object\n   //this == undefined (strict mode), this== window(non-strict mode)\n   //return true or false; \n}\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "publisher.mapEvent(sourceEvent, targetEvent[, condition])", "parameters": [
                {"name": "sourceEvent", "type": "string", "desc": "the event originally triggered on the publisher"},
                {"name": "targetEvent", "type": "string", "desc": "the event to be mapped to"},
                {"name": "condition", "type": "function", "desc": "optional function to determined whether it is ok to trigger the target event. It is default value is <code>function () { return true; }</code>"}
            ]}
        ], "examples": [
            {"desc": "The following example how to map event for DOM element.", "code": " //mapEvent with no condition\n  $(\"input\").mapEvent(\"click\", \"foo\");\n  \n  //mapEvent with a condition  \n  $(\"input\").mapEvent(\"click\", \"bingo\", function (e) {   \n    return e.originalPublisher.attr(\"data-bingo\") == \"true\";\n  });", "url": "http://jsbin.com/eNopEda/2", "jsbin": true},
            {"desc": "The following event shows how to map event for repository node.", "code": "  hm(\"count\", 100)\n    \n    .mapEvent(\"afterUpdate\", \"up\", function (e) {  \n   \n      return e.proposed > e.removed;\n      \n    })\n    .mapEvent(\"afterUpdate\", \"down\", function (e) {\n  \n      return e.proposed < e.removed;    \n  \n    });", "url": "http://jsbin.com/UNogelI/3", "jsbin": true}
        ]}
    ]},
    {"name": "newJqEvent", "type": "", "namespace": "Utilities", "shortDesc": "hm.newJqEvent", "longDesc": "<p>\nCreate new jQuery event base on an existing jQuery event, when existing event triggered to any DOM element or jQuery object, and the condition is met,  the new event will be triggered.\n</p>", "signatures": [
        {"name": "hm.newJqEvent(eventName, baseEventName, condition)", "returns": "hm", "shortDesc": "", "desc": "<p>This method does not used any other features of Hm.js. It is different from $obj.mapEvent(oldEvent, newEvent, condition) in that, mapEvent is only valid for the selected element, and create new event is valid for all elements. The condition is like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction (e) {\n  //this refer to window\n //e is just a un-tampered jQuery event object\n}\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "hm.newJqEvent(eventName, baseEventName, condition)", "parameters": [
                {"name": "eventName", "type": "string", "desc": "the new event name to be created"},
                {"name": "baseEventName", "type": "string", "desc": "the name of existing event"},
                {"name": "condition", "type": "function", "desc": "the function which return true or false"}
            ]}
        ], "examples": [
            {"desc": "", "code": "\n  /*\n    the hm.js already include the following code, so that you\n    can bind this event\n\n\thm.newJqEvent( \"enter\", \"keyup\",\n\t\tfunction( e ) {\n\t\t\treturn (e.keyCode === 13);\n\t\t}\n\t).newJqEvent( \"esc\", \"keyup\",\n\t\tfunction( e ) {\n\t\t\treturn (e.keyCode === 27);\n\t\t}\n\t);\n\n*/\n \n  hm.newJqEvent(\"ctrl\", \"keydown\", function (e) {\n    return e.ctrlKey;\n  });\n  \n  \n  hm(\"myhandler\", function (e) {\n    hm.log( e.type );   \n  });\n  ", "url": "http://jsbin.com/UyaZAhi/2", "jsbin": true}
        ]}
    ]},
    {"name": "ns", "type": "", "namespace": "Unified Subscription.Subscription.Declarative", "shortDesc": "ns", "longDesc": "<p>In hm.js, all html elements are associate with a model path. The root element of DOM is associate with the root model path (an empty string). If an element does not have an \"ns\" subscription property, by default it will inherit from its parent's model path. So if an element has \"ns\" property, its model path is merged from parent's model path and \"ns\" property.\n</p>\n\n<pre>\nmodelPathOfElement = hm.util.mergePath(modelPathOfParentElement , ns);\n</pre>\n\n<p>\nThe logic of mergePath can be found <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.ns?api.apiAction=view&api.selectedEntryName=Node.Path\">here</a>\n</p>", "signatures": [
        {"name": "ns=\"subPath\"", "returns": "N/A", "shortDesc": "", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "ns=\"subPath\"", "parameters": [
                {"name": "subPath", "type": "string", "desc": "the relative path to the parent's model path"}
            ]}
        ], "examples": [
            {"desc": "\nThe following example, use the \"debug\" subscription group to output the \"ns\" property value of each elements which have data-sub attribute. \n", "code": "  <div debug>\n    <div ns=\"person\" debug>\n      <div id=\"1\" ns=\"firstName\" debug>\n        <div id=\"10\" debug></div>\n        <div id=\"11\" ns=\".\" debug></div>\n        <div id=\"12\" debug=\"_\"></div>\n        <div id=\"13\" ns=\"..\" debug></div>\n        <div id=\"14\" ns=\"/\" debug></div>\n        <div id=\"15\" ns=\"/address\" debug></div>\n        <div id=\"16\" ns=\"..lastName\" debug></div>\n        <div id=\"17\" ns=\"_\" debug></div>\n      </div>\n      <div id=\"2\" ns=\"_\" debug>\n        <div id=\"21\" ns=\"xx\" debug></div>\n      </div>\n    </div>\n  </div>\n  \n  <div log-panel></div>", "url": "http://jsbin.com/davag/1", "jsbin": true}
        ]}
    ]},
    {"name": "!events", "type": "", "namespace": "Unified Subscription.Subscription.Declarative", "shortDesc": "!events", "longDesc": "<p>The \"!events\" attributes declare the subscriptions between contextual element as <b>subscriber</b> and other object as publisher. This is one type of attributes. </p>", "signatures": [
        {"name": "!events=\"publisher|handler|options|delegate\"", "returns": "N/A", "shortDesc": "", "desc": "<p>Here a couple possible variations</p>\n<pre data-sub=\"prettyprint:_\">\n!events=\"publisher|handler\"\n!events=\"publisher|handler|options\"\n!events=\"publisher|handler|_\"\n!events=\"publisher|handler|_|delegate\"\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "!events=\"publisher|handler|options|delegate\"", "parameters": [
                {"name": "events", "type": "string", "desc": "event names separated by \"_\""},
                {"name": "publisher", "type": "string", "desc": "A publisher can be node or jQuery object. If publisher is a node, this parameter is sub-path relative to its default path of the element. The full path is their merged path. The path logic is <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.ns?api.apiAction=view&api.selectedEntryName=Core.Node.Path\n\">here</a>. If publisher is jQuery selector, then this parameter should begin with \"$\". "},
                {"name": "handler", "type": "string", "desc": "Handler is string expression handler, the syntax of the expression is <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.ns?api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Handler.string\">here</a>"},
                {"name": "options", "type": "string", "desc": "This parameter is optional. It is useful, when the handler is a workflow type and the workflow type has initialize method to handle the options. The workflow type details is <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Declarative+Sub.ns?api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Workflow\">here</a>. You can explicitly set to undefined by using \"_\". If you have delegate behind, you can use syntax like : !events:publisher|handler|_|delgate. Otherwise, you can use !events:publisher|handler|_ or !events:publisher|handler."},
                {"name": "delegate", "type": "string", "desc": "optional, a jQuery selector to enable jQuery delegate event, this is applicable only if publisher is a element"}
            ]}
        ], "examples": [
            {"desc": "In the following example, the model is updated by a timer. The view subscribe to model's event using \"!events\" attribute.", "code": "  <div data-sub=\"ns:app\">\n    \n    <p>\n      current time:\n      <!-- \"#/app.showTime\" is path expression handler,\n           \"css*background-color\" is activity expression handler\n      -->\n      <span !init_afterUpdate=\"currentTime|#/app.showTime;color|css*background-color\"\n            debug>\n      </span>\n    </p>\n    \n    <p>\n      Duration: \n      <!-- \"text\" is acivity expression handler-->\n      <span !init_afterUpdate=\"duration|text\" debug></span>  \n    </p>\n    \n      <!-- \"*dump\" is workflow type expression handler-->\n    <div !init_after*=\".|*dump\"></div>  \n  \n  </div>", "url": "http://jsbin.com/uhiveg/2", "jsbin": true},
            {"desc": "", "code": "  var app = hm(\"app\", {\n    startedOn: new Date(),\n    currentTime: new Date(),\n    color: \"green\",\n    showTime: function (e) {\n      var time = e.publisher.get();\n      var displayTime = getTime(time);\n      e.subscriber.text(displayTime);\n    },\n    //app.duration has implicit reference to \n    //app.startedOn and app.startedOn\n    duration: function () {\n      return (this.get(\"currentTime\") - this.get(\"startedOn\"))/1000;\n    }\n  });", "url": ""},
            {"desc": "The following example shows how a element subscribe events of another element, with a delegate selector.", "code": "\n\n  <p !click=\"$#controlPanel|val css*background-color|_|.color\" debug>\n      hello\n  </p>\n  \n  <div id=\"controlPanel\">\n   <input type=\"button\" class=\"color\" value=\"red\" >\n   <input type=\"button\" class=\"color\" value=\"blue\" >\n   <input type=\"button\" class=\"color\" value=\"green\" >\n  </div>", "url": "http://jsbin.com/eyirud/2", "jsbin": true}
        ]}
    ]},
    {"name": "$events", "type": "", "namespace": "Unified Subscription.Subscription.Declarative", "shortDesc": "$events", "longDesc": "<p>The \"$events\" attributes declare the subscriptions between contextual element as <b>publisher</b> and other object as subscriber. This is one type of attributes. </p>", "signatures": [
        {"name": "$events:subscriber|handler|options|delegate", "returns": "", "shortDesc": "", "desc": "<p>Here a couple possible variations</p>\n<pre data-sub=\"prettyprint:_\">\n$events:subscriber\n$events:subscriber|handler\n$events:subscriber|handler|_\n$events:subscriber|handler|_|delegate\n</pre>", "overloads": [
            {"versionAdded": "0.1", "name": "$events:subscriber|handler|options|delegate", "parameters": [
                {"name": "events", "type": "string", "desc": "multiple event names separated by \"_\""},
                {"name": "subscriber", "type": "string", "desc": "A subscriber can be node or jQuery object. If subscriber is a node, this parameter is sub-path relative to its default path of the element. The full path is their merged path. The path logic is <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Model.Path\">here</a>. If subscriber is jQuery selector, then this parameter should begin with \"$\"."},
                {"name": "handler", "type": "string", "desc": "optional, string expression handler, the syntax of the expression is <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Unified+Subscription.Subscription.Handler.string\">here</a>.  This parameter is optional, if the subscriber is repository node, and the node value is a function handler. In this case, the function is the handler."},
                {"name": "options", "type": "string", "desc": "optional. It is useful, when the handler is a workflow type and the workflow type has initialize method to handle the options. The workflow type details is <a href=\"fredyang/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Event.Event+Handling.Handler.workflow+type\">here</a>. You can explicitly set to undefined by using \"_\". If you have delegate behind, you can use syntax like : $events:subscriber|handler|_|delegate. Otherwise, you can use $events:subscriber|handler|_ or $events:subscriber|handler"},
                {"name": "delegate", "type": "", "desc": "optional, a jQuery selector to enable jQuery delegate event."}
            ]}
        ], "examples": [
            {"desc": "The following example demonstrate how to use $events ($keyup) attributes to to create subscriptions in which the contextual element is the publisher.", "code": "   \n  <div ns=\"myapp\">\n \n    <div>Your full name (first name, last name):</div>\n  \n    <!-- \"#/myapp.handlers.updatePerson\" is path expression handler-->\n    <input type=\"text\"    \n    $keyup=\"person|#/myapp.handlers.updatePerson\" debug >\n    \n    <div>color:</div>\n    \n    <!-- \"val\" is activity expression handler-->\n    <input type=\"text\" $keyup=\"color|val\" \n    !afterUpdate=\"color|css*background-color\" debug >\n    \n    <div>Password:(pasword is 123)</div>\n    \n    <!-- there is no explicit handler below, \n    because the subscriber (handlers.authenticate) is the\n    implicity handler\n    -->\n    <input type=\"text\" $keyup=\"handlers.authenticate\"  debug >\n    \n\n    <div !init_afterUpdate=\"passed|*show\">You are authenticated.</div>\n  \n  </div>", "url": "http://jsbin.com/qibaz/1", "jsbin": true},
            {"desc": "", "code": "  var model = hm(\"myapp\", {\n      \n    person: {\n      firstName: \"\",\n      lastName: \"\"\n    },\n    \n    color: \"\",\n    \n    passed: false,\n    \n    handlers: {\n      \n      updatePerson: function (e) {\n        \n        var fullName = $.trim(e.publisher.val());\n        parts = fullName.split(separator);\n        //\n        //here \"this\" refer to the e.subscriber myapp.person\n        //but not myapp.handlers\n        //\n        //to avoid the confusion, use e.subscriber instead here\n        //\n        e.subscriber.set(\"firstName\", parts[0] || \"\");\n        e.subscriber.set(\"lastName\", parts[1] || \"\");\n        \n      },\n      \n      authenticate: function (e) {\n        \n        var passed =  (e.publisher.val().trim() == \"123\");\n        \n        //e.subscriber is myapp.hanlers.authenticate\n        //we can do use the following here\n        //\n        //e.subscriber.set(\"...passed\", passed);\n        \n        //but it safer to use the following\n        //\n        model.set(\"passed\", passed);\n        \n      }\n    }", "url": "", "jsbin": true}
        ]}
    ]},
    {"name": "mergePath", "type": "", "namespace": "Node.Path", "shortDesc": "hm.util.mergePath(contextPath, subPath)", "longDesc": "", "signatures": [
        {"name": "hm.util.mergePath(contextPath, subPath)", "returns": "string", "shortDesc": "<p>\nMerge a context path with a sub-path, return a full path.\n</p>", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.util.mergePath(contextPath, subPath)", "parameters": [
                {"name": "contextPath", "type": "string", "desc": "the path of the context node"},
                {"name": "subPath", "type": "string", "desc": "the sub-path relative to the context node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "composite binding", "type": "", "namespace": "Unified Subscription.Subscription.Declarative.binding", "shortDesc": "composite binding", "longDesc": "<p>A composite binding  contains subscriptions and other composite bindings. More specifically, \nit can contains one or zero ns property, and any number of \"!events\", \"$events\" and composite binding . The following define a composite binding which has one \"ns\" property one \"!events\", one \"$events\" and one composite binding.</p>\n\n<pre prettyprint>\nhm.binding(bindingName, \n\"ns:path1;\" + \n\"!events:path2|handler2|options2;\" +\n\"$events:path3|handler3|option3;\" + \n\"anotherBinding:path4|options4\");\n</pre>\n\n<p>\nIn the following, we can define a binding \"text\", which consist of only one subscription.\n</p>\n\n<pre prettyprint>\nhm.binding(\"text\",  \"!init after*:.|get text *toString\");\n</pre>\n\n<p>Then we can apply binding attribute \"text\" to an html element.  In the following, two labels subscribe the events of displayTime, one use composite binding, one use inline events, they create the same subscription in runtime, but the composite binding is more expressive.\n</p>\n\n<pre prettyprint preview=\":_|http://jsbin.com/oyimal/2\">\n\n&lt;div text=\"displayTime\" debug&gt;&lt;/div&gt;\n&lt;div !init_afterUpdate=\"displayTime|get text *toString\" debug&gt;&lt;/div&gt;\n</pre>\n\n<h3>\"ns\" inheritance</h3>\n\n<p> Each binding is also associated with a namespace implicitly or explicitly, the namespace calculation is the same as show in <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Declarative.ns\">\"ns\" attribute</a>. Here are few example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/qipid/1\">\n\n hm.binding(\"binding1\", \"!event1:.|handler1\");\n hm.printBinding(\"binding1:foo\");\n  \n hm.binding(\"binding2\", \"!event2:bar|handler2\");\n hm.printBinding(\"binding2:foo\");\n</pre>\n\n<h3>Nesting binding</h3>\n<p>A parent binding can nest one or more child bindings, and child binding can also nest other bindings,  and the nesting can go any level deep. Here are some example.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/xijey/1\">\n hm.binding(\"binding1\", \"ns:foo;!event1:.|handler1\");\n hm.binding(\"binding2\", \"ns:bar;binding1:.\");\n hm.printBinding(\"ns:qux;binding2:.\");\n</pre>\n\n<h3>options inheritance</h3>\n<p>The subscriptions inside of binding can inherit the options of binding, which can inherit the options of parent binding. For example</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/wunax/1\">\n\n  hm.binding(\"binding1\", \"!event1:.|handler1\");\n  hm.printBinding(\"binding1:path1|foo\");\n  \n  hm.binding(\"binding2\", \"!event2:.|handler2|bar\");\n  hm.printBinding(\"binding2:path2\");\n  \n  hm.binding(\"binding3\", \"!event2:.|handler2|foo\");\n  hm.printBinding(\"binding3:path3|bar\");\n  \n  hm.binding(\"binding4\", \"binding3:.|qux\");\n  hm.printBinding(\"binding4:path4\");\n \n  hm.binding(\"binding5\", \"binding3:.|baz\");\n  hm.printBinding(\"binding5:path5|kiz\");\n</pre>\n\n<h3>options overriding</h3>\n<p>\nA subscription inside of binding can override the options of the binding if the subscription options is prefixed with \"_\". A child binding can override the options of parent binding if the options of child binding is prefixed with \"_\".</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/jonuv/1\">\n  hm.binding(\"binding1\", \"!event1:.|handler|_\");\n  hm.printBinding(\"binding1:path1|foo\");\n  \n  \n  hm.binding(\"binding2\", \"!event2:.|handler|_bar\");\n  hm.printBinding(\"binding2:path2|foo\");\n  \n  hm.binding(\"binding3\", \"!event3:.|hander|foo\");\n  hm.binding(\"binding4\", \"binding3:.|_bar\");\n  hm.printBinding(\"binding4:path4|qux\");\n</pre>", "signatures": []},
    {"name": "trigger", "namespace": "Utilities", "shortDesc": "node.trigger", "longDesc": "<p>This method allows you manually trigger a event to model node. It is useful when you write custom node methods, or directly update the model.\n</p>", "signatures": [
        {"name": "hm.trigger( publisherPath, originalPublisherPath, eventType[, proposed[, removed ]]) ", "returns": "hm", "shortDesc": "trigger an repository event", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "hm.trigger( path, originalPath, eventType, proposed, removed )", "parameters": [
                {"name": "path", "type": "string", "desc": "the path of a node"},
                {"name": "originalPath", "type": "string", "desc": "the path of original node, this is normally the same as path, in Hm.js, it is different when implementing bubbling."},
                {"name": "eventType", "type": "the name of node event", "desc": ""},
                {"name": "proposed", "type": "object", "desc": "optional, the value of proposed change"},
                {"name": "removed", "type": "object", "desc": "optional, the old value of the node"}
            ]}
        ], "examples": []},
        {"name": "node.trigger([subPath,] eventName, proposed, removed)", "returns": "node", "shortDesc": "trigger events to node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.trigger([subPath,] eventName[, proposed[, removed]])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "sub-path relative to the current node, it is current node if this missing"},
                {"name": "eventName", "type": "string", "desc": "the name of repository event"},
                {"name": "proposed", "type": "object", "desc": "optional, the value of proposed change"},
                {"name": "removed", "type": "object", "desc": "optional, the value of old value of the node"}
            ]}
        ], "examples": [
            {"desc": "The following update a model directly instead of using repository model, the raise an custom event. The subscription to customs event will be notified.", "code": "  hm.set(\"person\", {\n    firstName: \"\",\n    lastName: \"\",\n    changeName: function (firstName, lastName) {\n      \n      var person = this.get();\n      var oldPerson = hm.util.clone(person);\n      person.firstName = firstName;\n      person.lastName = lastName;\n      //raised a custom event\n      this.trigger(\"nameChanged\", person, oldPerson);\n    }\n  });\n  \n  hm.handle(\"person\", \"nameChanged\", function (e) {\n    hm.log(\"person is changed from \" + JSON.stringify(e.removed) + \" to \" + JSON.stringify(e.proposed));\n    \n  });\n  \n  hm(\"person\").set(\"changeName\", \"John\", \"Doe\");", "url": "http://jsbin.com/qokur/1"}
        ]}
    ]},
    {"name": "activities", "namespace": "Template", "shortDesc": "activites", "longDesc": "<p>\nThere are three template activities, they are initialize activity \"templateOptions\", convert activity \"template\", finalize activity, \"parseSubs\".\n</p>", "signatures": []},
    {"name": "workflow", "namespace": "Template", "shortDesc": "workflow", "longDesc": "<p>\nHm.js includes two template workflows, \"tmpl\" and \"include\".  They are defined as following\n</p>\n\n<pre prettyprint>\nhm.workflow(\"tmpl\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", \n  convert: \"*template\",\n  set: \"html\",\n  finalize: \"*parseSubs\"\n});\n\nhm.workflow(\"include\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", \n  convert: \"*template\",\n  set: \"replaceWith\",\n  finalize: \"*parseSubs\"\n});\n</pre>\n\n<p>All the template workflow share the same \"initialize\", \"convert\", and \"finalize\" activity,  the only difference is the \"get\" and \"set\" activity. You can use the above code as boilerplate to create your template workflow.  You can also use the  the following method to create a template workflow, these method already include common activity, all you need is add you \"get\" activity and \"set\" activity.\n</p>\n\n<pre prettyprint>\nvar myTemplateWorkflow = \nhm.template.newTemplateHandler ( getActivity, setActivity );\n\nhm.workflow(\"myTemplateWorkflow\",  myTemplateWorkflow);\n</pre>", "signatures": []},
    {"name": "bindings", "namespace": "Template", "shortDesc": "bindings", "longDesc": "<p>\nHm.js includes 5 template bindings  like the following.\n</p>\n<pre prettyprint>\nhm.binding( {\n\n  tmpl: \"!init:.|*tmpl\",\n\n  tmplOnChange: \"!init after*.:.|*tmpl\",\n\n  tmplOnChildChange: \"!init after*. after*.1:.|*tmpl\",\n\n  tmplOnAnyChange: \"!init after*:.|*tmpl\",\n\n  include: \"!init:.|*include\"\n} );\n</pre>\n\n<p>All \"tmplXXX\" bindings generate contents inside the attached element, the difference is how to update the content in response the change of model or the child model. and the contents will be reproduced on the change of model. The following example show differences.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/ElaNokA/3\">\n\n&lt;tbody tmpl=\"contacts|personTemplate\"&gt;&lt;/tbody&gt;\n\n&lt;tbody tmpl-on-change=\"contacts|personTemplate\"&gt;&lt;/tbody&gt;\n\n&lt;tbody tmpl-on-child-change=\"contacts|personTemplate\"&gt;&lt;/tbody&gt;\n\n&lt;tbody tmpl-on-any-change=\"contacts|personTemplate\"&gt;&lt;/tbody&gt;\n</pre>\n\n\n<p>The \"include\" binding also generate contents, but the container is replaced with the contents it generate. The following example shows this.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/IsoLeWU/2\">\n  \n&lt;table&gt;\n  &lt;tr&gt;\n   &lt;td&gt;First Name&lt;/td&gt;\n   &lt;td&gt;Last Name&lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr include=\"app.contacts|contactsTemplate\"&gt;&lt;/tr&gt;\n&lt;/table&gt;\n</pre>", "signatures": []},
    {"name": "renderTmpl", "namespace": "Template.handler types", "shortDesc": "renderTmpl", "longDesc": "<p>This workflow is defined as below.</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.workflow(\"renderTmpl\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", //extensible\n  convert: \"*template\",\n  set: \"html\", //extensible\n  finalize: \"*parseSubs\"\n});\n</pre>\n\n<p>\nThe activities of <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Template.activities.templateOptions\">templateOptions</a> , <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Template.activities.template\">template</a>, <a href=\"#api.apiAction=view&api.selectedEntryName=Core.Template.activities.parseSubs\">parseSubs</a> are shared by all template workflow type. What is special here, is that , the worklow's get activity, simply just get the value of publisher, and use jQuery html method to fill the content of subscriber, which here is an html element.\n</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/ejeten/1\">\n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;tbody data-sub=\"!init:app.contacts|*renderTmpl\"&gt;\n      &lt;tr&gt;\n\t\t&lt;td&gt;\n          {{:firstName}}\n\t\t&lt;/td&gt;\n\t\t&lt;td&gt;\n          {{:lastName}}\n\t\t&lt;/td&gt;\n\t&lt;/tr&gt;\n\t&lt;/tbody&gt;\n  &lt;/table&gt;\n</pre>", "signatures": []},
    {"name": "replace", "namespace": "Template.handler types", "shortDesc": "replace", "longDesc": "<p>This workflow is defined as below.</p>\n<pre data-sub=\"prettyprint:_\">\nhm.workflow(\"replace\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", //extensible\n  convert: \"*template\",\n  set: \"replaceWith\", //extensible\n  finalize: \"*parseSubs\"\n});\n</pre>\n\n<p>\nThe activities of <a href=\"\">templateOptions</a> , <a href=\"\">template</a>, <a href=\"\">parseSubs</a> are shared by all template workflow type. What is special here, is that , the worklow's get activity, simply just get the value of publisher, and use jQuery \"replaceWith\" method to replace subscriber itself with the generated mark-up.\n</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/uceqik/1\">\n    &lt;script type=\"jsrender\" id=\"contactsTemplate\"&gt;\n      &lt;tr&gt;\n\t\t&lt;td&gt;\n          {{:firstName}}\n\t\t&lt;/td&gt;\n\t\t&lt;td&gt;\n          {{:lastName}}\n\t\t&lt;/td&gt;\n\t&lt;/tr&gt;\n  &lt;/script&gt;\n  \n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;!-- this will be replaced with the mark-up --&gt;\n    &lt;tr !init=\"app.contacts|*replace|contactsTemplate\"&gt;&lt;/tr&gt;\n  &lt;/table&gt;\n</pre>", "signatures": []},
    {"name": "templateOptions", "namespace": "Template.activities", "shortDesc": "templateOptions", "longDesc": "<p>\"templateOptions\" activity is an initialize activity, it is used to initialize an handler with a template options to be used in \"template\" activity. A template option is like the following:</p>\n\n\n<h3><code>templateId[,wrapDataInArray[,engineName]]</code></h3>\n\n<p>The first parameter in the option is <code>templateId</code>, which is required, then followed by two optional parameter <code>wrapDataInArray</code> ('true' or 'false'), and <code>engineName</code> (the name of engine)  When engineName is missing, the value of <code>hm.template.defaultEngine</code> is used. </p>\n\n<p>This activity extract  templateId, wrapDataInArray, and engineName from the options, and then attached it to the handler. It is a function below. \n</p>\n\n<pre prettyprint>\nhm.activity.initialize.templateOptions =  function( publisher, subscriber, work, options ) {};\n</pre>\n\n<p>The following sample manually use the activity to initialize a dummy handler, and the content of the handler is dumped to the screen</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/iVohePu/2\">\nvar publisher = {}, \n    subscriber = {},\n    handler = {};\n    \n\nhm.activity.initialize.templateOptions(\n  publisher, \n  subscriber, \n  handler, \n  \"myTemplateId,true,jsrender\");\n\n\nhm.log(JSON.stringify(handler));\n\n//reset handler to an empty object\nhandler = {};\n\nhm.activity.initialize.templateOptions(\n  publisher, \n  subscriber, \n  handler, \n  \"myTemplateId\");\n\nhm.log(JSON.stringify(handler));\n</pre>\n\n<p>If you use inline template inside the element, you don't need an options</p>\n", "signatures": []},
    {"name": "template", "namespace": "Template.activities", "shortDesc": "template (convert activity)", "longDesc": "<p>\nThis activity is a \"convert\" activity, which convert the data produced by \"get\" activity into a jQuery object which wrap a dom element list. The following is skeleton of the activity's implementation.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.activity.convert.template = function( data, e ) {\n\n//data is produced by \"get\" activity\n//e.handler.templateId is set in \"initialize\" activity \"templateOptions\"\nreturn templateAdapter.render( templateId, data, renderContext) ;\n\n}\n</pre>\n\n<p>The data returned in \"get\" activity and the template id set in \"initialize\" activity \"templateOptions\" are accessible in this activity, it combine data and template into html and wrap it with a jQuery object. If the template is an external template it will return a promise which will resolve html later.\n</p>\n\n<h3>Unit test your template</h3>\n<p>Normally you don't call this function directly, but you can use it to unit test your template with this activity like the following example.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/uzoj/2\">\n  var data = [{\n      firstName: \"John\",\n      lastName: \"Doe\"\n    }, {\n      firstName: \"Jane\",\n      lastName: \"Roe\"\n    }]\n\n  var e = {\n    publisher: hm(\"app.contacts\"),\n    handler: {\n      templateId: \"contactsTemplate\"\n    }\n  };\n\n  var $obj = hm.activity.convert.template(data, e);\n  \n $(\"tbody\").html($obj);\n</pre>\n\n<pre prettyprint>\n &lt;script type=\"jsrender\" id=\"contactsTemplate\"&gt;\n  &lt;tr&gt;\n     &lt;td&gt;\n    {{:firstName}}\n\t&lt;/td&gt;\n\t&lt;td&gt;\n     {{:lastName}}\n\t&lt;/td&gt;\n\t&lt;/tr&gt;\n &lt;/script&gt;\n &lt;table&gt;\n  &lt;thead&gt;\n  &lt;tr&gt;\n   &lt;td&gt;First Name&lt;/td&gt;\n   &lt;td&gt;Last Name&lt;/td&gt;\n\t&lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n  &lt;/tbody&gt;\n &lt;/table&gt;\n</pre>\n\n<h3>render context</h3>\n<p>Hm.js does not include a template engine, instead it uses a template engine adapter to delegate the work to third party template engine, using the following code\n</p>\n\n<pre prettyprint>\ntemplateAdapter.render( templateId, data, renderContext ) ;\n</pre>\n\n<p>\nThe renderContext object is an instance of RenderContext, which is defined as following\n</p>\n\n<pre prettyprint>\n{\n  modelPath: e.publisher.path,\n  e: e,\n  get: function () {\n \tvar publisher = e.publisher;                      \n\treturn publisher.get.apply( publisher, arguments );    \n  }\n} \n</pre>\n\n<p>When we implement our template adapter,  we can use render context to access to model and event object.  The built-in \"jsrender\" and \"handlebarjs\" both adapter have two helper \"get\" and \"prop\" which use the render context. The \"get\" helper can call the a model node's function, the \"prop\" helper can access the model's function. The following example show how to use these two tag to access model in \"jsrender\".\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/OgihiLE/2\">\n\nvar Person = hm.Class.extend({\n  fullName: function () {\n    return this.get(\"firstName\") + \" , \" + this.get(\"lastName\");\n  }\n});\n\nhm(\"app\", {\n  \"contacts\": Person.list([{\n    firstName: \"John\",\n    lastName: \"Doe\",\n    gender: \"m\"\n  }, {\n    firstName: \"Jane\",\n    lastName: \"Roe\",\n    gender: \"f\"\n  }]),\n\n  getTitle: function (gender) {\n    if (gender == \"m\") {\n      return \"Mr.\";\n    } else {\n      return \"Mrs.\";\n    }\n  }\n});</pre>\n\n<pre prettyprint>\n &lt;script type=\"jsrender\" id=\"contactsTemplate\"&gt;\n    &lt;tr&gt;\n      &lt;td&gt;&lt;!-- use \"get\" tag to call model node function --&gt;\n          {{get \"..getTitle\" gender /}}                          \n     &lt;/td&gt;   \n\t&lt;td&gt;\n     {{:firstName}}\n\t&lt;/td&gt;\n\t&lt;td&gt;\n      {{:lastName}} \n\t&lt;/td&gt;\n     &lt;td&gt;     \n     &lt;!-- use \"prop\" tag to call model's function --&gt;\n       {{prop \"fullName\" /}}                               \n   &lt;/td&gt;\n &lt;/tr&gt;\n&lt;/script&gt;\n  \n  \n  &lt;table&gt;\n    &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Title&lt;/td&gt;\n      &lt;td&gt;First Name&lt;/td&gt;\n      &lt;td&gt;Last Name&lt;/td&gt;\n      &lt;td&gt;Full Name&lt;/td&gt;\n\t&lt;/tr&gt;\n    &lt;/thead&gt;\n    &lt;tbody tmpl=\"app.contacts|contactsTemplate\"&gt;&lt;/tbody&gt;\n  &lt;/table&gt;\n</pre>\n\n", "signatures": []},
    {"name": "parseSubs", "namespace": "Template.activities", "shortDesc": "parseSubs (finalize activity)", "longDesc": "<p>The definition of these activity is as below</p>\n\n<pre prettyprint>\nhm.activity.finalize.parseSubs = function( value, e ) { \n $( value ).parseSubs();                                                                                       \n};                                                     \n</pre>\n\n<p>After template activity and set activity are returned, and the mark-up is merged into DOM, this activity will is called to import the subscriptions declared in the mark-up. The following shows the difference of two workflow, one use this activity, one doesn't.</p>\n\n<pre prettyprint  preview=\"_|http://jsbin.com/opUjaYo/2\">\nhm.workflow(\"handlerWithoutFinalizer\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", \n  convert: \"*template\",\n  set: \"replaceWith\"\n});\n\nhm.workflow(\"handlerWithFinalizer\",  {\n  initialize: \"*templateOptions\",\n  get: \"get\", \n  convert: \"*template\",\n  set: \"replaceWith\",\n  finalize: \"*parseSubs\"\n});\n\n\nhm(\"myapp\", {\n  firstName: \"John\",\n  lastName: \"Doe\",\n  fullName: function () {\n    return this.get(\"firstName\") + \",\" + this.get(\"lastName\"); \n  }  \n});\n</pre>\n<pre prettyprint>\n &lt;script type=\"jsrender\" id=\"myTemplate\"&gt;\n  &lt;div ns=\"myapp\"&gt;\n    &lt;lable&gt;firstName: &lt;input type=\"text\" val=\"firstName|keyup\" &gt;&lt;/label&gt;\n    &lt;lable&gt;lastName: &lt;input type=\"text\" val=\"lastName|keyup\" &gt;&lt;/label&gt;\n   &lt;div text=\"fullName\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/script&gt;\n  \n&lt;div&gt;The following render &lt;b&gt;without&lt;/b&gt; parseSub \"finalize\" activity&lt;/div&gt;\n\n&lt;div !init=\".|*handlerWithoutFinalizer|myTemplate\"&gt;&lt;/div&gt;\n\n&lt;hr /&gt;  \n\n&lt;div&gt;The following render &lt;b&gt;with&lt;/b&gt; parseSub \"finalize\" activity&lt;/div&gt;\n\n&lt;div !init=\".|*handlerWithFinalizer|myTemplate\"&gt;&lt;/div&gt;\n</pre>\n\n\n<h3>Recursive child view rendering</h3>\n<p>\nThis activity is important activity. With it, we can recursively render child view. In the following example, the root view &lt;body /&gt; render its child view, and child views render their child view recursively, eventually, a whole application is build. \n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/oFEqiYEj/2\">\n\n\n&lt;body tmpl=\"/|rootView\"&gt;&lt;/body&gt;\n</pre>", "signatures": []},
    {"name": "template engine adapter", "namespace": "Template", "shortDesc": "template engine adapter", "longDesc": "<p>Hm.js does not include a template engine, it uses template adapters to talk to third party template engine.  Hm.js includes two adapters, one for template engine <a href=\"https://github.com/BorisMoore/jsrender\">jsrender</a>, one for handlebarjs.  To add an adapter, use the following syntax.\n</p>\n\n<pre prettyprint>\nhm.template.engineAdapter( \"myTemplateEngine\", {\n  render: function( templateId, data, context ) { }\n  //...additional member\n});\n</pre>\n\n<p>If the above statement is called, the default template engine will be \"myTemplateEngine\", if a <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Template.activities.templateOptions\">templateOptions</a> does not include an engine name, \"myTemplateEngine\" will is the default engine If you want to change another engine as default engine use the follow: </p>\n\n<pre prettyprint>\nhm.template.defaultEngine = \"anotherEngine\";\n</pre>\n\n<p>There are two kinds of template rendering,  synchronous,  asynchronous. Synchronous rendering is used when a template is inline template and internal template. Asynchronous rendering is used when a template is external template, asynchronous is optional.</p>\n\n<h3>Implementing synchronous rendering</h3>\n<p>To implement synchronous rendering, you need <b>one and only one</b> method in your adapter. This method can return <b>string or DOM elements</b>. The following is how jsrender adapter's  implementation.</p>\n<pre data-sub=\"prettyprint:_\">\njsRenderAdapter.render = function (templateId, data, context) {\n  if (!$.render[templateId]) {\n    this.compile(templateId,\n    document.getElementById(templateId).innerHTML);\n  }\n  return $.render[templateId](data, context);\n};\n</pre>\n\n<h3>Implementing asynchronous rendering</h3>\n<h4>adapter.isTemplateLoaded</h4>\n<p>There are a couple of options to implement asynchronous rendering. But regardless which options, firstly you must implement adapter.isTemplateLoaded method. Without it,  Hm.js doesn't  know whether a template is external template or not. Here is jsRender adapter's implementation.\n</p>\n\n<pre prettyprint>\njsRenderAdapter.isTemplateLoaded = function (templateId) {\n  return !!$.render[templateId] || !! document.getElementById(templateId);\n};\n</pre>\n\n<p>Additionally, you need to implement one of the following.</p>\n\n<h4>Option 1: implement adapter.async</h4>\n\n<p>This method should return a jQuery promise, which promise to deliver text or DOM element. Here it is signature:</p>\n\n<pre data-sub=\"prettyprint:_\">\njsRenderAdapter.renderAsync = function(templateId, data, renderContext ) {\n//return jQuery promise which promise to deliver text or DOM element\n};\n</pre>\n\n<h4>Option 2: implement <code>hm.template.load()</code></h4>\n\n<p>This method return an empty promise. When the template is loaded, you signal that the promise is done, Hm.js will call <code>adapter.render()</code>. The method is like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.template.load = function( templateId ) { \n //return an empty promise\n}\n</pre>\n\n<h4>Option 3: implement <code>jsRenderAdapter.compile()</code></h4>\n\n<p>This is the easiest way to implement asynchronous rendering. Hm.js will take care of the template fetching and other plumbing.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\njsRenderAdapter.compile = function (templateId, source) {\n  $.templates(templateId, {\n    markup: source,\n    debug: jsRenderAdapter.templateDebugMode,\n    allowCode: jsRenderAdapter.allowCodeInTemplate\n  });\n};\n</pre>\n\n<h3>Other template engine specific setting</h3>\n<p>If you have some settings specific to to a template engine, you can add this setting to the template adapter, so that the can be used in render method and the compile method. The following shows how to change the setting for jsrender adapter.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n//the following are jsRender specific settings\njsRenderAdapter.templateDebugMode = false;\njsRenderAdapter.allowCodeInTemplate = true;\n\n//such as\nhm.template.engineAdapter(\"jsrender\").templateDebugMode = true;\nhm.template.engineAdapter(\"jsrender\").allowCodeInTemplate = false;\n</pre>", "signatures": []},
    {"name": "App", "namespace": "bulit-in bindings", "shortDesc": "App", "longDesc": "<p>In hm.js, an application is a module which has both view and module, and their behavior defined in subscriptions. The <code>app</code> binding can be used to create such kind of application. An application can be a aggregation of child application, or it can be just atomic application. \nAn application is physically implemented by a set of resource which include data, template, css, JavaScript code. You need organize them in a pre-defined way. Later when the app binding is parsed, hm.js will dynamically load them into the page, and you don't need to statically import this assets into your page using traditional &lt;script /&gt; and &lt;link /&gt; tag.\n</p>\n\n<h3>App definition vs App instance</h3>\n<p>There are two different concept, although the are related. App definition does two thing.\n\n</p>\n<ol>\n<li>bootstrapping app instances</li>\n<li>unload app instances</li>\n</ol>\n\n\n<p>\nApp instance is the result of bootstrapping. Bootstrapping create the views and models, and the subscriptions among them. In the following, when it said \" building app\", it means building app definition. When it is said \"load an app\", which means creating app instance.\n</p>\n\n<h3>Bootstrap an app instance</h3>\n<p>\nIn <a href=\"#api.apiAction=view&api.selectedEntryName=Core.value+adapter?api.apiAction=view&api.selectedEntryName=Template.External+Template\">external template</a>, we saw an <a href=\"http://plnkr.co/edit/6XsWZG?p=preview\" target=\"_blank\">example</a> that the view can render itself by fetching the template dynamically.  But the model of the application is still defined in JavaScript file which is statically imported into the page using &lt;script /&gt; tag. An app definition can bootstrap an application instance with all the assets and resource including template, css,  data, etc. There are two ways to bootstrap the an application,  declaratively or programmatically.  Declarative bootstrapping use the <code>app</code> binding, which internally call the <code>hm.App.load</code> to bootstrap an application programmatically. The following examples basically does the same thing.\n</p>\n\n<pre prettyprint>\nhm.App.load( appName, viewContainer, modelContainer, options  );\n//example\n//default viewContainer is document.body, \n//modelContainer is root model hm()\nhm.App.load( \"demo\" );  \n</pre>\n\n<pre prettyprint>\n&lt;tag app=\"modelContainer|appName|options\"&gt;&lt;/tag&gt;\n&lt;!-- example --&gt;\n&lt;body app=\"/|demo\"&gt;&lt;/body&gt;\n</pre>\n\n<p>In the bootstrapping process, the following things happen.</p>\n<ol class=\"list\">\n\n<li>Check whether the definition of the app is available. If it is available, call the following method. If it is not available, use <code>hm.loader</code> to load it asynchronously. After it is available, call the following method and continue next step, and the real bootstrapping start.\n\n<pre prettyprint>\napp.load( viewContainer, modelContainer, options );\n</pre>\n\n</li>\n\n<li>Load the initial data required by the app instance</li>\n\n<li>Build root model with the initial data under a unique namespace so that it will collide with other models</li>\n\n<li>Build root view using template workflow and root model inside view container.  Because it is under a view container, it is possible that we have multiple app instance.\n\n<p>Because of \"finalize\" activity <a href=\"#api.apiAction=view&api.selectedEntryName=Core.value+adapter?api.apiAction=view&api.selectedEntryName=Template.activities.parseSubs\">parseSubs</a> of template workflow, the root view can build is child views and descendant view using declarative subscriptions.</p></li>\n\n\n<li>Save the app instance to the view container's private state, so that only one app instance can be only loaded to the view container once. And the app instance can be also retrieve from the view container later to unload itself from the view container. \n</li>\n\n<li>Increment the instance count of the app for profiling purpose, and  it can be also used for enforce singleton app instance if it is desired.\n</li>\n</ol>\n\n<p>\nThe follow example demonstrate how to implement a simple application definition. The assets of the application definition include demo.js, demo.css, and server html files which define the templates. \n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/3K8kU0/preview\">\n/*\n    &lt;@depend&gt;\n    demo.css\n    &lt;/@depend&gt;\n*/\n\n(function () {\n\n  hm.App.add({\n    name: \"demo\",\n    getInitialData: function () {\n      return {\n        \"contacts\": [{\n          firstName: \"John\",\n          lastName: \"Doe\"\n          }, \n          {\n            firstName: \"Jane\",\n            lastName: \"Roe\"\n          }\n        ]};\n    }\n  });\n  \n})();\n\n</pre>\n\n<pre prettyprint>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;title&gt;app binding test&lt;/title&gt;    \n&lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://code.semanticsworks.com/assets/js/jsrender.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://code.semanticsworks.com/assets/js/hm.debug.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nhm.loader(\"app\").url = function (moduleId) {\n   var fileName = hm.loader.fileName( moduleId );\n  return fileName + \".js\";\n  };\n&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body app=\"/|demo\"&gt;  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n\n<h3>Unload an app instance</h3>\n<p>When an app is not required any more, it can be unloaded by the request from outside or inside of the view container. The unload behavior is extensible, by default it does the following thing</p>\n<ol class=\"list\">\n <li>empty the view container</li>\n  <li>delete the root model created under the model container</li>\n</ol>\n\n<p>\nIn the following example, it shows how an application can be loaded on demand, and unloaded on demand. \n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/yHmST9/preview\">\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;title&gt;load/unload app&lt;/title&gt;\n&lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://code.semanticsworks.com/assets/js/jsrender.js\"&gt;&lt;/script&gt;\n&lt;script src=\"http://code.semanticsworks.com/assets/js/hm.debug.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n(function (){\n  hm.loader(\"app\").url = function (moduleId) {\n\tvar fileName = hm.loader.fileName( moduleId );\n return fileName + \".js\";\n};\n})();\n&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;input type=\"button\" value=\"load gmail\" load-app=\"/|gmail,#container\"&gt;\n&lt;input type=\"button\" value=\"unload gmail outside of app container\" unload-app=\"/|gmail,#container\"&gt;\n\n&lt;div id=\"container\"&gt;\n&lt;/div&gt;\n\n&lt;input type=\"button\" value=\"load gmail 2\" load-app=\"/|gmail,#container2\"&gt;\n&lt;input type=\"button\" value=\"unload gmail 2 outside of app container\" unload-app=\"/|gmail,#container2\"&gt;\n\n&lt;div id=\"container2\"&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n", "signatures": []},
    {"name": "Async activity", "namespace": "Unified Subscription.Subscription.Activity", "shortDesc": "Async activity", "longDesc": "<p>An async activity  is an activity which returns a jQuery promise object, which promises to return the value later. Currently, the \"get\" activity and \"convert\" activity can be asynchronous.  </p>\n\n<p>When you compose an handler with activities, you can mix and match synchronous and async activities together, Hm.js will take care of the connection between them.  For example, if you can use an async \"get\" activity, and synchronous \"set\" activity, however the value passed into the \"set\" activity is not a promise but a value the resolved by the promise, these has been taken care by hm.js.\n</p>\n\n<p>The following example use a handler with two async \"get\", \"convert\" activity. You need to click a button complete an activity to simulate the asynchronous process. \n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/aNojUDU/2\">\n var deferredGet,\n      deferredConvert,      \n      model = hm(\"myapp\", {    \n        handlerStatus: \"stopped\",    \n        getValue: null,    \n        convertValue: null,    \n        result: null,       \n        handlers: {      \n          getValue: {\n            //asyn activity        \n            get: function (e) {    \n              model.set(\"result\", null);    \n              model.set(\"getValue\", \"defaultGetValue\");          \n              model.set(\"convertValue\", \"defaultConvertValue\");          \n              hm.clearlog();      \n              hm.log(\"'get' activity started, waiting promise of 'get' activity to be resolved...\");          \n              deferredGet = $.Deferred();          \n              model.set(\"handlerStatus\", \"getting\");          \n              //return a promise, but not true value          \n              return deferredGet.promise();        \n            },\n        \n            //asyn activity        \n            convert: function (value, e) {\n              hm.log(\"'convert' receive value from 'get' activity: '\" + value +               \n                     \"', waiting for promise of convert activity to be resolved...\");          \n              deferredConvert = $.Deferred();          \n              //return a promise, but not true value          \n              model.set(\"handlerStatus\", \"converting\");          \n              return deferredConvert.promise();        \n            },\n                \n            set: function (value, e) {          \n              model.set(\"result\", value);          \n              hm.log(\"'set' receive value from 'convert' activity: '\" + value + \"'\");                \n            },\n                \n            finalize: function (value, e) {          \n              hm.log(\"'finalize' receive value from 'convert' activity: \" + value);          \n              model.set(\"handlerStatus\", \"stopped\");          \n              deferredGet = null;          \n              deferredConvert = null;               \n            }      \n          },\n      \n          finishGetActivity: function (e) {\n            hm.log(\"resolving promise of 'get' activity\");\n            deferredGet.resolve(model.get(\"getValue\"));              \n          },\n            \n          finishConvertActivity: function (e) {        \n            hm.log(\"resolving promise of 'convert' activity\");        \n            deferredConvert.resolve(model.get(\"getValue\") + \",\" + model.get(\"convertValue\"));        \n      \n          }    \n        }    \n      });\n</pre>", "signatures": []},
    {"name": "change", "namespace": "Utilities", "shortDesc": "node.change()", "longDesc": "", "signatures": [
        {"name": "node.change([subPath])", "returns": "node", "shortDesc": "trigger a \"afterUpdate\" event to a node.", "desc": "It is a shortcut of triggering a \"afterUpdate\" event to a node", "overloads": [
            {"versionAdded": "0.1", "name": "node.change(subPath)", "parameters": [
                {"name": "[subPath]", "type": "string", "desc": "optional, sub-path relative to the node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "debugging", "namespace": "Utilities", "shortDesc": "debugging", "longDesc": "<p>\nThere are a couple debugging functions that help you to see what subscriptions has been created for model or view,  they are only for debugging purpose,  do not used it for other purpose.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n//the obj might be a jQuery object or model node\n//subscriptions in which the object is publisher\nsubscriptions = obj.subsToMe(); \n//\n//subscriptions in which the object is subscriber,\nsubscriptions = obj.subsFromMe(); \n//\n//subscriptions in which the object is either publisher or subscriber\nsubscriptions = obj.subscriptions(); \n</pre>", "signatures": []},
    {"name": "onDeleteNode", "namespace": "Node.callbacks", "shortDesc": "onDeleteNode", "longDesc": "<p>\nThe function's signature is \n</p>\n\n<pre data-sub=\"prettyprint:_\">\nfunction ( physicalPath, removedValue ) {\n\n}\n</pre>", "signatures": [
        {"name": "hm.onDeleteNode(fn)", "returns": "hm", "shortDesc": "add a function to be called back when node is deleted", "desc": "", "overloads": [], "examples": []}
    ]},
    {"name": "onAddOrUpdateNode", "namespace": "Node.callbacks", "shortDesc": "onAddOrUpdateNode", "longDesc": "", "signatures": []},
    {"name": "val", "namespace": "bulit-in bindings", "shortDesc": "val", "longDesc": "<p>We use form elements such \"input\", \"select\" to capture user's input. In hm.js, we can attach subscription to these elements to convert them into a model value like the following.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/IYUYEg/2\">\n\n&lt;input $change=\"name|val\" !init_afterUpdate=\"name|val\"&gt;\n\n</pre>\n\n<p>But the declarative subscriptions are a little verbose. The \"val\" binding can simplify these. It is an extensible dynamic binding,  which can easily create one-way or two-way connection between  simple form elements or complex widget such as date picker of third party to a model node.  If the widget is third party, you can implement a value adapter \"date\" like the following example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/AkeCANe/3\">\n\n&lt;form ns=\"myapp.profile\"&gt;\n    \n    &lt;label&gt;&lt;b&gt;Name:&lt;/b&gt;\n      &lt;input type=\"text\" val=\"name\"&gt;\n    &lt;/label&gt;\n  \n    &lt;label&gt;&lt;b&gt;Date of Birth:&lt;/b&gt;    \n      &lt;input type=\"text\" val=\"dateOfBirth|,,date\"&gt;\n    &lt;/label&gt;\n  \n    &lt;label&gt;&lt;b&gt;Language &lt;br&gt; (ctrl + click to select multiple):&lt;/b&gt;\n      &lt;br/&gt;      \n      &lt;select multiple options=\"..lookupData.languages\"  val=\"languages\"&gt;&lt;/select&gt;\n    &lt;/label&gt;\n  \n    &lt;label&gt;&lt;b&gt;Major:&lt;/b&gt;\n      &lt;select caption=\"..lookupData.caption\"\n           options=\"..lookupData.majors\"\n           val=\"major\"&gt;&lt;/select&gt;\n    &lt;/label&gt;\n  \n    &lt;div class=\"label\"&gt;&lt;b&gt;Gender:&lt;/b&gt;\n      &lt;label class=\"normal\"&gt;\n        &lt;input type=\"radio\" val=\"gender\" value=\"male\"&gt;Male&lt;/label&gt;&amp;nbsp; &amp;nbsp;\n      &lt;label class=\"normal\"&gt;\n      &lt;input type=\"radio\" val=\"gender\" value=\"female\"&gt;Female&lt;/label&gt;  \n    &lt;/div&gt;\n\n    &lt;div class=\"label\"&gt;&lt;b&gt;&lt;/b&gt;\n      &lt;label class=\"normal\"&gt;\n        &lt;input type=\"checkbox\" val=\"accept\"&gt;Accept terms?&lt;/label&gt;\n    &lt;/div&gt;\n    \n    &lt;label&gt;    \n      &lt;b&gt;&lt;/b&gt;    \n      &lt;input type=\"button\"  $click=\"/myapp.submit\" value=\"Submit\" /&gt;\n      &lt;button type=\"reset\"&gt;reset&lt;/button&gt;\n    &lt;/label&gt;\n  &lt;/form&gt;\n</pre>\n\n<h3>value adapter</h3>\n<p>The \"val\" binding works for all html form elements. But if you want to use it with third party widget, you need to implement a value adapter like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.valueAdapter({\n  //optional if match function is present\n  name: \"adapterName\",\n  //\n  //optional if name is present\n  match: function ($elem) {\n    return true;\n  },\n  //\n  //prepare $element\n  initialize: function ($elem, modelValue) {}\n  //\n  //get a value from element\n  get: function ($elem, e) {},\n  //\n  //set a value to $element\n  set: function ($elem, value, e) {},\n  //\n  //optional, if get function already convert, you don't need this\n  //object is a string \"*commonConvertActivityName\" or \n  //function (value) {}\n  convert: object \n});\n</pre>\n\n<p>\nThe following is a implementation of value adapter for jQuery UI datepicker.\n</p>\n<pre prettyprint>\nhm.valueAdapter({\n  name: \"date\",\n\tinitialize: function( $elem, modelValue ) {\n         $elem.datepicker( {\n\t\tonSelect: function( dateText, instance ) {\n\t\t$( this ).trigger( \"change\" );\n\t},\n            defalutDate: modelValue\n\t} );\n          \n        setTimeout(function () {\n         $elem.attr(\"value\", $elem.val());\n      }, 10);\n  },\n  //get value from view and set the model\n  get: function ($elem) {\n    return $elem.datepicker(\"getDate\");\n\n  },\n  //get value from model and set the view\n  set: function ($elem, value, e) {\n    if (+$elem.datepicker(\"getDate\") != +value) {\n      $elem.datepicker(\"setDate\", value);\n    }\n  }\n});\n</pre>\n\n<p>If you the value adapter has implement the match function,  hm.js can automatically to pickup the adapter for you, and you can  use \"val\" binding like <code>val=\"path\"</code>. In the above implementation, there is no match function. So you need to specify the adapter name in your binding like the following.\n</p>\n\n<pre prettyprint>\n&lt;input type=\"val:dateOfBirth|,,date\" &gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/ELOVIMe/2\">\n &lt;form&gt;\n  &lt;p&gt;\n    &lt;label&gt;Date of Birth:\n      &lt;input type=\"text\" val=\"dateOfBirth|,,date\"&gt;    \n  &lt;/p&gt;\n  &lt;p&gt;\n   &lt;input type=\"reset\"&gt;\n  &lt;/p&gt;\n&lt;/form&gt;\n</pre>\n\n<pre prettyprint>\nhm(\"myapp\", {\n  dateOfBirth: new Date()\n});\n</pre>", "signatures": [
        {"name": "val:path[|[updateEvent],[updateTarget][,adapterName]]", "returns": "N/A", "shortDesc": "building subscriptions between a view and a model so that a view's value and model's value can be synchronized.", "desc": "<p>In a lot of case, you can use the default format like <code>val:path</code> , but you can fine tune the binding behavior using options. Here are a couple other possible usages</p>\n\n<ul>\n<li><code>val:path</code> <br>This means update model when \"change\" event trigger to view, and both model and view need to be updated. Use adapter.match function to select the adapter.</li>\n<li>\n<code>val:path|keypress</code> <br>This means update model when \"keypress\" event trigger to view, and both model and view need to be updated. Use adapter.match function to select the adapter.\n<li>\n<code>val:path|,model</code> <br>This means update model when \"change\" event trigger to view, and only model need to be updated. Use adapter.match function to select the adapter.\n</li>\n<li>\n<code>val:path|,view</code> <br>This means update model when \"change\" event trigger to view, and only view need to be updated. Use adapter.match function to select the adapter.\n</li>\n<li>\n<code>val:path|,,date</code> <br>This means update model when \"change\" event trigger to view, and both model and view need to be updated. Use \"date\" adapter, for this binding.\n</li>\n<li>\n<code>val:path|keyup,model,temperature</code> <br> This means update model when \"keyup\" event trigger to the view, and only model needs to be updated. Use \"temperature\" adapter for this binding.\n</li>\n</ul>", "overloads": [
            {"versionAdded": "0.1", "name": "val:path[|[updateEvent],[updateTarget][,adapterName]]", "parameters": [
                {"name": "updateEvent", "type": "string", "desc": "optional, by default it is \"change\" event, other values can be \"keyup\" etc."},
                {"name": "updateTarget", "type": "string", "desc": "optional, The  acceptable values are\n<ul>\n<li>(not specified), it means update both view and model</li>\n<li><code>model</code>, it means update model only</li>\n<li><code>view</code>, it means update view only</li>\n</ul>"},
                {"name": "adapterName", "type": "string", "desc": "optional, default value is empty, which means let Hm.js automatic pick a value adapter for you. Specify it, if you know the adapter name."}
            ]}
        ], "examples": []}
    ]},
    {"name": "bulit-in bindings", "namespace": "", "shortDesc": "build-in bindings", "longDesc": "<p>Hm.js includes lots small, handy subscription behavior.  A lot of them use a workflow type of the same name of the subscription behavior. You can use these workflow types of with other event names. Here a list of them.\n</p>\n\n<table>\n <tr>\n    <td>binding name</td>\n    <td>definition</td>\n    <td>functions</td>\n<tr>\n <tr>\n <tr>\n    <td>html</td>\n    <td class=\"code\">!init after*:.|get html *toString</td>\n  <td>change the html of element initially and when model change</td>\n</tr>\n <tr>\n    <td>text</td>\n    <td class=\"code\">!init after*:.|get text *toString</td>\n  <td>change the text of element initially and when model change.</td>\n</tr>\n    <td>options</td>\n    <td class=\"code\">!init after*:.|*options</td>\n    <td>populate option list of select element initially and after model change</td>\n<tr>\n <tr>\n    <td>caption</td>\n    <td class=\"code\">dynamic group</td>\n  <td>specify the first option of select element initially and after model change</td>\n</tr>\n <tr>\n    <td>show</td>\n    <td class=\"code\">!init after*:.|*show</td>\n    <td>show an element initially and after model change</td>\n</tr>\n </tr>\n    <td>hide</td>\n    <td class=\"code\">!init after*:.|*hide</td>\n    <td>hide an element initially and after model change</td>\n</tr>\n <tr>\n    <td>enable</td>\n    <td class=\"code\">!init after*:.|*enable</td>\n  <td>enable an element initially and after model change</td>\n</tr>\n<tr>\n    <td>enableLater</td>\n    <td class=\"code\">!after*:.|*enable</td>\n  <td>enable an element after model change</td>\n</tr>\n <tr>\n    <td>disable</td>\n    <td class=\"code\">!init after*:.|*disable</td>\n  <td>disable an elmenet</td>\n</tr>\n<tr>\n    <td>disableLater</td>\n    <td class=\"code\">!after*:.|*disable</td>\n  <td>disable an element after model change</td>\n</tr>\n <tr>\n    <td>addClass</td>\n    <td class=\"code\">!init after*:.|*addClass</td>\n  <td>add a class to an element initially and after model change</td>\n</tr>\n <tr>\n    <td>removeClass</td>\n    <td class=\"code\">!init after*:.|*removeClass</td>\n  <td>remove a class to an element initially and after model change</td>\n</tr>\n <tr>\n    <td>focus</td>\n    <td class=\"code\">!init after*:.|*focus</td>\n  <td>focus on an element initially and after model change</td>\n</tr>\n <tr>\n    <td>count</td>\n    <td class=\"code\">!init after*:.|*count</td>\n  <td>show the length of an array node initially and after model change</td>\n</tr>\n <tr>\n    <td>dump</td>\n    <td class=\"code\">!init *:.|*dump</td>\n  <td>print the value of a model initially and after model change</td>\n</tr>\n <tr>\n    <td>alert</td>\n    <td class=\"code\">$click:.|*alert</td>\n  <td>alert a message when click</td>\n</tr>\n <tr>\n    <td>preventDefault</td>\n    <td class=\"code\">$click:_|*preventDefault</td>\n  <td>prevent default action when click</td>\n</tr>\n <tr>\n    <td>confirm</td>\n    <td class=\"code\">$click:.|*confirm</td>\n  <td>alert a confirm message box when click</td>\n</tr>\n <tr>\n    <td>setTo</td>\n    <td class=\"code\">$click:.|*setTo</td>\n  <td>set model to a fixed value when click</td>\n</tr>\n<tr>\n    <td>0</td>\n    <td class=\"code\">$click:.|*0</td>\n  <td>set model to 0 when click</td>\n</tr>\n <tr>\n    <td>null</td>\n    <td class=\"code\">$click:.|*null</td>\n  <td>set model to null when click</td>\n</tr>\n <tr>\n    <td>true</td>\n    <td class=\"code\">$click:.|*true</td>\n  <td>set model to true when click</td>\n</tr>\n <tr>\n    <td>false</td>\n    <td class=\"code\">$click:.|*false</td>\n  <td>set a model to false when click</td>\n</tr>\n <tr>\n    <td>toggle</td>\n    <td class=\"code\">$click:.|*toggle</td>\n  <td>flip a model value when click</td>\n</tr>\n <tr>\n    <td>++</td>\n    <td class=\"code\">$click:.|*++</td>\n  <td>increment a model when click</td>\n</tr>\n <tr>\n    <td>--</td>\n    <td class=\"code\">$click:.|*--</td>\n  <td>decrement a model when click</td>\n</tr>\n\n\n <tr>\n    <td>sort</td>\n    <td class=\"code\">$click:.|*sort</td>\n  <td>sort a value when click</td>\n</tr>\n <tr>\n    <td>clear</td>\n    <td class=\"code\">$click:.|*clear</td>\n  <td>clear the items of array when click</td>\n</tr>\n\n <tr>\n    <td>autofocus</td>\n    <td class=\"code\">dynamic group</td>\n  <td>auto-focus an element when load</td>\n</tr>\n <tr>\n    <td>mapEvent</td>\n    <td class=\"code\">dynamic group</td>\n  <td>raise a new event when an event triggered to an element</td>\n</tr>\n <tr>\n    <td>logPanel</td>\n    <td class=\"code\">dynamic group</td>\n  <td>show the message that hm.log() output</td>\n</tr>\n <tr>\n    <td>clearlog</td>\n    <td class=\"code\">clear:/*log</td>\n  <td>clear the items of *log model</td>\n</tr>\n\n <tr>\n    <td>cacheable</td>\n    <td class=\"code\">dynamic group</td>\n  <td>cache a model initially and after it change</td>\n</tr>\n</table>", "signatures": []},
    {"name": "html/text", "namespace": "bulit-in bindings", "shortDesc": "html/text", "longDesc": "<p>The definition of \"html\" binding is <code>!init after*:.|get html *toString</code>. It can use model's value to update element's html content initially and when model change.  The definition of \"text\" binding is <code>!init after*:.|get text *toString</code>. It can use model's value to update element's text initially and when model change. \n</p>", "signatures": []},
    {"name": "options", "namespace": "bulit-in bindings", "shortDesc": "options", "longDesc": "<p>You can use binding \"options\" to build a option list of a \"select\" element. The option list also can respond to the change of model.  Here is the syntax:\n</p>\n\n<pre prettyprint>\noptions=\"path[|textProperty,[idProperty]]\"\n//for example\noptions=\"path\"\noptions=\"path|name\"\noptions=\"path|name,id\"\n</pre>\n\n<h3>Example</h3>\n\n<pre prettyprint preview=\"_|http://jsbin.com/uYupUyOq/2\">\n\n&lt;h2&gt;string array as data source of option list&lt;/h2&gt;\n  &lt;select val=\"selectedFruit\" options=\"fruit\" caption=\"_\" debug&gt;&lt;/select&gt;\n  \n  &lt;button clear=\"fruit\"&gt;clear lookup&lt;/button&gt;\n  \n  &lt;button $click=\"addFruit\"&gt;add lookup fruit&lt;/button&gt;\n    \n    &lt;hr /&gt;\n    &lt;h2&gt;object array as data source of option list&lt;/h2&gt;\n    \n    &lt;select options=\"products|name,id\" caption=\"_\" val=\"selectedProduct\" debug&gt;&lt;/select&gt;\n    \n    &lt;button clear=\"products\"&gt;clear lookup&lt;/button&gt;\n  \n   &lt;button $click=\"addProducts\"&gt;add lookup product&lt;/button&gt;\n</pre>\n\n<pre prettyprint>\n(function () {\n\n  \n  hm(\"demo\", {       \n    fruit: [ \"apple\", \"orange\", \"banana\"],    \n    addFruit: function (e) {    \n      e.subscriber.cd(\"..fruit\").push(\"fruit \" + (++fruitCount) );           \n    },    \n    fruitCaption: \"\",    \n    products: [    \n      { id: \"p1001\", name: \"keyboard\" },      \n      { id: \"p1002\", name: \"mouse\" },      \n      { id: \"p1003\", name: \"Camera\" }      \n    ],    \n    selectedProduct: null,    \n    addProducts: function (e) {    \n          var id = productId++\n      e.subscriber.cd(\"..products\").push(      \n        {id: (\"p\" + id ), name: \"product \" + id }        \n      );       \n    }    \n  });\n  \n  var fruitCount = 3;\n  var productId = 1004;\n \n})();\n</pre>", "signatures": []},
    {"name": "caption", "namespace": "bulit-in bindings", "shortDesc": "caption", "longDesc": "<p>\nThis binding add a item to the top of option list of \"select\" element as caption.  The syntax is as following.\n</p>\n\n<pre prettyprint>\n&lt;!-- add a blank item to the list--&gt;\n//the path is \"_\", meaning there is no subscriber.\n&lt;select caption=\"_\" &gt; \n\n&lt;!-- add a item with text \"here is the caption\" to the list !--&gt;\n&lt;select caption=\"_|here is the caption\" &gt; \n\n&lt;!-- add an item with text define in modelPath --&gt;\n&lt;select caption=\"modelPath\"&gt; \n</pre>\n\n<h3>Example</h3>\n\n<pre prettyprint preview=\"_|http://jsbin.com/qosac/1\">\n\n&lt;select val=\"selectedFruit\" options=\"fruit\" caption=\"_\"&gt;&lt;/select&gt;    \n&lt;select val=\"selectedFruit\" options=\"fruit\" caption=\"_|--fruit--\"&gt;&lt;/select&gt;    \n&lt;select val=\"selectedFruit\" options=\"fruit\" caption=\"fruitCaption\"&gt;&lt;/select&gt;\n</pre>\n\n<pre prettyprint>\n hm(\"demo\", {       \n    fruit: [ \"apple\", \"orange\", \"banana\"],    \n    addFruit: function (e) {    \n      e.subscriber.cd(\"..fruit\").push(\"fruit \" + (++fruitCount) );           \n    },    \n    fruitCaption: \"-----\",    \n    selectedFruit: null\n\n  });\n</pre>", "signatures": []},
    {"name": "show/hide", "namespace": "bulit-in bindings", "shortDesc": "show/hide", "longDesc": "<p>The \"show\" subscription group and workflow type will show the element when model value is truthy, otherwise hide the element.  The model value can be a simple value like string, integer, or it can be a function, in this case the value of function call is evaluated. You can also add an options to create an expression, when the expression is true, show the element, otherwise hide the element. The \"hide\" counterpart will do the opposite. The following is the syntax.\n<p>\n\n<pre prettyprint>\n//\nshow=\"path\"\nshow=\"path|value\"\nshow=\"path|expression \"\n//\nhide=\"path\"\nhide=\"path|value\"\nhide=\"path|expression\"\n</pre>\n\n<h3>Example</h3>\n\n<pre prettyprint preview=\"_|http://jsbin.com/ajeziTA/2\">\n&lt;body&gt;\n  &lt;div ns=\"demo\"&gt;       \n    &lt;h4&gt;simple model, no expression&lt;/h4&gt;\n    &lt;div&gt;\n      &lt;button show=\"visible\" false=\"visible\"&gt;hide&lt;/button&gt;\n      &lt;button hide=\"visible\" true=\"visible\"&gt;show&lt;/button&gt; &lt;span data-sub=\"show:visible\"&gt;Hello world&lt;/span&gt;\n    &lt;/div&gt;\n    \n    &lt;table&gt;\n      &lt;col style=\"width:300px\"&gt;\n        &lt;tr&gt;\n          &lt;td&gt;\n            &lt;h4&gt;\"equal\" expression&lt;/h4&gt;\n            &lt;div show=\"selectedNumber|1\"&gt;number 1&lt;/div&gt;\n            &lt;div show=\"selectedNumber|2\"&gt;number 2&lt;/div&gt;\n            &lt;div show=\"selectedNumber|3\"&gt;number 3&lt;/div&gt;\n            &lt;div show=\"selectedNumber|4\"&gt;number 4&lt;/div&gt;\n            &lt;div show=\"selectedNumber|5\"&gt;number 5&lt;/div&gt; \n            &lt;h4&gt;complex expression&lt;/h4&gt;\n            &lt;div show=\"selectedNumber|&gt;3\"&gt;you can see this because the number is over 3&lt;/div&gt; \n            &lt;h4&gt;function model&lt;/h4&gt;\n            &lt;div show=\"tooBig\"&gt;you can see this because the number is too big&lt;/div&gt;\n          &lt;/td&gt;\n          &lt;td&gt;\n            &lt;select caption=\"_|--number--\" val=\"selectedNumber\" options=\"numbers\"&gt;&lt;/select&gt;\n          &lt;/td&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n  &lt;hr&gt;\n  &lt;div dump=\"demo\"&gt;&lt;/div&gt;\n  &lt;div log-panel&gt;&lt;/div&gt;\n&lt;/body&gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_\">\n hm(\"demo\", {\n    visible: true,\n    selectedNumber: \"\",\n    numbers: [1, 2, 3, 4, 5],\n    tooBig: function () {\n     return this.get(\"selectedNumber\") > 4; \n    }\n  });\n</pre>", "signatures": []},
    {"name": "enable/disable", "namespace": "bulit-in bindings", "shortDesc": "enable/disable", "longDesc": "<p>The \"enable\" subscription group and workflow type will enable the element when model value is truthy, otherwise disable the element.  The model value can be a simple value like string, integer, or it can be a function, in this case the value of function call is evaluated. You can also add an options to create an expression, when the expression is true, enable the element, otherwise hide the element. The \"disable\" counterpart will do the opposite. The following is the syntax.\n<p>\n\n<pre data-sub=\"prettyprint:_\">\n//\nenable=\"path\"\nenable=\"path|value\"\nenable=\"path|expression\"\n//\ndisable=\"path\"\ndisable=\"path|value\"\ndisable=\"path|expression\"\n</pre>\n\n<pre prettyprint preview=\"_|http://jsbin.com/IXaGItIP/2\">\n&lt;body&gt;\n  &lt;div data-sub=\"ns:demo\"&gt;\n    &lt;h3&gt;no expression&lt;/h3&gt;\n    &lt;button enable=\"done\" false=\"done\" debug&gt;start&lt;/button&gt;\n    &lt;button disable=\"done\" true=\"done\" debug&gt;stop&lt;/button&gt;\n    \"done\": &lt;span text=\"done\"&gt;&lt;/span&gt;\n    \n    &lt;h3&gt;expression&lt;/h3&gt;\n    &lt;button enable=\"count|&lt;5\" ++=\"count\" debug&gt;up&lt;/button&gt;\n    &lt;button disable=\"count|0\" --=\"count\" debug&gt;down&lt;/button&gt;\n    \"count\": &lt;span text=\"count\"&gt;&lt;/span&gt;\n  &lt;/div&gt;\n  &lt;div log-panel&gt;&lt;/div&gt;  \n&lt;/body&gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_\">\nhm(\"demo\", {\n    done: true,\n    count: 3  \n  });\n</pre>", "signatures": []},
    {"name": "addClass/removeClass", "namespace": "bulit-in bindings", "shortDesc": "addClass/removeClass", "longDesc": "<p>The \"addClass\" subscription group and workflow type will add a CSS class to the element when model value is truthy, otherwise remove the class from the element.  The model value can be a simple value like string, integer, or it can be a function, in this case the value of function call is evaluated. You can also add an options to create an expression, when the expression is true, add the class to the element, otherwise remove the class from the element. The \"remove\" counterpart will do the opposite. The following is the syntax.\n<p>\n\n<pre data-sub=\"prettyprint:_\">\n//\naddClass=\"path|className\"\naddClass=\"path|className,value\"\naddClass=\"path|className,expression\"\n//\nremoveClass=\"path|className\"\nremoveClass=\"path|className,value\"\nremoveClass=\"path|className,expression\"\n</pre>\n\n\n<pre prettyprint preview=\"_|http://jsbin.com/oVirale/2\">\n&lt;body&gt;\n  &lt;div ns=\"demo\"&gt;\n    \n    &lt;h3&gt;no expression&lt;/h3&gt;\n    \n    &lt;button enable=\"done\" false=\"done\"&gt;start&lt;/button&gt;\n    &lt;button disable=\"done\" true=\"done\"&gt;stop&lt;/button&gt;\n    \"done\": &lt;span text=\"done\"&gt;&lt;/span&gt; \n    &lt;span remove-class=\"done|pending\" debug=\"_\"&gt;&lt;/span&gt;\n    \n    \n    &lt;h3&gt;expression&lt;/h3&gt;\n    &lt;div add-class=\"temperature|hot,&gt;23\" debug&gt;    \n      &lt;button ++=\"temperature\"&gt;up&lt;/button&gt;\n      &lt;button --=\"temperature\"&gt;down&lt;/button&gt;\n      &lt;span&gt;\"temperature\": &lt;span text=\"temperature\"&gt;&lt;/span&gt;      \n    &lt;/div&gt;\n      \n  &lt;/div&gt;\n  &lt;div log-panel&gt;&lt;/div&gt;\n&lt;/body&gt;\n</pre>\n\n<pre prettyprint>\n hm(\"demo\", {\n    done: true,\n    temperature: 23  \n  });\n</pre>", "signatures": []},
    {"name": "count", "namespace": "bulit-in bindings", "shortDesc": "count", "longDesc": "<p>The \"count\" subscription group can update the length of array node.</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/obayes/3\">\n&lt;body&gt;\n  &lt;div ns=\"demo\"&gt;\n    &lt;button $click=\"addItems\"&gt;add items&lt;/button&gt;\n    You have &lt;span count=\"items\"&gt;&lt;/span&gt; item&lt;span show=\"plural\"&gt;s&lt;/span&gt;\n    &lt;div dump=\"items\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div log-panel&gt;&lt;/div&gt;\n&lt;/body&gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_\">\n var i = 1;\n  hm(\"demo\", {\n    items: [],\n    addItems: function (e) {\n      e.subscriber.cd(\"..items\").push(i++);\n    },\n    plural: function() {\n      return this.get(\"items\").length > 1; \n    }\n  });\n</pre>", "signatures": []},
    {"name": "focus", "namespace": "bulit-in bindings", "shortDesc": "focus", "longDesc": "<p>\n\"focus\" is an subscription group which will focus on an element when the model is truthy or an expression is evaluated to by truthy. The syntax is as follow:\n</p>\n<pre prettyprint>\n//\nfocus=\"path\"\nfocus=\"path|value\"\nfocus=\"path|expression\"\n</pre>\n<p>\nThe following shows an text box auto focus itself, when model change to true.\n</p>\n<pre prettyprint preview=\"_|http://jsbin.com/UyEPAZo/2\">\n&lt;div ns=\"demo\"&gt;\n  &lt;div hide=\"editMode\"&gt;\n    &lt;button true=\"editMode\"&gt;switch to edit mode&lt;/button&gt;\n    &lt;div html=\"article\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  \n  &lt;div show=\"editMode\"&gt;\n    &lt;textarea rows=\"10\" cols=\"50\" val=\"article\" focus=\"editMode\" debug&gt;&lt;/textarea&gt;\n    &lt;br /&gt;\n    &lt;button false=\"editMode\"&gt;Done&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;div log-panel&gt;&lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "click related bindings", "namespace": "bulit-in bindings", "shortDesc": "click related bindings", "longDesc": "<p>Hm.js has a few subscription behavior and workflow types for view event \"click\".  All these subscription behavior use the same name of their workflow type. For example,  subscription group <code>null</code> is defined as <code>$click:.|*null</code></p>\n</p>\n\n<table>\n<tr>\n<td>name</td>\n<td>side effect</td>\n<td>syntax</td>\n</tr>\n\n<tr>\n<td>alert</td>\n<td>alert a message</td>\n<td class=\"code\">alert=\"path\"\n<br>\nalert=\"_|message\"\n</td>\n</tr>\n\n<tr>\n<td>confirm</td>\n<td>confirm with a message</td>\n<td class=\"code\">\nconfirm=\"path\"\n<br>\nconfirm=\"_\"\n<br>\nconfirm=\"_|message\"\n</td>\n</tr>\n\n<tr>\n<td>null</td>\n<td>set model to null</td>\n<td class=\"code\">null=\"path\"</td>\n</tr>\n\n<tr>\n<td>setTo</td>\n<td>set a fixed value to model</td>\n<td class=\"code\">set-to=\"path|fixedValue\"</td>\n</tr>\n<tr>\n<td>true</td>\n<td>set model to true</td>\n<td class=\"code\">true=\"path\"</td>\n</tr>\n\n<tr>\n<td>false</td>\n<td>set model to false</td>\n<td class=\"code\">false=\"path\"</td>\n</tr>\n<tr>\n<td>toggle</td>\n<td>flip model's value</td>\n<td class=\"code\">toggle=\"path\"</td>\n</tr>\n\n\n<tr>\n<td>++</td>\n<td>increment model by 1</td>\n<td class=\"code\">++=\"path\"</td>\n</tr>\n<tr>\n<td>--</td>\n<td>decrement model by 1</td>\n<td class=\"code\">--=\"path\"</td>\n</tr>\n\n<tr>\n<td>sort</td>\n<td>set model</td>\n<td class=\"code\">sort=\"path\"  <br> sort=\"path|colName\"  <br> sort=\"path|colName,false\"\n</td>\n</tr>\n\n<tr>\n<td>clear</td>\n<td>clear all items of model</td>\n<td  class=\"code\">clear=\"path\"</td>\n</tr>\n</table>\n\n<h3>Examples</h3>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/ejefor/6\">\n&lt;table ns=\"demo\"&gt;\n &lt;tr&gt;\n   &lt;td&gt;group/workflow name&lt;/td&gt;\n   &lt;td&gt;action&lt;/td&gt;\n   &lt;td&gt;side effect&lt;/td&gt;\n &lt;/tr&gt;\n \n &lt;tr&gt;\n   &lt;td&gt;alert&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button alert=\"message\"&gt;alert&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td dump=\"message\"&gt;&lt;/td&gt;\n &lt;/tr&gt;\n \n  &lt;tr&gt;\n   &lt;td&gt;confirm&lt;/td&gt;\n   &lt;td&gt;\n     &lt;a href=\"http://google.com\" confirm=\"confirm\" &gt;confirm&lt;/a&gt;\n     \n   &lt;/td&gt;\n   &lt;td dump=\"confirm\"&gt;&lt;/td&gt;\n &lt;/tr&gt;\n \n   &lt;tr&gt;\n   &lt;td&gt;prevent-default&lt;/td&gt;\n   &lt;td&gt;\n     &lt;a href=\"http://google.com\" prevent-default&gt;prevent-default&lt;/a&gt;\n     \n   &lt;/td&gt;\n   &lt;td&gt;&lt;/td&gt;\n &lt;/tr&gt;\n \n &lt;tr&gt;\n   &lt;td&gt;null&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button null=\"message\"&gt;set null&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td dump=\"message\"&gt;&lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;setTo&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button set-to=\"message|hello\"&gt;set-to 'hello'&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td dump=\"message\"&gt;&lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;true&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button true=\"boolean\"&gt;set true&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"boolean\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;false&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button false=\"boolean\"&gt;set false&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"boolean\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;toggle&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button toggle=\"boolean\"&gt;toogle&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"boolean\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;++&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button ++=\"count\"&gt;++&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"count\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;--&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button --=\"count\"&gt;--&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"count\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;sort&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button sort-items=\"numbers\"&gt;sort number&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"numbers\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;sort&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button sort-items=\"objects|id\"&gt;sort objects&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"objects\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n &lt;tr&gt;\n   &lt;td&gt;clear&lt;/td&gt;\n   &lt;td&gt;\n     &lt;button clear=\"items\"&gt;clear&lt;/button&gt;\n   &lt;/td&gt;\n   &lt;td&gt;&lt;span dump=\"items\"&gt;&lt;/span&gt;\n   &lt;/td&gt;\n &lt;/tr&gt;\n&lt;/table&gt;\n</pre>", "signatures": []},
    {"name": "autofocus", "namespace": "bulit-in bindings", "shortDesc": "autofocus", "longDesc": "<p>This a dynamic group, it does not create any subscription. However, it make the element focus after page load.\n</p>\n\n<h3>Example</h3>\n\n<pre prettyprint preview=\"_|http://jsbin.com/oqamor/3\">\n\n\n    &lt;input type=\"text\" autofocus &gt;\n</pre>", "signatures": []},
    {"name": "mapEvent", "namespace": "bulit-in bindings", "shortDesc": "mapEvent, mapClick", "longDesc": "<p>When an event trigger to an element, you can use binding <code>mapEvent</code> to the event into another event, and trigger it to the element. The syntax is as following:\n</p>\n\n<pre data-sub=\"prettyprint:_;\">\nmap-event=\"_|originalEvent,newEvent\"\n//e.g\nmap-event=\"_|click,delete\"\n</pre>\n\n<p>\n\"mapClick\" is short-cut of mapEvent, you can use <code>map-click=\"_|delete</code> for <code>map-event=\"_|click,delete\"</code>\n</p>\n\n<p>This subscription group create an binding to the original event, when the original event trigger, trigger the new event to the element. This useful for certain case. For example, you have lots of elements which generate \"click\" event, and you want to listen to these event, instead of binding handler to all these elements, you bind handler to their parent, however,  you only need use different logic for different kind of elements. So your handler will be have lots of switch or if/else. The following shows how to use mapEvent subscription group to solve this problem.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/meheq/1\">\n  &lt;div ns=\"demo\"\n      $delete=\"processDelete\"\n      $edit=\"processEdit\"\n      $cancel=\"processCancel\"&gt;       \n    &lt;button map-event=\"_|dblclick,edit\"&gt;double click to edit&lt;/button&gt;      \n    &lt;button map-click=\"_|cancel\"&gt;click to cancel&lt;/button&gt;      \n    &lt;button map-event=\"_|ctrlclick,delete\"&gt;ctrl+ click to delete&lt;/button&gt;  \n  &lt;/div&gt;\n  \n  &lt;div log-panel&gt;&lt;/div&gt;\n</pre>\n\n<pre prettyprint>\nhm(\"demo\", {\n  processDelete: function (e) {\n    hm.log(\"process delete\");\n  },\n  processEdit: function (e) {\n    hm.log(\"process edit\");\n  },\n  processCancel: function (e) {\n    hm.log(\"process cancel\");\n  }\n});\n</pre>\n", "signatures": []},
    {"name": "cacheable", "namespace": "Node.LocalStorage", "shortDesc": "node.cacheable([subPath])", "longDesc": "", "signatures": [
        {"name": "node.cacheable(subPath)", "returns": "hm", "shortDesc": "", "desc": "automatic cache the node value when the node is changed", "overloads": [
            {"versionAdded": "0.1", "name": "node.cacheable([subPath])", "parameters": [
                {"name": "subPath", "type": "string", "desc": "optional, sub-path relative to the current node"}
            ]}
        ], "examples": []}
    ]},
    {"name": "listView", "namespace": "bulit-in bindings", "shortDesc": "listView", "longDesc": "<p>You can use binding <code>listView</code> to display array model in a list just like binding <code>tmplOnchange</code>, <code>tmplOnChildChange</code>, <code>tmplOnAnychange</code>. Moreover, <code>listView</code> is more efficient in that it can update only the view row which map to the changed model row.\n</p>\n\n<h3>Example</h3>\n<p>In the following example shows, clicking the button will manipulate the items in an array node, the list view can update the effected rows effected, while other row remain unchange.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/gegec/1\">\n&lt;div ns=\"demo\"&gt;\n      \n    &lt;button $click=\"updateFirstContact\"&gt;update first contact&lt;/button&gt;\n    &lt;button $click=\"moveRow\"&gt;move row 2 to 3&lt;/button&gt;\n    &lt;br&gt;\n    &lt;button $click=\"addNewContact\"&gt;add new contact&lt;/button&gt;\n    &lt;button $click=\"removeLastContact\"&gt;remove last contact&lt;/button&gt;\n     \n    &lt;h3&gt;list view&lt;/h3&gt;\n    &lt;table &gt;\n        &lt;tr&gt;\n          &lt;th&gt;First Name&lt;/th&gt;\n          &lt;th&gt;Last Name&lt;/th&gt;\n          &lt;th&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;tbody list-view=\"contacts|contact\"&gt;\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n  \n    &lt;div dump=\"contacts\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_\">\n var i = 1;\n \n  var model = hm(\"demo\", {\n    contacts: [\n      { firstName: \"Jane\", lastName: \"Poe\"},\n      { firstName: \"Robert\", lastName: \"Roe\"},\n      { firstName: \"Brett\", lastName: \"Boe\"},\n      { firstName: \"Carla\", lastName: \"Coe\"},\n      { firstName: \"Donna\", lastName: \"Doe\"},\n      { firstName: \"Juan\", lastName: \"Doe\"}\n      ],\n    updateFirstContact: function (e) {\n      i++;\n      model.cd(\"contacts\").update(0, {\n        firstName: \"Jane\" + i, lastName: \"Poe\" + i\n      });\n     \n    },\n     addNewContact: function (e) {\n        i++;\n        model.cd(\"contacts\").push({\n          firstName: \"firstName\" + i, lastName : \"lastName\" + i\n          \n        });\n        \n      },\n    removeLastContact: function (e) {\n     model.cd(\"contacts\").pop();\n    \n    },\n    moveRow: function (e) {\n      model.cd(\"contacts\").move(1, 2);\n    }\n  \n  });\n  hm(\"*ts\", true);\n</pre>\n<h3>listView binding details</h3>\n<table>\n<tr><th>binding syntax</th><th  class=\"code\">list-view=\"pathOfArray|idOfRowTemplate\"</th></tr>\n<tr><td>subscription</td><td>description</td></tr>\n<tr>\n<td  class=\"code\">renderTmplOnNodeChange:.</td>\n<td>render all the rows initially and after the Array node is set</td></tr>\n<tr>\n<td  class=\"code\">!afterCreate.1:.|*addRowView</td>\n<td>add a new row when an new item is added to the array</td>\n</tr>\n<tr>\n<td  class=\"code\">!afterUpdate.1:.|*updateRowView</td>\n<td>update the row when an item in the array is updated</td>\n</tr>\n<tr>\n<td  class=\"code\">!afterDel.1:.|*removeRowView</td>\n<td>remove the row when an item is remove from array</td>\n</tr>\n</table>", "signatures": []},
    {"name": "queryView", "namespace": "bulit-in bindings", "shortDesc": "queryView", "longDesc": "<p>Binding queryView allows you to do simple query on an array model and display the query result in a list. Moreover, the result list view can be updated when the underlying data is updated. However, the result list must be re-rendered completely. Hm.js also include a few related bindings to that allow you do queries like  sorting, reset sorting, filtering, reset filtering, paging, reset paging, and reset all query. All these are optional.\n</p>\n\n<h3>Example</h3>\n<p>\nThe following is refactory of the example in list view. The model is identical, the difference is the mark-up. This example compare the list view which bind to the model array, while the query view bind the query result of model array.\n</p>\n<pre prettyprint preview=\"_|http://jsbin.com/zohan/1\">\n\n &lt;div class=\"demo\" ns=\"demo\"&gt;\n    &lt;button $click=\"updateFirstContact\"&gt;update first contact&lt;/button&gt;\n    &lt;button $click=\"moveRow\"&gt;move row 2 to 3&lt;/button&gt;\n    &lt;br&gt;\n    &lt;button $click=\"addNewContact\"&gt;add new contact&lt;/button&gt;\n    &lt;button $click=\"removeLastContact\"&gt;remove last contact&lt;/button&gt;\n    \n     &lt;h3&gt;query view (bind to query of model)&lt;/h3&gt;\n\n    &lt;div ns=\"contacts\" enable-query=\".\"&gt;\n      &lt;p&gt;search :\n        &lt;select val=\"*query.filter.by\"&gt;\n          &lt;option value=\"\"&gt;All&lt;/option&gt;\n          &lt;option value=\"firstName\"&gt;First Name&lt;/option&gt;\n          &lt;option value=\"lastName\"&gt;Last Name&lt;/option&gt;\n        &lt;/select&gt;\n        \n        &lt;select val=\"*query.filter.ops\"&gt;\n          &lt;option value=\"\"&gt;contains&lt;/option&gt;\n          &lt;option value=\"equals\"&gt;equals&lt;/option&gt;\n        &lt;/select&gt;\n        \n        &lt;input type=\"text\" placeholder=\"enter to search\" search-box=\".\" &gt;        \n        &lt;input value=\"Reset Search\" type=\"button\" reset-search=\".\" &gt;\n\n      &lt;/p&gt;\n      \n      &lt;table show-found=\".\"&gt;\n        &lt;tr&gt;\n          &lt;th sort-query=\".|firstName\" title=\"sort by first name\"&gt;First Lame&lt;/th&gt;\n          &lt;th sort-query=\".|lastName\" title=\"sort by last name\"&gt;Last Name&lt;/th&gt;\n          &lt;th&gt;\n            &lt;input value=\"reset sort\" type=\"button\" reset-sort=\".\" /&gt;\n          &lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tbody query-view=\".|contact\"&gt;&lt;/tbody&gt;\n        &lt;tfoot pager=\".|pagerTemplate\"&gt;&lt;/tfoot&gt;\n      &lt;/table&gt;\n      &lt;p hide-found=\".\"&gt;No result found&lt;/p&gt;\n      &lt;p&gt;\n        &lt;input value=\"reset all\" type=\"button\" reset-query=\".\" /&gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n         &lt;h3&gt;list view (bind to model)&lt;/h3&gt;\n\n    &lt;table&gt;\n        &lt;tr&gt;\n          &lt;th&gt;First Name&lt;/th&gt;\n          &lt;th&gt;Last Name&lt;/th&gt;\n          &lt;th&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;tbody list-view=\"contacts|contact\"&gt;&lt;/tbody&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n  &lt;hr&gt;\n  &lt;div dump=\"demo.contacts\"&gt;&lt;/div&gt;\n</pre>\n\n<h3>queryView syntax</h3>\n\n<p>\nTo use the queryView, the first step is to initialize the query feature like the following.\n</p>\n<pre prettyprint>\nhm( pathOfArray).enableQuery();\n</pre>\n\n<p>Internally it will create an query object  in the shadow node of the array, like the following. This object  interact with views to achieve the functions such as paging, sorting, filtering.\n</p>\n<pre prettyprint>\nhm(\"pathOfArray*\").extend({\npager: {\n enabled: false,\n index: 0, //nth page\n count: 1,\n size: 0\n},\n sort:  {\n  by: null, //currently we only support sort by one column sort\n  asc: null\n },\nfilter: {\n by: \"\",\n value: \"\",\n ops: \"\",\n enabled: false\n},\n//is query enabled\n enabled: function() {\n  return this.get( \"pager.enabled\" ) || this.get( \"sort.by\" ) || this.get( \"filter.enabled\" );\n}\n}); \n</pre>\n\n<p>\nThe following are a quick reference to the bindings used in the samples. It shows the subscriptions created in each each binding\n</p>\n\n<table class=\"group\">\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">query-view=\"pathOfArray\" </th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">tmpl-on-any-change:*queryResult</td>\n\t\t<td>render all the rows in query result initially and after any change of the array which\n\t\t\tquery is against\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">sort=\"pathOfArray|propertyName\" (e.g sort=\"items|firstName\")</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click=\"*query.sort.by|*setTo\"</td>\n\t\t<td>change node at items*query.sort.by to the option value(firstName)</td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">$click:*query.sort.asc|*toggle</td>\n\t\t<td>flip the value of node at items*query.sort.asc</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click:*refreshQuery</td>\n\t\t<td>trigger \"afterUpdate\" event to \"items*queryResult\" node</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">resetSort:pathOfArray(e.g resetSort:items)</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click:*resetSort</td>\n\t\t<td>call resetSort handler when view is click, which change the\n\t\t\t<code>sort.by</code>,\n\t\t\t<code>sort.asc</code>.\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">show:*query.sort.by</td>\n\t\t<td>show the view when it is <code>sort.by</code> has value</td>\n\t</tr>\n\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">search:pathOfArray(e.g search:items)</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click:*refreshQuery</td>\n\t\t<td>trigger <code>afterUpdate</code> events to items*queryResult when view is clicked.</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">enable:*query.filter.enabled</td>\n\t\t<td>enable the view when <code>filter.enabled</code> is true, otherwise disable</td>\n\t</tr>\n\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">resetSearch:pathOfArray(e.g resetSearch:items)</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click:*resetSearch</td>\n\t\t<td>invoke resetSearch handler when view is click, it will reset the\n\t\t\t<code>query.filter</code></td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">show:*query.filter.enabled</td>\n\t\t<td>enable the view when <code>filter.enabled</code> is true, otherwise disable</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">resetQuery:pathOfArray(e.g resetQuery:items)</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$click:*resetQuery</td>\n\t\t<td>call resetQuery handler when view is click</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">show:*query.enabled</td>\n\t\t<td>show the view when <code>items*query.enabled</code> is true</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">searchBox:pathOfArray(e.g searchBox:items)</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">ns:*query.filter.value</td>\n\t\t<td>set the group ns to items*query.filter.value</td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">val:.|enter</td>\n\t\t<td>set the value of the textbox to the node when enter key is hit</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$esc:.|*null</td>\n\t\t<td>set null value to the node when esc key is hit</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">pager:pathOfArray|pagerTemplateId(e.g\n\t\t\tpager:items|pagerTemplateId)\n\t\t</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">renderTmplOnSubNodeChange:*query.pager</td>\n\t\t<td>render the pager initially and re-render after any part of\n\t\t\t<code>items*query.pager</code> is changed.\n\t\t</td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">show:*hasQueryResult|_</td>\n\t\t<td>show the pager view when query result is not empty, otherwise hide it.</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">$paging:*paging</td>\n\t\t<td>when paging event triggered, call the handler at items*paging, which will change\n\t\t\t<code>*pager.index</code>, and trigger the <code>afterUpdate</code> event to\n\t\t\t<code>items*queryResult</code>.\n\t\t</td>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">preventDefault:_</td>\n\t\t<td>prevent the view's default behavior when view is clicked</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">setPage:pathOfArray</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">true:*query.pager.enabled;</td>\n\t\t<td>when view is clicked, set <code>items*query.pager.enabled</code> to true</td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">enable:*query.pager.size</td>\n\t\t<td>enable the view when <code>items*query.pager.size not zero</code></td>\n\t</tr>\n\n\t<tr>\n\t\t<td class=\"code\">$click*refreshQuery</td>\n\t\t<td>trigger <code>afterUpdate</code> to items*queryResult.</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">page:|pageIndex</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">dynamic group</td>\n\t\t<td>set the page index to to \"items*pager.index to the pageIndex when view\n\t\t\tis clicked. the pageIndex can be a number, or \"next\", \"previous\", \"first\", \"last\".\n\t\t</td>\n\t</tr>\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">showFound</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">show*hasQueryResult</td>\n\t\t<td>show view when query result has record, otherwise hide the view</td>\n\t</tr>\n\n\n\t<tr>\n\t\t<th colspan=\"2\" class=\"code\">hideFound</th>\n\t</tr>\n\t<tr>\n\t\t<td class=\"code\">show*hasQueryResult</td>\n\t\t<td>hide view when query result has record, otherwise show the view</td>\n\t</tr>\n\n</table>\n", "signatures": []},
    {"name": "shadowEdit", "namespace": "bulit-in bindings", "shortDesc": "shadowEdit", "longDesc": "<p>When we edit a document, we actually edit on a copy of document,  the editing will not be immediately persisted until we save it, and we have the option to save the change or we discard the change. By applying the same concept, we can use \"shadowEdit\" binding to edit model. The copy here is called shadow.  shadowEdit support both non-array object (including primitive type, such as string, boolean) and array.\n</p>\n", "signatures": []},
    {"name": "tabs", "namespace": "bulit-in bindings", "shortDesc": "tabs", "longDesc": "<p>In the tab plugin, there are two kind of tab components, tab link, and tab view. While both of them can be selected, tab link can also change selection when it is being clicked. The tab binding is used to associated with the tab id with an model node. If a model value is the same as as tab component's tab id, the a \"selected\" class will be applied to it, otherwise the class will be removed. </p>\n<p>\nThe tab id of tab view is specified in <code>tab-view</code> attribute, the tab id of tab link is specified in <code>tab-link</code> attribute. You can use CSS to control the style of selected tab component and unselected ones like the following.</p>\n\n<pre prettyprint>\ndiv[tab-view] {\n  display: none;\n}\n\ndiv[tab-view].selected {\n display: block;\n}\n</pre>\n\n<p>Tab components can be stand-alone or  or nested in a tab container. When they are stand-alone, each of them has a tab binding. When they are nested in a tab container, they don't need to use tab binding, instead the tab container has use a binding <code>tabContainer</code>, which is more memory efficient.  You can standalone tab and tab container at the same time, which give you lots styling flexibility. The following is an example.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n&lt;!--standalone tabs--&gt;\n&lt;li tab-link=\"news\" tab=\"category\"&gt;News&lt;/li&gt;\n&lt;div tab-view=\"news\" tab=\"category\"&gt;contents&lt;/div&gt;\n\n&lt;!--tab container--&gt;\n&lt;ul tab-container:category\"&gt;\n  &lt;li tab-link=\"news\" &gt;News&lt;/li&gt;\n  &lt;div tab-view=\"news\" &gt;contents&lt;/div&gt;\n&lt;/ul&gt;\n</pre>\n\n<p>The class applied to tab link and tab view is by default <code>selected</code>,  the attribute of tab view is by default <code>tab-view</code> and the attribute of tab link is <code>tab-link</code> attribute, all this can be customized like following.</p>\n\n<pre prettyprint>\nhm.options.selectedClass = \"selected\";\nhm.options.tabViewAttr = \"tab-view\";\nhm.options.tabLinkAttr = \"tab-link\";\n</pre>\n\n<h3>tab</h3>\n<p>\nThis binding can be applied to be a tab link or tab view. It must be used with an element with <code>tab-link</code> or <code>tab-view</code> attribute like the following.\n</p>\n\n<pre prettyprint>\ntab=\"path[|selectedClass]\"\n\n&lt;li tab-link=\"news\" tab=\"category|active\"&gt;News&lt;/li&gt;\n &lt;div tab-view=\"news\" tab=\"category\"&gt;\n</pre>\n\n<h3>tab-container</h3>\n\n<p>This binding can be applied to tab container which contains elements with <code>tab-view</code> or <code>tab-link</code> attributes. The syntax is as following:\n</p>\n\n<pre prettyprint>\ntab-container=\"path[|selectedClass]\"\n\n&lt;div tab-container=\"category\"&gt;&lt;div&gt;\n&lt;div tab-container=\"category|active\"&gt;&lt;div&gt;\n</pre>\n\n<h3>Example</h3>\n\n<p>The following example use both standalone tab and tab container at the same time, and they are associated with a model node \"category\" </p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/humem/1\">\n&lt;div ns=\"demo\"&gt;\n  &lt;div&gt;\n     &lt;h3&gt;stand-alone tab links and tab views (each of them has its own subscriptions)&lt;/h3&gt;\n\n    &lt;ul&gt;\n      &lt;li tab-link=\"news\" tab=\"category\"&gt;News&lt;/li&gt;\n      &lt;li tab-link=\"opinion\" tab=\"category\"&gt;Opinion&lt;/li&gt;\n      &lt;li tab-link=\"sports\" tab=\"category\"&gt;Sports&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div tab-view=\"news\" tab=\"category\"&gt;\n      &lt;p&gt;News..&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div tab-view=\"opinion\" tab=\"category\"&gt;\n      &lt;p&gt;Opinion ..&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div tab-view=\"sports\" tab=\"category\"&gt;\n      &lt;p&gt;Sports ..&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n     &lt;h3&gt;tab container for tab links and tab views (only contaner has subscriptions)&lt;/h3&gt;\n\n    &lt;div tab-container=\"category\"&gt;\n      &lt;ul&gt;\n        &lt;li tab-link=\"news\"&gt;News&lt;/li&gt;\n        &lt;li tab-link=\"opinion\"&gt;Opinion&lt;/li&gt;\n        &lt;li tab-link=\"sports\"&gt;Sports&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;div  tab-view=\"news\"&gt;\n        &lt;p&gt;News..&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;div  tab-view=\"opinion\"&gt;\n        &lt;p&gt;Opinion...&lt;/p&gt;\n      &lt;/div&gt;\n      &lt;div tab-view=\"sports\"&gt;\n        &lt;p&gt;Sports ...&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</pre>\n\n<h3>nested tab containers</h3>\n\n<p>If a tab container contains another tab container, clicking the tab link in the parent tab container will change the tabs in the children container as well, just like this <a href=\"http://jsbin.com/uqovut/3/edit\">example</a>.  To fix the problem,  we need to apply a scope to the tab components within the a tab container, like the following example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/mohaw/1\">\n&lt;div tab-container=\"category|category\"&gt;\n  &lt;ul&gt;\n    &lt;li tab-link=\"news\" tab-container-name=\"category\"&gt;News&lt;/li&gt;\n    &lt;li tab-link=\"opinion\" tab-container-name=\"category\"&gt;Opinion&lt;/li&gt;\n    &lt;li tab-link=\"sports\" tab-container-name=\"category\"&gt;Sports&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;div tab-view=\"news\" tab-container-name=\"category\"&gt;\n    &lt;p&gt;News News News&lt;/p&gt;\n  &lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "for non-array", "namespace": "bulit-in bindings.shadowEdit", "shortDesc": "for non-array", "longDesc": "<h3>Shadow Edit on object</h3>\n\n<p>When we about  to shadow edit the object, the shadow of non-array object will be dynamically created. The shadow object is like the following.\n</p>\n\n<pre prettyprint>\nhm(\"objectPath*edit\", {\n  item: copyOfValue,\n  mode: function () {\n     //return \"read\" or \"update\"\n  }\n});\n</pre>\n\n<p>\nWhen display an object, we need a display template, when edit an object, we need a edit template.\nThe following example demo how to shadow edit an object.\n</p>\n\n<pre prettyprint  preview=\"_|http://jsbin.com/quweg/1\">\n  &lt;div ns=\"demo.contact\"&gt;  \n    &lt;div display-item-view=\".|displayContact\"&gt;&lt;/div&gt;  \n    &lt;div edit-item-view=\".|editContact\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  \n  &lt;div dump=\"demo.contact\"&gt;&lt;/div&gt;\n  &lt;div dump=\"demo.contact*edit\"&gt;&lt;/div&gt;\n\n&lt;script type=\"jsrender\" id=\"displayContact\"&gt;\n  &lt;p&gt;first name: {{:firstName}}&lt;/p&gt;\n  &lt;p&gt;last name: {{:lastName}}&lt;/p&gt;\n   &lt;button data-sub=\"editObject:.\"&gt;edit&lt;/button&gt;\n&lt;/script&gt;  \n  \n&lt;script type=\"text/template\" id=\"editContact\"&gt;\n &lt;div ns=\"*edit.item\"&gt;\n &lt;p&gt;\n &lt;input type=\"text\" class=\"firstName\" val=\"firstName\"/&gt;\n &lt;/p&gt;\n  &lt;p&gt;\n  &lt;input type=\"text\" class=\"lastName\" val=\"lastName\"/&gt;\n   &lt;/p&gt;\n &lt;p&gt;\n   &lt;input type=\"button\" value=\"Save\" save-edit=\".\" &gt;\n   &lt;input type=\"button\" value=\"Cancel\" cancel-edit=\".\" &gt;\n  &lt;/p&gt;\n&lt;/div&gt;\n&lt;/script&gt;\n </pre>\n<pre data-sub=\"prettyprint:_\">\n var model = hm(\"demo\", {\n    contact: { firstName: \"Jane\", lastName: \"Poe\"}\n  });\n</pre>\n\n<h3>Shadow Edit on primitive value</h3>\n<p>\nTo edit a primitive value such as string is similar, but just a bit simpler, since there is no need for a template like the following.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/jetug/1\">\n\n\n&lt;div ns=\"demo.name\"&gt;\n    &lt;span hide-on-edit=\".\" &gt;\n      &lt;span text=\".\"&gt;&lt;/span&gt;\n      &lt;button edit-object=\".\"&gt;edit&lt;/button&gt;\n    &lt;/span&gt;\n    &lt;span show-on-edit=\".\" &gt;\n      &lt;input type=\"text\" val=\"*edit.item\"&gt;\n      &lt;button save-edit=\".\"&gt;save&lt;/button&gt;\n      &lt;button cancel-edit=\".\"&gt;cancel&lt;/button&gt;\n    &lt;/span&gt;\n  &lt;/div&gt;\n\n&lt;script type=\"jsrender\" id=\"displayContact\"&gt;\n  &lt;p&gt;first name: {{:firstName}}&lt;/p&gt;\n  &lt;p&gt;last name: {{:lastName}}&lt;/p&gt;\n   &lt;button data-sub=\"editObject:.\"&gt;edit&lt;/button&gt;\n&lt;/script&gt;\n</pre>\n\n<pre data-sub=\"prettyprint:_\">\nvar model = hm(\"demo\", {\n    name: \"John\"\n  });\n</pre>\n\n<p>\nThe edit a label like above use lots of mark-up, we can write a simple subscription group to simplified this like the following:</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/yocel/1\">\n\n\n&lt;span editable=\"name\"&gt;&lt;/span&gt; \n</pre>\n\n<p>The \"editable\" subscription group is defined as follow</p>\n\n<pre prettyprint>\nhm.behavior.editable2 = function( elem, path, group, options ) {\n  setTimeout( function() {\n\n    var attribute = \"ns:/\" + path + \"*edit.item;\" +\n                    \"showOnEdit:&lt;;\" +\n                    \"val:.|enter;\" +\n                    \"$enter:.|*saveShadowItem;\" +\n                    \"$esc:.|*resetShadowItem;\" +\n                    \"focus:&lt;*edit.mode|update\";\n\n    $( '&lt;input type=\"text\" data-sub=\"' + attribute + '\" /&gt;' )\n      .insertAfter( elem ).parseSubs();\n\n  }, 10 );\n\n};\n\nhm.behavior.editable = \"hideOnEdit:.;\" +\n                     \"text:.;\" +\n                     \"$dblclick:.|*editShadowItem;\" +\n                     \"editable2:.\";\n</pre>", "signatures": []},
    {"name": "for array", "namespace": "bulit-in bindings.shadowEdit", "shortDesc": "for array", "longDesc": "<p>Shadow edit for array model is a little different from shadow edit for object and primitive types. When we edit an array, we create, update, and remove an array item one by one.  Array model is normally displayed by list view or query view. You can shadow-edit both.  To shadow edit an array, we need to do some initialization like the following.</p>\n\n<pre prettyprint>\n//shadow edit on list view\nitemsNode.initShadowEdit();\n\n//shadow edit on query view\nitemsNode.enableQuery();\nitemsNode.cd(\"*queryResult\").initShadowEdit();\n</pre>\n\n<p>\nWhen shadow edit  is enabled from list view or query view,  hm.js create a shadow structure like the following.\n</p>\n\n<pre prettyprint>\nhm(\"items*edit\", {\n  item: null,\n  index: -1,\n  mode: function () {\n     //return \"read\" or \"update\" or \"new\"\n  },\n itemTemplate: object\n});\n//or\nhm(\"items*queryResult*edit\", {\n  item: null,\n  index: -1,\n  mode: function () {\n     //return \"read\" or \"update\" or \"new\"\n  },\n itemTemplate: object\n});\n</pre>\n\n<h3>Example</h3>\n<p> In the following example,  inside the list view and query view, each row has an edit button and delete button. There is an add button. When update button or new button is clicked, and a edit view is displayed and the list view or query view is hidden.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/dizow/1\">\n&lt;div ns=\"demo.contacts\"&gt;\n  &lt;div&gt;\n    \t&lt;h3&gt;list view&lt;/h3&gt;\n\n    &lt;table hide-on-edit=\".\"&gt;\n      &lt;thead&gt;\n        &lt;tr&gt;\n          &lt;td colspan=\"3\"&gt;\n            &lt;input type=\"button\" value=\"New Contact\" new-item=\".\" /&gt;\n          &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;th&gt;First Name&lt;/th&gt;\n          &lt;th&gt;Last Name&lt;/th&gt;\n          &lt;th&gt;action&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;/thead&gt;\n      &lt;tbody list-view=\".|contactRow\" shadow-edit=\".\"&gt;&lt;/tbody&gt;\n    &lt;/table&gt;\n    &lt;div edit-item-view=\".|contactInEditMode\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;hr &gt;\n  &lt;div&gt;\n    &lt;h3&gt;query view&lt;/h3&gt;\n    &lt;div hide-on-edit=\"*queryResult\"&gt;\n      &lt;input type=\"button\" value=\"New Contact\" new-item=\"*queryResult\" /&gt;\n      &lt;div&gt;\n      search\n      &lt;select val=\"*query.filter.by\"&gt;\n        &lt;option value=\"\"&gt;All&lt;/option&gt;\n        &lt;option value=\"firstName\"&gt;First Name&lt;/option&gt;\n        &lt;option value=\"lastName\"&gt;Last Name&lt;/option&gt;\n      &lt;/select&gt;\n      &lt;select val=\"*query.filter.ops\"&gt;\n        &lt;option value=\"\"&gt;contains&lt;/option&gt;\n        &lt;option value=\"equals\"&gt;equals&lt;/option&gt;\n      &lt;/select&gt;\n      &lt;input type=\"text\" search-box=\".\" /&gt;\n      &lt;input value=\"Reset Search\" type=\"button\" reset-search=\".\"\n      /&gt;\n      &lt;/div&gt;\n      &lt;table show-found=\".\"&gt;\n        &lt;thead&gt;\n          &lt;tr&gt;\n            &lt;th style=\"cursor: pointer\" sort-query=\".|firstName\"&gt;First Name&lt;/th&gt;\n            &lt;th style=\"cursor: pointer\" sort-query=\".|lastName\"&gt;Last Name&lt;/th&gt;\n            &lt;th&gt;\n              &lt;input value=\"reset sort\" type=\"button\" reset-sort=\".\" /&gt;\n            &lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody query-view=\".|contactRow\" shadow-edit=\"*queryResult\"&gt;&lt;/tbody&gt;\n        &lt;tfoot pager=\".|pagerTemplate\"&gt;&lt;/tfoot&gt;\n      &lt;/table&gt;\n      &lt;p hide-found=\".\"&gt;No result found&lt;/p&gt;\n      &lt;p&gt;\n        &lt;input value=\"reset query\" type=\"button\" reset-query=\".\" &gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div ns=\"*queryResult\" edit-item-view=\".|contactInEditMode\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;label&gt;\n  &lt;input type=\"checkbox\" val=\"*ts\"&gt;Turn on time stamp&lt;/label&gt;\n&lt;div dump=\"demo.contacts*edit\"&gt;&lt;/div&gt;\n</pre>\n<p>\nThe key of using shadow edit is using attributes <code>shadow-edit</code> , <code>edit-item-view</code>\n</p>\n<h3>shadowEditInRow binding</h3>\n\n<p>Like previous example, you can use <code>shadowEditInRow</code> to edit array model. \nInstead of using <code>shadow-edit</code>, you use <code>shadow-edit-in-row</code>. In previous example, you use <code>edit-item-view</code> to handle editing in both new mode and edit mode. In the following example, you use <code>new-item-view</code> to edit in new model, and use the in-row edit template to edit item in edit mode.  In the in-row edit item, we need to use render context's model path as the namespace of the container.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/pinap/1\">\n\n&lt;tbody list-view=\".|contactRow\" shadow-edit-in-row=\".|contactRowInEditMode\"&gt;&lt;/tbody&gt;\n\n&lt;div new-item-view=\".|contactInEditMode\"&gt;&lt;/div&gt;\n\n&lt;tbody query-view=\".|contactRow\" shadow-edit-in-row=\"*queryResult|contactRowInEditMode\"&gt;&lt;/tbody&gt;\n\n&lt;div ns=\"*queryResult\" new-item-view=\".|contactInEditMode\"&gt;&lt;/div&gt;\n\n&lt;script type=\"text/template\" id=\"contactRowInEditMode\"&gt;\n&lt;tr ns=\"{{modelPath /}}*edit.item\"&gt;\n &lt;td&gt;\n  &lt;input type=\"text\" class=\"firstName\" val=\"firstName\"/&gt;\n &lt;/td&gt;\n &lt;td&gt;\n  &lt;input type=\"text\" class=\"lastName\" val=\"lastName\"/&gt;\n &lt;/td&gt;\n &lt;td&gt;\n  &lt;input type=\"button\" value=\"Update\" save-edit=\".\"/&gt;\n  &lt;input type=\"button\" value=\"Cancel\" cancel-edit=\".\"/&gt;\n &lt;/td&gt;\n&lt;/tr&gt;\n&lt;/script&gt;\n</pre>", "signatures": []},
    {"name": "ad-hoc implementation ", "namespace": "bulit-in bindings.shadowEdit", "shortDesc": "ad-hoc implementation ", "longDesc": "<p>The shadowEdit depends on an shadow EditObject, which is under the shadow object. However, we don't really need a shadowEdit plugins to do shadow edit. The following shows how to implement shadow edit without the plugins, and the shows how use shadowEdit plugin to remove this boilerplate.\n</p>\n\n<h3>Ad-hoc implementation of shadow edit.</h3>\n<p>The following is the model of the scenario. It shadow an shadow objects, and several handler that handler to modified the model. The example is bit long, the view is omitted here.  please click on jsbin link to read it.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/lebej/1\">\n  var contacts = hm(\"demo.contacts\"),\n      edit = hm(\"demo.edit\");\n  \n  hm(\"demo\", {\n    contacts: [\n      { firstName: \"Jane\", lastName: \"Poe\" }, \n      { firstName: \"Robert\",lastName: \"Roe\"}, \n      { firstName: \"Brett\", lastName: \"Boe\"}, \n      { firstName: \"Carla\", lastName: \"Coe\"}, \n      { firstName: \"Donna\", lastName: \"Doe\"}, \n      { firstName: \"Juan\", lastName: \"Doe\" }\n    ],\n    \n    //the following logics impelements the \n    //shadow edit in a adhoc process\n    //\n    //shadow object and other state\n    edit: {\n      mode:\"read\",\n      item: null,\n      selectedIndex: -1,\n      itemTemplate: {\n        firstName: null,\n        lastName: null\n      }\n    },\n    //delete\n    removeConact: function (e) {\n      var index = e.selectedRowIndex();\n      contacts.removeAt(index);\n    },\n    //create\n    addNewContact: function (e) {\n      edit.set(\"item\", hm.util.clone(edit.get(\"itemTemplate\")));\n      edit.set(\"mode\", \"edit\");\n    },\n    //edit\n    editContact: function (e) {\n      var index = e.selectedRowIndex(),\n          item = contacts.get(index);\n      edit.set(\"selectedIndex\", index);\n      edit.set(\"item\", hm.util.clone(item, true));\n      edit.set(\"mode\", \"edit\");\n     },\n    //save\n    saveEdit: function (e) {\n      var index = edit.get(\"selectedIndex\"),\n          editingContact = edit.get(\"item\");\n      \n      if (index != -1) {\n        //update\n        contacts.updateAt(index, editingContact);\n        edit.set(\"selectedIndex\", -1);\n      } else {\n        //add\n        contacts.push(editingContact);\n      }\n      edit.set(\"mode\", \"read\");\n      edit.set(\"item\", null);\n    },\n    //cancel\n    cancelEdit: function (e) {\n      edit.set(\"mode\", \"read\");\n      edit.set(\"item\", null);\n      edit.set(\"selectedIndex\", -1);\n    }\n  });\n</pre>\n\n<h3>Implementation using shadowEdit binding</h3>\n<p>The model using here is only the pure data, it will not be show here. All those ad-hoc handler and shadow object are removed, because the \"shadowEdit\" already implement them. Got to jsbin, to compare them side by side. \"shadowEdit\" do the same thing as the adh-hoc implementation, but it is reusable for other similar case.\n</p>\n<pre prettyprint preview=\"_|http://jsbin.com/sedof/1\">\n&lt;script type=\"jsrender\" id=\"contact\"&gt;\n   &lt;tr&gt;\n      &lt;td&gt;{{:firstName}}&lt;/td&gt;\n      &lt;td&gt;{{:lastName}}&lt;/td&gt;\n        &lt;td&gt;\n        \n          &lt;input type=\"button\" value=\"edit\" class=\"editRow\"/&gt;\n           &lt;input type=\"button\" value=\"remove\" class=\"deleteRow\"/&gt;  \n            \n        &lt;/td&gt;\n        &lt;td&gt;{{ts /}}&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/script&gt;\n &lt;script type=\"jsrender\" id=\"editingCotnact\"&gt;\n   \t&lt;div ns=\"*edit.item\"&gt;\n\t\t&lt;p&gt;\n\t\t\tFirst Name: &lt;input type=\"text\" val=\"firstName\"&gt;\n\t\t&lt;/p&gt;\n\n\t\t&lt;p&gt;\n\t\t\tLast Name: &lt;input type=\"text\" val=\"lastName\"&gt;\n\t\t&lt;/p&gt;\n         &lt;p&gt;\n           &lt;button save-edit=\".\"&gt;Ok&lt;/button&gt;\n             &lt;button cancel-edit=\".\"&gt;Cancel&lt;/button&gt;\n    &lt;/p&gt;\n\t&lt;/div&gt;   \n&lt;/script&gt;\n\n&lt;div ns=\"demo.contacts\"&gt;     \n    &lt;h3&gt;list view&lt;/h3&gt;\n    &lt;table hide-on-edit=\".\"&gt;\n        &lt;tr&gt;\n          &lt;td colspan=\"2\"&gt;\n            &lt;button new-item=\".\"&gt;\n              Add new contact\n            &lt;/button&gt;\n          &lt;/td&gt;\n      &lt;/tr&gt;\n        &lt;tr&gt;\n          &lt;th&gt;First Name&lt;/th&gt;\n          &lt;th&gt;Last Name&lt;/th&gt;\n          &lt;th&gt;action&lt;/th&gt;\n          &lt;th&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;tbody list-view=\".|contact\" shadow-edit=\".\"&gt;\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n    \n    &lt;div edit-item-view=\".|editingCotnact\"&gt;&lt;/div&gt;\n &lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "itemTemplate", "namespace": "bulit-in bindings.shadowEdit", "shortDesc": "itemTemplate", "longDesc": "<p>To shadow edit an array node, one of the tasks is to create new item. The new item is a clone of  a itemTemplate. By default, when initiating shadowEdit for array or array query, the scehma of the itemTemplate inferred from the schema of the first item in array or a result of query. However, the item template can be explicitly set, it either an object or it is function to create a new item.  There are two way to set the item template.\n</p>\n\n<h3>Programatically set item template</h3>\n\n<p>We can set it from initShadowEdit() like the following.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/subic/1\">\nitemsNode.initShadowEdit(object);\nitemsNode.cd(\"*queryResult\").initShadowEdit(object);\n//or\nitemsNode.initShadowEdit(objectBuilder);\nitemsNode.cd(\"*queryResult\").initShadowEdit(objectBuilder);\n</pre>\n\n<h3>Set item template by convention</h3>\n<p>If the array path is \"items\", the initShadowEdit expect \"items_itemTemplate\" is the item template.</p>\n<pre prettyprint preview=\"_|http://jsbin.com/cumof/1\">\nvar model = hm(\"demo\", {\n    contacts: [\n      { firstName: \"Jane\", lastName: \"Poe\"},\n      { firstName: \"Robert\", lastName: \"Roe\"},\n      { firstName: \"Brett\", lastName: \"Boe\"},\n      { firstName: \"Carla\", lastName: \"Coe\"},\n      { firstName: \"Donna\", lastName: \"Doe\"},\n      { firstName: \"Juan\", lastName: \"Doe\"}\n      ],\n    contacts_itemTemplate: function () {\n      return {\n        firstName: \"firstName\",\n        lastName: \"lastName\"\n      };\n    }\n  });\n</pre>", "signatures": []},
    {"name": "validation", "namespace": "bulit-in bindings", "shortDesc": "validation", "longDesc": "<p>Validation binding is used to validate the model but not the view. When user input data via a widget and the input is invalid, the binding does not prevent the model to be updated by user's input. Instead, the binding just flag that the model is invalid. You can decide what to do when model is invalid. Generally,  there are 4 steps in using the validation in Hm.js</p>\n\n<ol>\n<li>create validator</li>\n<li>attach validator to model</li>\n<li>invoke validator</li>\n<li>act on validity</li>\n</ol>\n\n<p>In <a href=\"#api.apiAction=view&api.selectedEntryName=Core.value+adapter?api.apiAction=view&api.selectedEntryName=bulit-in+bindings.val\">val binding</a>, there is an example of using input widgets. The example does not have any validation. The following is refactory of the example. There are there difference here. Firstly, the model is attached with some validators. Secondly, the input widget is attached with <code>warning</code> binding, which will show warning message if the model behind the widget is invalid. Thirdly, when the the submit button is attached with <code>check-validity</code> binding, if one model in the form is invalid, it will not submit the form.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/guvug/1\">\n\nmodel.cd(\"profile\").validator({\n  name: [\"required\"],\n  dateOfBirth: [[\"required\", \"please enter your birthday\"]],\n  major: \"required\",\n languages: \"required\",\n  gender: \"required\",\n  accept: [ \"required\", [\"fixedValue\", {fixedValue: true, error: \"You must accept terms\"}]]\n});\n</pre>\n\n<pre prettyprint>\n&lt;input type=\"text\" ns=\"name\" val=\".\" warn=\".\"&gt;\n\n&lt;input type=\"button\"  $click=\"/myapp.submit\" value=\"Submit\" \n check-validity=\".\"&gt;\n</pre>\n\n<h3>How it works?</h3>\n\n<p>When we attach a validator to a model  <code>hm(\"foo\")</code>, this will attach a handler to the <code>afterUpdate</code> handler. After model is updated, validator is called, if the model value is invalid, handler will create an error message in <code>hm(\"foo*errors\")</code> and add the model path <code>foo</code> to the <code>hm(\"*invalidPaths\")</code>. If value changed again, and value becomes valid, the error generated previous will be removed from <code>hm(\"foo*errors\")</code>, and the path <code>foo</code> will be remove from <code>hm(\"*invalidPaths\")</code>.</p>\n\n<h3>Example</h3>\n\n<p>The following example uses <code>hm(\"foo\").validator()</code> to add 3 validators to the model, <code>required</code>, <code>number</code> and a custom handler.  Observe how the debug data dump changes when you key in a value.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/yulux/1\">\n  hm(\"demo\", {\n    number: null\n  });\n  \n  hm(\"demo.number\").validator([\n    \"required\",\n    \"number\",\n    function (value) {\n      if (value &lt; 100) {\n         return \"you must enter not less than 100\"; \n      }\n    }\n  ]);\n</pre>\n\n<pre prettyprint>\n &lt;div data-sub=\"ns:demo\"&gt;\n    &lt;label&gt;\n    Ener a number over 100: \n    \n    &lt;input type=\"text\" data-sub=\"val:number|keyup\" /&gt;\n    &lt;/label&gt;\n\n  &lt;/div&gt;\n  &lt;div dump=\"demo.number\"&gt;&lt;/div&gt;\n  &lt;div dump=\"demo.number*errors\"&gt;&lt;/div&gt;\n  &lt;div dump=\"*invalidPaths\"&gt;&lt;/div&gt;\n</pre>\n\n<p>\nThe data in node <code>path*errors</code> and <code>*invalidPaths</code> can be used to rendering warning to user. Hm.js comes with a simple <code>warning</code> binding, which shows error beside the input widget, and <code>checkValidity</code> , which check whether the descendants of a node and the node itself have any error. But you don't have to use them,  you can create your binding to leverage the data in <code>path*errors</code> and <code>*invalidPaths</code>. The following example make a small change on previous example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/ladij/1\">\n &lt;div class=\"demo\" ns=\"demo\"&gt;\n    &lt;div&gt;\n    &lt;label&gt;\n    Ener a number over 100: \n    \n      &lt;input type=\"text\" ns=\"number\" val=\".|keyup\" warn=\"number\" /&gt;\n    &lt;/label&gt;\n    &lt;/div&gt;\n    \n    &lt;div&gt;\n      &lt;button check-validity=\".\"\n        alert=\".|You data is submitted\"&gt;Submit&lt;/button&gt;      \n    &lt;/div&gt;\n  &lt;/div&gt;\n  \n  &lt;div dump=\"demo.number\"&gt;&lt;/div&gt;\n  &lt;div dump=\"demo.number*errors\"&gt;&lt;/div&gt;\n  &lt;div dump=\"*invalidPaths\"&gt;&lt;/div&gt;\n</pre>\n", "signatures": []},
    {"name": "programmatically", "namespace": "bulit-in bindings..validation.apply validator", "shortDesc": "apply validator programmatically", "longDesc": "<p>We can use node.validator() to apply validator to model</p>", "signatures": [
        {"name": "node.validator(validator[, options])", "returns": "Node", "shortDesc": "apply a validator a model node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.validator(commonValidator[, options])", "parameters": [
                {"name": "commonValidator", "type": "string", "desc": "the name of common validator, such as \"required\", \"number\" etc."},
                {"name": "options", "type": "object", "desc": "optional, the options to customize common validator. Different common validator might have different options."}
            ]},
            {"versionAdded": "0.1", "name": "node.validator(adHocValidator)", "parameters": [
                {"name": "adHocValidator", "type": "function", "desc": "a function to check whether a value is valid or not, if it is invalid, return an error message or return false to use the default error message.\n<pre data-sub=\"prettyprint:_;preview:_|\">\nfunction (value) {\n  //check value\n //return error message or return false or return undefined\n}\n</pre>"}
            ]}
        ], "examples": [
            {"desc": "<p>The following use check to apply <code>required</code> validator to two nodes. One has an options, which is the error message. One does not have an option, which use default error message of the validator.</p>", "code": "  hm(\"demo\", {\n    name: null,\n    phone: null\n  });\n  \n  \n  hm(\"demo.name\").validator(\"required\");\n  hm(\"demo.phone\").validator(\"required\", \"Please enter a phone number\");", "url": "http://jsbin.com/itunol/3"},
            {"desc": "<p>This example use a ad-hoc function to return different error message based on the input value</p>", "code": "hm(\"demo\", {\n  number: null\n });\n  \nhm(\"demo.number\").validator(\"required\");\nhm(\"demo.number\").validator(function( value ) {\n if (!$.isNumeric( value )) {\n   return \"Please enter a number between 1 and 100, e.g 50\";\n  } else if (value > 50) {\n   return \"Please enter a smaller number\";\n } else if (value < 50) {\n  return \"Please enter a larger value\";\n }\n});\n  ", "url": "http://jsbin.com/urecov/2"}
        ]},
        {"name": "node.validator(validators)", "returns": "Node", "shortDesc": "apply multiple validators to a node", "desc": "", "overloads": [
            {"versionAdded": "0.1", "name": "node.validator(validators)", "parameters": [
                {"name": "validators", "type": "array", "desc": "an array of validators, the item of which can be a commonValidator, or [commonValidator, options], or ad-hoc functions."}
            ]}
        ], "examples": [
            {"desc": "<p>This example add multiple validator in a single call.\n</p>", "code": "  hm(\"demo\", {\n    number: null\n  });\n  \n  hm(\"demo.number\").validator(\n    [\n      //validator 1, common validator with options\n      [\"required\", \"Number field is required\"],\n      //validator 2, common validator with no options\n      \"number\",\n      //validator 2, ad-hoc validator\n      function (value) {\n        if (value > 50) {\n\t\t\treturn \"Please enter a smaller number\";\n\t\t} else if (value < 50) {\n\t\t\treturn \"Please enter a larger value\";\n\t\t}\n      }\n    ]);", "url": "http://jsbin.com/ofisal/2"}
        ]},
        {"name": "node.validator(validatorGroup)", "returns": "node", "shortDesc": "apply a group of validators the children of the node.", "desc": "If a node has multiple children, this method can apply validators to children in one single call.", "overloads": [
            {"versionAdded": "0.1", "name": "node.validator(validatorGroup)", "parameters": [
                {"name": "validatorGroup", "type": "object", "desc": "validator group is like \n<pre data-sub=\"prettyprint:_\">\n{\n   subProperty1: validatorOrValidators1,\n   subProperty2: validatorOrValidators2\n}\n//validatorOrValidators can be a validator, or\n// [validator, options], \n//or [ validator1, [validator2, options2], validator3]\n</pre>"}
            ]}
        ], "examples": [
            {"desc": "<p>The following example use validationGroup to register all the validations to the property of registration node.</p> \n\n</p>", "code": " hm( \"demo\", {\n      registration: {\n        email: \"\",\n        url: \"\",\n        name: \"\",\n        age: \"\",\n        password: \"\",\n        repeat_password: \"\",\n        accepted: false\n      },\n      message: \"You request has been submitted\"\n    }\n  );\n\n  hm( \"demo.registration\" ).validator( {\n    email: [\"email\", \"required\"],\n    url: \"url\",\n    name: [\n      [\"regex\", \"/[a-zA-Z ]{5,}/,You must specify a valid name with at least 5 characters.\"],\n      \"required\"\n    ],\n    age: [\n      [\"number\", \"age must be a number\"]\n    ],\n    password: \"required\",\n    repeat_password: [\"required\", [\"equal\", \"..password,The passwords are not the same.\"]],\n    accepted: [\n      [\"required\", \"You must agree the terms\"],\n      [\"fixedValue\", \"true\" ]\n    ]\n  } );", "url": "http://jsbin.com/itafag/3"}
        ]}
    ]},
    {"name": "create validator", "namespace": "bulit-in bindings.validation", "shortDesc": "create validator", "longDesc": "<p>\nThere are two kinds of validator in Hm.js, ad-hoc validator and well-known validator\n</p>\n<h3>ad-hoc validator</h3>\n<p>\nAd-hoc validator is just a function or a regular expression, whether check a value is valid. If it is valid, return <code>undefined</code>. If it is invalid, return an error message, or return false if you want to use system's default error message. The default error message in defined in <code>hm.options.errors.defaultError</code>, and you can change that. The following is simple example.\n</p>\n\n<pre prettyprint>\nfunction( value ) {\n if (value > 50) {\n   return \"Please enter a smaller number\";\n } else if (value < 50) {\n  return \"Please enter a larger value\";\n }\n}\n</pre>\n\n<h3>well-known validator</h3>\n\n<p>Well-known validator is created to be reusable, they can be referenced by name. Hm.js comes with 17 well-known validators. A well-known validator has at most five members, but only the <code>name</code> property and the <code>isValid</code> function or regular expression are required, others are optional. The following shows the implementation of <code>minlength</code> validator, which has all of the five members.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.validator( {\n  //required\n  name: \"minlength\",\n\n  //required\n  //the options parameter is optional, it is created by \n  //the initialize function as below\n  isValid: function( value, options ) {\n    return value.length &gt;= options.minlength;\n  },\n\n  //optional, required only if your validator \n  //has parameters, like the one \"minlength\" here\n  //options is the string or object passed in when \n   //the validator is applied.\n  initialize: function( publisher, subscriber, handler, options ) {\n    var match;\n    if (options &amp;&amp; (match = rFirstToken.exec( options ))) {\n      handler.options = {\n        minlength: +match[1],\n        error: match[3]\n      };\n    } else {\n      throw \"invalid options for minlength validator\";\n    }\n  },\n\n  //optional, default value is hm.options.errors.defaultError \n  //it is the error message when the model is invalid, or\n  //it is the error template which will be passed into \n   //buildError if it is available.\n  error: \"Please enter at least {minlength} characters.\",\n \n  //optional, required only if you build a error based \n  //on options created in initialize function\n  // it is a function like function ( errorTemplate, options ) { }\n  buildError: hm.validator.defaultErrorBuilder\n} );\n</pre>\n\n<p>\n<code>hm.validator.defaultErrorBuilder</code> is helper function, the following shows what it does.\n</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/vihad/1\">\n\nvar error = hm.validator.defaultErrorBuilder(\"hello, {name}\", {name: \"john\"});\nhm.log(error);\n</pre>\n\n<h3>Example</h3>\n<p>The following is simple zip code validator,  whose <code>isValid</code> function is regular expression.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/iFImIjeJ/2\">\n\nhm.validator({\n  name: \"zipCode\",\n  error: \"Please enter a valid zip code\",\n  isValid: /^\\d{5}(-\\d{4})?$/\n});\n</pre>", "signatures": []},
    {"name": "apply validator", "namespace": "bulit-in bindings.validation", "shortDesc": "apply validator to model", "longDesc": "<p>The target of validation binding is not the value a input widget holds, but the value of model which the widget it bound to.</p>\n\n<p>There are two ways to attach validator to model nodes, programatically or declaratively. However, programmatic method is the preferred way, because the the validation is on the model side but not the view side. But sometime it is convenient to use declarative way, when the model is created dynamically  like the shadow model used in shadow edit binding.\n</a>\n\n<h3>Attach validator to model programmatically</h3>\n<p>Hm.js bundles a 17 frequently used well-known validator which can be referenced by name like the following\n</p>\n\n<pre prettyprint>\nmodel.validator(wellknownValidatorName, options);\n</pre>\n\n<p>The options is usually used to override the default error message of the validator. But some validators like such as <code>equal</code>, <code>fixedValue</code>, <code>regex</code> use it to initialize the required parameters.  The following is some examples\n</p>\n\n<pre prettyprint>\n\nmodel.validator(wellknownValidatorName, \"error message\");\n\n//p1,p2 .. are the parameters passed as options into the function\n//validator.initialize( publisher, subscriber, handler, options ) { }\nmodel.validator(wellknownValidatorName, \"p1,p2,...,error message\");\n\nnameNode.validator(\"required\", \"The name is required!\");\n\nvalumeNode.validator(\"range\", \"1000,2000,The volume must be between 1000 to 2000\");\n\n</pre>\n\n\n<p>A model node can have multiple validators applied to it at same time. One special validator is <code>required</code>. When the validator is used with other validator,  it follow the rules in the following table. When a model is empty, it means  the model value is undefined or empty string, or white space only string.\n</p>\n\n<table>\n <tr>\n    <td>required?</td>\n    <td>model is empty?</td>\n    <td>isValid?</td>\n    <td>evaluate other validators?</td>\n  </tr>\n\n<tr>\n  <td>no</td>\n  <td>yes</td>\n   <td>yes</td>\n   <td>no</td>\n</tr>\n\n\n<tr>\n  <td>no</td>\n  <td>no</td>\n   <td>depends on other validators</td>\n   <td>yes</td>\n</tr>\n\n\n\n<tr>\n  <td>yes</td>\n  <td>yes</td>\n   <td>no</td>\n   <td>no</td>\n</tr>\n\n<tr>\n  <td>yes</td>\n  <td>no</td>\n   <td>depends on other validators</td>\n   <td>yes</td>\n</tr>\n\n\n</table>\n\n\n<h3>Example</h3>\n\n<p>The following shows all 17 common validators in action</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/AkEzUcI/2\">\n  hm( \"demo\", {\n      registration: {\n        creditcard: \"\",\n        date: \"\",\n        dateISO: \"\",\n        digits: \"\",\n        email: \"\",\n        password:\"\",\n        equal_password: \"\",\n        fixedValue: \"\",\n        max: \"\",\n        maxlength: \"\",\n        min: \"\",\n        minlength: \"\",\n        number: \"\",\n        range: \"\",\n        rangelength: \"\",\n        regex: \"\",\n        url: \"\"\n      }\n    }\n  );\n\n  hm( \"demo.registration\" ).validator( {\n        creditcard: [\"required\", \"creditcard\" ],\n        date: [\"required\", \"date\"],\n        dateISO: [\"required\", \"dateISO\"],\n        digits: [\"required\", \"digits\"],\n        email: [\"required\", \"email\"],\n        password: \"required\",\n        equal_password: [\n          \"required\",\n          //\"..password\" is that subPath to compared node\n          [\"equal\", \"..password,The passwords are not the same.\"]\n          \n        ],\n        fixedValue: [\n          \"required\", \n          [\"fixedValue\", \"ok\"]\n        ],\n        max: [\n          \"required\", \n          [\"max\", 100]\n        ],\n        maxlength: [\n          \"required\", \n          [\"maxlength\", 10]\n        ],\n        min: [\n          \"required\", \n          [\"min\", 100]\n        ],\n        minlength: [\n          \"required\", \n          [\"minlength\", 10]\n        ],\n        number: [\"required\", \"number\"],\n        range: [\n          \"required\", \n          [\"range\", \"10,99\"]\n        ],\n        rangelength: [\n          \"required\", \n          [\"rangelength\", \"10,15\"]\n        ],\n        regex: [\n          \"required\", \n          [\"regex\", \"/\\\\w{10,}/\"]\n        ],\n        url: [\"required\", \"url\"]\n  } );\n</pre>\n\n<p>\nWhen you add well-known validator, its default message is saved at <code>hm.options.errors</code>. So the following allow you change the default error message of <code>required</code> validator to Chinese.\n</p>\n\n<pre prettyprint>\nhm.options.errors.required = \"\";\n</pre>\n\n\n<h3>applying well-known validator declaratively</h3>\n\n<p>We can use <code>validatorName=\"path|options\"</code> to apply common validator declaratively. In the following, validator <code>required</code>, <code>regex</code> is applied to model \"name\".  Please note this binding has nothing to do with the the textbox(the view), you can attach these validator to any elements, it still works.\n</p>\n\n<pre prettyprint preview>\n&lt;input type=\"text\" ns=name\"\n    val=\".\"\n    required=\".\"\n    regex=\".|/[a-zA-Z ]{5,}/,You must specify a valid name\"\n    warn=\".\"/&gt;\n</pre>\n\n<p>\nGenerally, you apply validator programmatically, because its easy to maintain. But sometime is much easier that declaratively. Because the model is dynamically created. In the following example,  the shadow edit model is constantly created and deleted, we want to apply <code>required</code> validator to the shadow edit model's first name, and last name,  it is hard to do that programmatically. But it is very easy to do that declaratively like the following.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/nexux/1\">\n &lt;div ns=\"*edit.item\"&gt;\n &lt;p&gt;\n  &lt;input type=\"text\" class=\"firstName\" ns=\"firstName\" val=\".\" required=\".\" warn=\".\"/&gt;\n &lt;/p&gt;\n  &lt;p&gt;\n  &lt;input type=\"text\" class=\"lastName\" ns=\"lastName\" val=\".\" required=\".\" warn=\".\"/&gt;\n  &lt;/p&gt;\n   &lt;p&gt;\n   &lt;input type=\"button\" value=\"Save\" save-edit=\".\" check-validity=\".\" &gt;\n  &lt;input type=\"button\" value=\"Cancel\" cancel-edit=\".\" &gt;\n      {{ts /}}\n &lt;/p&gt;\n&lt;/div&gt;\n</pre>\n\n<h3>applying ad-hoc validator to declaratively</h3>\n\n<p>\nFirst the ad-hoc validator must be put in repository. Then we can reference it from view.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/aceqog/3\">\n\n  &lt;input type=\"text\" ns=\"name\" val=\".|keyup\" required=\".\" validator=\".|..checkName\" warn=\".\"&gt;\n    &lt;br&gt;\n    &lt;button check-validity=\".\"&gt;check&lt;/button&gt;\n\n</pre>\n\n<pre prettyprint>\n hm(\"demo\", {\n    name: \"\",\n    checkName: function (value) {\n      if (value.length &lt; 5) {\n        return \"name must have at least 5 chracters\"; \n        \n      }\n    }\n  });\n</pre>\n", "signatures": []},
    {"name": "invoke validator", "namespace": "bulit-in bindings.validation", "shortDesc": "invoke validator", "longDesc": "<p>There are two ways invoke a validator, reactive and proactive.\n</p>\n<h3>Reactive invocation</h3>\n\n<p>Reactive invocation means that you don't write extra to to invoke it, it is taken care by subscriptions.  When we attach a validator to a model, a subscription is created for the <code>afterUpdate</code> event of the model. After model is updated,  the validator will be automatically invoked. \n</p>\n\n<h3>Proactive invocation</h3>\n\n<p>If model has not been changed,  but you want to know whether it is valid,  you need to proactively invoke the validator.\n</p>\n<h4><code>model.checkValidity()</code></h4>\n<p>In the following example,  in subscription handler of the button click events, the code uses  <code>model.checkValidity()</code> to check the validity of registration model proactively. In this example, the model (registration) is an complex model, with a few properties which are attached with some validators. When the <code>checkValidity</code> method is called on the model,  internally,  it call all the <code>checkValidity</code> on properties. If one of the property is invalid, then the parent model is invalid.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/gixof/1\">\n  hm( \"demo\", {\n      registration: {\n        email: \"\",\n        url: \"\",\n        name: \"\",\n        age: \"\",\n        password: \"\",\n        repeat_password: \"\",\n        accepted: false\n      },\n     //$click event handler\n      checkValidity: function () {\n       var valid = hm(\"demo.registration\").checkValidity();\n        alert(\"validity of registration model is \" + valid);\n      }\n    }\n  );\n\n  hm( \"demo.registration\" ).validator( {\n    email: [\"email\", \"required\"],\n    url: \"url\",\n    name: [\n      [\"regex\", \"/[a-zA-Z ]{5,}/,You must specify a valid name with at least 5 characters.\"],\n      \"required\"\n    ],\n    age: [\n      [\"number\", \"age must be a number\"]\n    ],\n    password: \"required\",\n    repeat_password: [\"required\", [\"equal\", \"..password,The passwords are not the same.\"]],\n    accepted: [\n      [\"required\", \"You must agree the terms\"],\n      [\"fixedValue\", \"true\" ]\n    ]\n  } );\n</pre>\n\n<pre prettyprint>\n&lt;input type=\"button\" value=\"check validity\" $click=\"/demo.checkValidity\"/&gt;\n</pre>\n\n<h4><code>checkValidity binding</code></h4>\n\n<p>Instead of writing your event handlers to call the <code>model.checkValidity()</code>, you can apply <code>checkValidity</code> binding to a button. Moreover, if the model is invalid, other click handlers attached to button will not be executed. The following is the refactory of above sample. The following is the only difference from previous example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/relaq/1\">\n&lt;input type=\"button\" value=\"Submit\" check-validity=\".\" alert=\"..message\"/&gt;\n</pre>", "signatures": []},
    {"name": "react to validation result", "namespace": "bulit-in bindings.validation", "shortDesc": "react to validation result", "longDesc": "<p>When a validator is invoked, it does the following tasks</p>\n\n<ol>\n<li>Add error or remove error from queue to <code>model*errors</code> node.</li>\n<li>Add or remove the path of model from the queue <code>*invalidPaths</code></li>\n</ol>\n\n<p>\nA validator care about only model, it does not care about view at all, so invoking a validator does not trigger any view behavior. In order trigger view behavior, we must create subscription to react to the validation result. Hm.js has a few bindings to react to validation result,  but we can also create customs binding to react differently.\n</p>\n\n\n<h3><code>warn</code> binding</h3>\n<p>This is a binding create subscription to validation result, if model is invalid,  a warning message will be insert after the widget, if model is valid, the warning message is removed.\n</p>\n\n\n<pre prettyprint preview=\"_|http://jsbin.com/EgEMaLO/2\">\n &lt;label&gt;\n    Name:&lt;input type=\"text\" ns=\"name\" val=\".|keyup\" warn=\".\" /&gt;\n &lt;/label&gt;\n</pre>\n\n<h3>\n<code>warnSummary</code> binding\n</h3>\n\n<p>Similar to <code>warn</code> binding, <code>warnSummary</code> create subscription to validation result. When model is invalid, it lists all error messages related to a model and its properties in a list view, the list view need to be rendered by a template.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/quvij/1\">\n&lt;div warn-summary=\"demo|errorSummary\"&gt;&lt;/div&gt;\n\n&lt;script type=\"jsrender\" id=\"errorSummary\"&gt;\n{{if #data.length}}\n  &lt;ol class=\"error\"&gt;\n    {{for #data}}\n      &lt;li&gt;{{:#data}}&lt;/li&gt;\n    {{/for}}\n &lt;/ol&gt;  \n{{/if}}    \n&lt;/script&gt;\n</pre>\n\n<h3><code>validityChanged</code> event</h3>\n\n<p>This is a special event. It will be triggered when after the validity of the node has changed. A model is consider valid when the number of errors generated by validator is zero. When the number of error change from a positive number to 0, or from 0 to a positive number the event will be triggered. The <code>e.proposed</code> returns the validity of the node, <code>e.removed</code> is the value of previous validity.  You can use this event to disable the \"submit\" button like the following example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/aCurAQE/2\">\n\n\n &lt;button check-validity=\".\" !validity-changed=\".|#styleButton\"\n  alert=\".|You data is submitted\"&gt;Submit&lt;/button&gt;  \n</pre>\n<pre prettyprint>\n  hm(\"demo\", {\n    name: null,\n    phone: null,\n    styleButton: function (e) {\n       this.attr(\"disabled\", !e.proposed); \n    }\n  });\n</pre>\n\n<h3><code>validityChecked</code> event</h3>\n<p>\nThis event will be triggered after <code>node.checkValidity()</code> is called.\n</p>\n\n<h3>\n<code>model.getErrors()</code>\n</h3>\n\n<p>\nThis method will return the errors of a model and its children. You should call this method only after <code>model.checkValidity()</code> method is called, because without calling this method, validator will not generate any errors.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/UrAhEcO/2\">\n&lt;button check-validity=\".\"\n  !after-update*_validity-checked=\".|#printError\"\n  !validity-changed=\".|#styleButton\"\n  alert=\".|You data is submitted\"&gt;Submit&lt;/button&gt; \n</pre>\n\n<pre data-sub=\"prettyprint:_\">\n  hm(\"demo\", {\n    name: null,\n    phone: null,\n    styleButton: function (e) {\n       this.attr(\"disabled\", !e.proposed);\n    },\n    printError: function (e) {\n      var errors = e.publisher.getErrors();\n      if (errors.length) {\n        hm.log(\"--errors so far ----\");\n        for (var i = 0; i < errors.length; i++) {\n         hm.log(errors[i]);\n        }\n      } else {\n        hm.log(\"---no error yet---\"); \n      }\n    }\n  });\n</pre>\n\n<h3><code>node.resetValidity()</code></h3>\n<p>\nThis method reset the side effect caused by validators. It clears the data in <code>*invalidPaths</code>, and <code>model*errors</code>. It also raise event <code>validityReset</code>.\n</p>\n\n<h3><code>resetValidity</code> event</h3>\n<p>\nThis event will be triggered after node.resetValidity() is called.\n</p>\n\n<h3><code>resetValidity</code> binding</h3>\n<p>\nThis binding create a subscription that when view is clicked, call <code>model.resetValidity</code>. The following examples, how resetValidity reset the side effect caused by validator.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/EGivEVAp/2\">\n\n&lt;button reset-validity=\".\"&gt;reset&lt;/button&gt;\n</pre>\n\n<h3><code>form</code> binding</h3>\n<p>\nThis binding will be automatically created <code>form</code> element. When form reset button is clicked, reset event is triggered to the form, the model associated with the form reset its validity.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/IraQeCAv/2\">\n&lt;form id=\"myform\" ns=\"demo.registration\" novalidate&gt;\n   &lt;input type=\"button\" value=\"Submit\" check-validity=\".\" alert=\"..message\"/&gt;\n   &lt;button type=\"reset\"&gt;Reset&lt;/button&gt;\n&lt;/form&gt;\n</pre>", "signatures": []},
    {"name": "Class", "namespace": "Utilities", "shortDesc": "hm.Class", "longDesc": "<p>In JavaScript,  we don't need class to build object, instead we use object literal. But sometimes,  when we need to build lots of objects with the shared behaviour,  we do need want to use something like \"Class\" in other languages. However, ES5 does not have class,  Hm.js provide <code>hm.Class</code> to imitate this. <code>hm.Class</code> is essentially a smart constructor. We can also use it to build derived constructor, which is similar to sub-class or derived class. The advantage to use derived constructors is that shared behaviour can be inherited from prototype, which is memory efficient.\n</p>\n\n<p><code>hm.Class</code> use similar extension mechanism of <a href=\"http://backbonejs.org/#Model\">Backbone.Model</a>, but it does not have the features such as id, cid, attributes, validation. The constructor created by <code>hm.Class</code> will build plain-old JavaScript object, which has very minimum features.  <code>hm.Class</code> let your define a constructor with in a more expressive style, it support simple object instantiation, inheritance, override. </p>\n\n<p>\nIn the following, we will use <code>hm.Class</code> to build a Orderline \"class\", The objects created by \"Ordreline\" with shared some methods passed down from prototype object. In that sense, it is more memory efficient than closure.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/uvEwese/3\">\n\nvar OrderLine = hm.Class.extend({\n    cid: null,\n    pid: null,\n    qty: 1,\n    price: function () {\n      var pid = this.get(\"pid\");\n      var product = $(products).filter(function () {\n          return this.id == pid;\n      })[0];\n      return product && product.price || \"\";\n    },\n    subTotal: function () {\n      return this.get(\"qty\") * this.get(\"price\");\n    },\n    toJSON: function () {\n      var rtn = this.callBase(\"toJSON\");\n      if (rtn.qty > 0)  {\n        rtn.qty = +rtn.qty;\n        //cid is not needed at server, delete it\n        delete rtn.cid; \n        return rtn;\n      }\n    },\n    productLookup: function () {\n      var cid = this.get(\"cid\");\n      return $(products).filter(function () {\n         return this.cid == cid;\n      });\n    }\n  });\n</pre>\n\n<h3><code>Class.extend()</code></h3>\n\n<p>\nYou can use it to create new constructor which looks like a derived class.\n</p>\n\n<pre prettyprint>\n//create a sub class of Class\nvar MyClass = hm.Class.extend(instanceProperties, staticProperpties);\n\n//create a sub class of MyClass\nvar MyAnotherClass = MyClass.extend(instanceProperties, staticProperpties);\n</pre>\n<p>The instanceProperties, are inherited by all instance of the new class. While the staticPoperties, will be member of the new class itself.\n</p>\n\n<p>\nThere  are 3 default instance members like follow. All instance created by the Class constructor or derived constructor (like MyClass) inherit them.\n</p>\n<pre prettyprint>\n{\n  callBase: function () {},\n  initialize: function () {},\n  toJSON: function () {}\n}\n</pre>\n<p>\nThere are 2 default static members like follow.  The Class constructor and derived constructor (like MyClass) inherit them.\n</p>\n\n<pre prettyprint>\n{\n  list: function () {},\n  extend: function () {}\n}\n</pre>\n\n<h3>Inheritance and override mechanism</h3>\n\n<p>This works similarly to other languages. A child class can inherit parent class's members. There are two kinds of members, instance members which is attached to each instance created by class. and static member which is attached to the class self. Both of these member can be inherited and overridden.</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/uriCoJi/1\">\n hm.log(\"----animal methods--------\");\n  var Animal = hm.Class.extend({\n    talk: function () {\n        hm.log(\"animal instance talk\");\n    },\n    walk: function () {\n      hm.log(\"animal instance walk\"); \n    }\n    \n  }, {\n    \n    print: function () {\n       hm.log(\"Animal static print\"); \n    },\n    \n    log: function () {\n       hm.log(\"Animal static log\"); \n    }\n  });\n\n  \n  Animal.log();\n  Animal.print();\n  \n  var animal = new Animal();\n  animal.talk();\n  animal.walk();\n  \n  hm.log(\"----cat methods--------\");\n  \n  var Cat = Animal.extend({\n    talk: function () {\n      hm.log(\"cat instance talk: miao\"); \n    }\n  }, {\n    log: function () {\n      hm.log(\"Cat static log\"); \n    }\n  \n  });\n  \n  Cat.log();\n  Cat.print();\n  \n  var cat = new Cat();\n  cat.talk();\n  cat.walk();\n</pre>\n\n\n<h3><code>instance.initialize()</code></h3>\n\n<p>\nWhen a Class object is called with a set of parameters, these parameters are passed into the <code>instance.initialize()</code> method. The default implementation of the method take an object, and extend the instance with the members of the object like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar Person = hm.Class.extend();\nvar person = new Person({ firstName: \"John\", lastName: \"Doe\" });\n//\n//person.firstName == \"John\"\n//person.lastName == \"Doe\"\n</pre>\n\n<p>\nBut you can override this method  like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar Person = hm.Class.extend({\n  initialize: function( firstName, lastName ) { \n\tthis.firstName = firstName;                  \n\tthis.lastName = lastName;                    \n   }                                            \n});\nvar person = new Person(\"John\", \"Doe\");\n</pre>\n\n<h3><code>instance.callBase(\"baseMember\"[, parameters])</code></h3>\n<p>\nIf you are overriding a method, you can call the original method with <code>instance.callBase</code> method. In the following, we want or constructor to support both of object extension and simple string parameter, so we can use this method.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar Person = hm.Class.extend({\n   initialize: function (firstName, lastName) {\n      if (typeof  firstName == \"string\") {\n           this.firstName = firstName;\n           this.lastName = lastName;\n      } else {\n        this.callBase(\"initialize\", firstName);\n      }\n   }\n});\n\n  var p1 = new Person(\"John\", \"Doe\");\n  var p2 = new Person({\n    firstName: \"John\",\n    lastName: \"Doe\"\n  });\n  //p1.firstName == p2.firstName, p1.lastName == p2.lastName;\n</pre>\n\n<h3>The \"new\" keyword is optional.</h3>\n<p>Normally when a constructor is called without the \"new\" keyword, this can caused unwanted behavior. However, the constructor <code>hm.Class</code>, and its descendent can be invoked with or without the \"new\" keyword. The result is the same.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar p1 = Person(\"John\", \"Doe\");\nvar p2 = new Person(\"John\", \"Doe\");\n</pre>\n\n<h3><code>Class.list()</code></h3>\n<p>\nTo create a list of instance of objects, we can use static method <code>Class.list</code> short-cut. The following achieve the same result.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar personList1 = [ \n     new Person({ firstName: \"John\", lastName : \"Doe\" }), \n     new Person( { firstName: \"Jane\", lastName : \"Roe\"})\n];\n\nvar personList2 = Person.list([  \n         [ \"John\", \"Doe\"],\n         [ \"Jane\", \"Roe\"]\n]);\n</pre>\n\n<h3><code>instance.toJSON()</code></h3>\n\n<p>\nThis method is called by JavaScript engine, when an instance of  \"Class\" is serialized to string by <code>JSON.stringify(instance)</code> method. The default implementation of  this method is to make a copy of the instance and delete the member with \"__\" prefix. So that if you have some private state which you don't want to serialized, you can prefix the state with \"__\" like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_;preview:_|http://jsbin.com/aqeqar/2\">\n  var obj = {};\n  obj.__privateStuff = \"secrect\";\n  obj.name = \"John\";\n  hm.log(\"------serialization of literal object-------\");\n  hm.log(JSON.stringify(obj)); \n  hm.log(obj.__privateStuff);\n  hm.log(\"\");\n  \n  obj = hm.Class();\n  obj.__privateStuff = \"secrect\";\n  obj.name = \"John\";\n  hm.log(\"------serialization of instance of Class-------\");\n  hm.log(JSON.stringify(obj));\n  hm.log(obj.__privateStuff);\n</pre>\n\n<p>\nYou can override the default implementation if you have more stuff to hide from serialization. In hte previous examples, the OrderLine class does not want the cid to be returned, and the qty member needs to be strict number, the implementation is following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\n  toJSON: function () {\n      var rtn = this.callBase(\"toJSON\");\n      if (rtn.qty > 0)  {\n        rtn.qty = +rtn.qty;\n        //cid is not needed at server, delete it\n        delete rtn.cid; \n        return rtn;\n      }\n    },\n</pre>", "signatures": []},
    {"name": "Entity", "namespace": "", "shortDesc": "Entity", "longDesc": "<p>\nEntity is a sub-class of <a href=\"/Hm.js/pages/doc.html#api.apiAction=view&api.selectedEntryName=Core.Class\">hm.Class</a>. It can be used to do some CRUD operation with server server,  by default it works with with restful service,  use \"POST\", \"PUT\", \"DELETE\", \"GET\" HTTP method. But its method can be overridden by sub-class. Here is its skeleton.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nhm.Entity = hm.Class.extend(\n//instance members, shared by instance\n{\n  create: function () {},\n  update: function () {},\n  fetch: function () {},\n  destroy: function () {},\n  //save can be called by model node only.\n  save: function () {}\n},\n//static members, shared by class\n{\n  state: enum, //detached, unchanged, added, deleted, modified\n  create: function (instance) {},\n  fetch: function (instance) {},\n  destroy: function (instance) {},\n  save: function (instance) {},\n  getUrl: function (methodName, instance) {},\n  ajax: function (methodName, instance) {}\n});\n</pre>\n<p>\nAll these methods  (except getUrl) return a jqXHR, which is a promise. They can be used independent of repository, like the following.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar Person = hm.Entity.extend(null, { url: \"http://localhost/people\");\nvar person = Person({firstName: \"John\", lastName: \"Doe\" });\nperson.create().done(function () {\n assert(person.id !== undefined, \"server return an id when created\");\n});\nvar persons = Person.fetch();\n//wait for previous call done\nassert(persons.length == 1);\n\n//wait for previous call done\nvar person2 = Person({id: person.id});\nperson2.fetch();\n\n//wait for previous call done\nperson2.firstName = \"Jane\";\nperson2.update();\n//wait for previous call done\nperson2.destroy();\n\n});\n</pre>\n\n<p>We can also put entity into repository, and called these method via node. There also three node extension method like the following. These method will divert the call the the the entity method.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nnode.save();\nnode.fetch();\nnode.destroy();\n</pre>\n\n<p>\nOne benefit to use node is that repository can keep track of its change internally, and update the change properties only, and node will figure it out whether it is update or create.\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar people = hm(\"people\", []);\npeople.push(Person({firstName: \"John\", lastName: \"Doe\" });\npeople.cd(0).save(); //this will be create\n\n//wait for previous call done\nvar id = people.cd(0).get(\"id\");\nassert( id !== undefined);\npeople.del(0); //delete it locally\npeople.push(Person({id: id});\npeople.cd(0).fetch(); \n\n//wait for previous call done\npeople.cd(0).set(\"firstName\", \"Jane\");\npeople.cd(0).save(); //this will be a update\n\n//wait for previous call done\npeople.cd(0).destroy(); //this will destroy from the server, and delete it locally\n\n//wait for previous call done\nassert(people.get(0) === undefined);\n</pre>\n\n<h3>Extending Entity</h3>\n<p>You can extend the entity by overriding both the instance method and the static method. But normally, you it is sufficient to override static method, because instance method will be redirect to instance method by default besides some other post-processing in side the instance method. \n</p>\n\n<pre data-sub=\"prettyprint:_\">\nvar Person = hm.Entity.extend(null, {\n   getUrl: function( methodName, instance ) { //overriding },\n   ajax: function (method, instance) { //use other type of web service instead of  restful service }\n});\n</pre>", "signatures": []},
    {"name": "routing", "namespace": "bulit-in bindings", "shortDesc": "routing", "longDesc": "<p>A web application has an important feature that desktop application doesn't have, that is url. Urls  link all the information together and become the world wide web. But is url important to a single page application? Here is a <a href=\"http://emberjs.com/blog/2013/08/31/ember-1-0-released.html\">quote </a> form Emberjs.\n</p>\n\n<blockquote>\nWhile struggling to figure out the best solution, we couldn't help but notice that many JavaScript applications on the web felt broken. Basic things that we had taken for granted for two decades all of a sudden stopped working. Just clicking the browser's back button was enough to break many of these apps.\n</blockquote>\n\n<p>Emberjs think that url is not only important to traditional web page, but it is also important to a single page application. An url of a web page can take you a piece information such as a page on the web, and an url of single page application can take you a single page application in appropriate state. This might seems to be trivial, but it is an important feature in lots MVC framework such as Emberjs. This feature normally call routing. </p>\n\n<p>Hm.js fully support routing. However it is optional feature. If your application does not care about persist application state into an url, and you don't care about page back button which will take you to the previous state of your application,  you don't have to use it. The following is the feature supported by routing of hm.js\n</p>\n\n<ol>\n  <li>When url change, restore the model to a proper state.</li>\n  <li>When model change, update the url which can used to do the previous task</li>\n  <li>Prevent circular update and infinite loop caused by previous two tasks</li>\n  <li>When an application get loaded by an absolute url, the application will be loaded in appropriate   state.\n </li>\n</ol>\n\n<p>\nThe route information is embedded in the hash of the url. There are two kind of route information, route path and route parameters. They are independent of each other, there is not direct relationship between them. This means you can use use route path only or route parameter only or both. The following example shows which part of the url is which.\n</p>\n\n<pre prettyprint>\n\nvar url = \"http://mysite/index.html#/home/news?id=1234&mode=desktop\"\n\nvar hash = \"home/news?id=1234&mode=desktop\";\n\nvar routePath = \"home/news\";\n\nvar routeParams = \"id=1234&mode=desktop\";\n\n</pre>\n\n\n<h3>route parameters</h3>\n\n<p>\nRoute parameters is used to synchronize the value of the a model with the route parameter in url hash. The syntax of using route parameter is as follow.  You can use multiple route parameters to synchronize the values of multiple models. The example is <a href=\"http://jsbin.com/arOgOfiK/3/edit\" target=\"_blank\">here</a>. \n</p>\n\n<pre prettyprint>\nhm.routeParams(modelPath1, modelPath2, ...);\n\n//if want to synchronize the value of  model hm(\"category\") \n//with the route paratermers in hash\n\nhm.routeParams(\"demo.category\");\n\n//if the current value of the hm(\"category\") is \"news\"\n//the route parameters in url with be like\n//  #!/?demo.category=news\n</pre>\n\n<h3>route path</h3>\n\n<p>\nRoute path is used to synchronize the value of the a model with the route path in url hash. You can define a route path like the following, you can define multiple route path. The example is <a target=\"_blank\" href=\"http://jsbin.com/uKozoXAM/3\">here</a>. \n</p>\n\n<pre prettyprint>\nhm.routePath(routePathPattern [, isDefaultPath ]);\n\n//the routePathPattern is like \"segment1/segment2/.../segmentN\"\n//each segment can be a normal string or a string starts with <code>:</code>, \n//in these case, the the string after <code>:</code> is a model path, \n//which means the value of the model should be embedded here.\n\n\n//If \"isDefaultPath\" is true, and the current path is empty, \n//hm.js will generate the path based on the state of the model\n\n//in the following, it create a default route\n\nhm.routePath(\"category/:demo.category\", true);\n</pre>\n\n<p>When the model defined in the route path changes, hm.js will try to find whether the pattern of route path match with the current route path, if it is matched,  then update the current route path with a new route path generated by the route path pattern and the updated value of the model.\n</p>\n", "signatures": []},
    {"name": "build app", "namespace": "bulit-in bindings.App", "shortDesc": "build app", "longDesc": "<p>To create create an app, we can use the following syntax.</p>\n\n<pre prettyprint>\n//register default App\nhm.App.add(applicationDefinition);\n</pre>\n\n\n<p><code>hm.App</code> is an constructor extended from <a href=\"#api.apiAction=view&api.selectedEntryName=Core.value+adapter?api.apiAction=view&api.selectedEntryName=Utilities.Class\">hm.Class</a>.  So you it can be sub-classed. For example, if you have reuse some components for all application definition, you can sub-class <code>hm.App</code> like the following.\n</p>\n\n<pre prettyprint>\nvar MyHouseApp = hm.App.extend(instanceMembers, staticMembers);\nMyHouseApp.add(applicationDefinition);\n\n</pre>\n<p>\n<code>hm.App</code> has implemented the default application definition as the following, all these definition can be inherited from your application definition. When we create our application definition, we just override some of the default implementation. The following is default application definition.\n</p>\n\n<pre prettyprint>\n{\n  load: function( $viewContainer, hmModelContainer, options ) {},\n\n  unload: function( $viewContainer ) {},\n\n  getInitialData: null, //function( modelContainer, options ) {}\n\n  loadModel: function( hmModelContainer, options ) {},\n\n  unloadModel: function( modelNamespace ) {},\n\n  loadView: function( $viewContainer, hmModelContainer ) {},\n\n  unloadView: function( $viewContainer ) {},\n\n  getTemplateOptions: function() {},\n\n  getModelNode: function( hmModelContainer ) {},\n\n  initialize: function( applicationDefinition) {},\n\n  instanceCount: 0,\n\n  uid: 0,\n\n  loadable: function () {return true;}\n\n  templateOptions: null,\n\n  subPath: null,\n\n  name: null\n}\n</pre>\n\n\n<h3>Example</h3>\n\n<h4>getInitialData</h4>\n<p>The follow is simple app, there is only one interesting method \"getInitialData\", which return the a data,  and we use declarative syntax to load an app instance.\n<p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/uZUnOho/1\">\nhm.App.add({\n    name: \"helloApp\",\n    getInitialData: function( modelContainer, options ) {\n      return { name: \"John\" };\n    }\n  });\n</pre>\n\n<pre prettyprint>\n&lt;script type=\"jsrender\" id=\"helloApp\"&gt;\n &lt;h1&gt;hello, {{:name}}&lt;/h1&gt;\n&lt;/script&gt;\n\n&lt;div app=\"demo|helloApp\"&gt;&lt;/div&gt;\n</pre>\n\n<p>\nWe can see that the bootstrapping process use lots default behaviour implemented by the above methods, such as add the data at a sub path \"helloApp\" of the to model container, \"demo\", render the mark-up using model \"demo.helloApp\" and template of id \"helloApp\", and wrap the mark-up under view container. All these behaviour are customizable.\n</p>\n\n<h4>Customize app instance with options</h4>\n<p>\nThe following example shows to to customize an app instance by using the options parameter, which follows the app name.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/obinoz/3\">\n  &lt;script type=\"jsrender\" id=\"helloApp\"&gt;\n    &lt;h1&gt;{{:greeting}}, {{:name}}&lt;/h1&gt;\n  &lt;/script&gt;\n\n&lt;div app=\"demo|helloApp,hi\"&gt;&lt;/div&gt;\n</pre>\n<pre prettyprint>\n \n  hm.App.add({\n    name: \"helloApp\",\n    getInitialData: function( modelContainer, options ) {\n      return { name: \"John\", greeting: options };\n    }\n  });\n</pre>\n\n<h4>Getting data asynchronously</h4>\n<p>In real application, the data should be from a service instead of hard-coded in the app definition, like previous examples. The following example use ajax to get data from service, and return a promise.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/fppz0c/preview\">\n  hm.App.add({\n    \n    name: \"helloApp\",\n    \n    getInitialData: function( modelContainer, options ) {\n      return $.getJSON(\"demo.json\");\n    }\n       \n  });\n</pre>\n\n<h4>Fetching app definition before bootstrapping</h4>\n\n<p>In the previous examples, the app definition is defined in the page statically. Hm.js also support to dynamically load app definition on the fly. In the following example, all assets of the application including app definition, the template and the data are loaded dynamically.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/icKQU9/preview\">\n\n &lt;div  app=\"demo|helloApp\"&gt;&lt;/div&gt;\n</pre>\n\n<h4>Customize how root model is build</h4>\n\n<p>\nIn the previous examples, they only take care how to fetch the data, and use the default <code>app.loadModel()</code> to build model with the data. The following example override loadModel(), and control both how to get data and how to build model with the data.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/4xYqyH/preview\">\n  hm.App.add({\n    name: \"helloApp\",    \n    loadModel: function (modelContainer, options) {\n      var modelNode = this.getModelNode(modelContainer);\n      return $.get(\"demo.json\").done(function (data) {\n        modelNode.set(data);\n      });\n    }       \n  });\n</pre>", "signatures": []},
    {"name": "activity expression", "namespace": "Unified Subscription.Subscription.Handler.handler expression", "shortDesc": "activity expression", "longDesc": "<p>Activity expression is combination of the names of common activity separated by space. If one activity does not exist , and it is in the middle of the expression, use \"_\" to replace, it is at tail position, simply leave it out. The following is the syntax of activity expression. .\n</p>\n\n<pre data-sub=\"prettyprint:_\">\nget set convert finalize initialize\n</pre>\n\n<p><strong>The activities in the expression is by the order of usage frequencies but not by the order when they are executed</strong>.  Because \"get\" activity and \"set\" activity are their most frequently used, so the they are at the beginning, and \"initialize\"  is least frequently used, so it is at the end.  There are two kind of activity expression, well-known activity expression and member activity expression</p>\n\n<h3>Well-known activity expression</h3>\n<p>\nWell-known activity expression is reference to well-known activity name. It start with prefix \"*\" like the following. Please note that if you want to use well-known activity expression, all activities in the expression must be well-known activities, and you must have have at least two of them. If you have only one well-know activities, it will be treated as <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Handler.handler+expression.workflow+expression\">workflow expression</a>\n</p>\n<pre prettyprint>\n//convert, finalize, initialize are not used\n\"*getTextValue *setNodeValue\" \n\n//convert, initialize are not used\n\"*getTextValue *setNodeValue _ *myFinalizer\" \n</pre>\n\n<h3>Member activity expression</h3>\n<p>\nMember activity are name with without \"*\" prefix. It is the method name of publisher or subscriber.The following is an example, the handler means call publisher.val() to get value x from publisher, then call subscriber.set(x) to set the value to subscriber.\n</p>\n\n<pre pettyprint>\nvar activityExpression = \"val set\";\n//\n//e.g\nhm(\"name\").sub($(\"#textBox\", \"change\", activityExpression);\n</pre>\n\n<p>\nSometimes, the method of publisher or subscriber has two parameter. For example, a jQuery support css method is like the following.\n</p>\n\n<pre prettyprint>\n//get a css property\nreturn $view.css(\"color\");\n//to set a css property\n$view.css(\"color\", value);\n</pre>\n\n<p>To support this scenario, we can use <code>memberName*firstParameterValue</code> like the following</p>\n\n<pre prettyprint>\n//handler expression\nvar activityExpression = \"get css*color\";\n//e.g\nhm(\"color\").sub($(\"#textBox\", \"init afterUpdate\", activityExpression);\n</pre>\n\n<h3>Examples</h3>\n\n\n<pre prettyprint preview=\"_|http://jsbin.com/xawub/1\">\n  &lt;div&gt;Your name:&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"name|val set\"  &gt;\n  \n  \n  &lt;div&gt;background color: (try type 'red', 'yellow\", '#eee')&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"color|val set\" !init=\"color|get val\"&gt;\n  \n  &lt;div !afterUpdate=\"message|get text\"\n       !init_afterUpdate=\"color|get css*background-color\"&gt;&lt;/div&gt;\n  \n  &lt;div log-panel&gt;&lt;/div&gt;\n</pre>\n\n<h3>Simplified member activity expression.</h3>\n<p>The member activity expression can be further simplified according to the following rule.</p>\n<table>\n<tr>\n<td>publisher</td>\n<td>subscriber</td>\n<td>default get activity</td>\n<td>default set activity</td>\n<td>full activity expression</td>\n<td>simplified activity expression</td>\n</tr>\n<tr>\n<td>view</td>\n<td>model</td>\n<td>N/A</td>\n<td>set</td>\n<td>val set</td>\n<td>val</td>\n</tr>\n<tr>\n<td>model</td>\n<td>view</td>\n<td>get</td>\n<td>N/A</td>\n<td>get html</td>\n<td>html</td>\n</tr>\n</table>\n<p>Using these rule, we can simplified the above example like the following.</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/ofedaz/2\">\n\n  &lt;div&gt;Your name:&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"name|val\"  &gt;\n  \n  \n  &lt;div&gt;background color: (try type 'red', 'yellow\", '#eee')&lt;/div&gt;\n    \n  &lt;input type=\"text\" $keyup=\"color|val\" !init=\"color|val\"&gt;\n  \n  &lt;div !afterUpdate=\"message|text\"\n       !init_afterUpdate=\"color|css*background-color\"&gt;&lt;/div&gt;\n  \n  &lt;div log-panel&gt;&lt;/div&gt;\n\n</pre>\n\n\n<h3>fakeGet Activity</h3>\n\n<p>\nIn some scenario, the subscriber does not care about what's the value of publisher, it just care about the event happens. For example, a model subscriber know how to change itself, when a button is clicked, so it does not need to get a value from the button. Another scenario is that, a view know how to change itself when a model is changed, it does not need to get a value from model. In these scenario, we can use <code>*fakeGet</code> activity. In following example, the model \"isHappy\" toggle itself, as long as a button is click, and the view toggle a class to itself, as long as the model is changed,  but it does not care about the value of the model.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/celob/1\">\n  &lt;!-- handler is *fakeGet toggle --&gt;\n  &lt;input type=\"button\" value=\"happy?\" \n    $click=\"isHappy|*fakeGet toggle\"&gt;\n     \n  &lt;!-- handler is *fakeGet toggleClass*happy --&gt;\n  &lt;p !afterUpdate=\"isHappy|*fakeGet toggleClass*happy\"&gt;\n    Hello world!\n  &lt;/p&gt;\n\n    &lt;div dump=\"isHappy\"&gt;&lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "path expression", "namespace": "Unified Subscription.Subscription.Handler.handler expression", "shortDesc": "path expression", "longDesc": "<p>\nPath expression allow us to reference a model function as handler, it starts with \"#\" sign and is followed by a model path. And the model path is a sub-path relative to the the subscriber if subscriber  is model, or a sub-path relative to the publisher if publisher is model node. If neither publisher nor subscriber is model, the path is treated as an absolute path. To avoid confusion,  you can use \"/\" to prefix that path, so it is always a absolute path.  Inside the handler, \"this\" refers to the subscriber, but not necessary handler itself.  Since it is inside of the model, it may be confused to treated as parent node,  be avoid the confusion, you can use \"e.subscriber\" instead of \"this\". The following is example:</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/celob/1\">\n\n&lt;body ns=\"myapp\"&gt;\n  &lt;div&gt;Your full name (first name, last name):&lt;/div&gt;\n  \n  &lt;input type=\"text\" $keyup=\"person|#..handlers.updatePerson\" &gt;\n\n  &lt;div dump=\"person\"&gt;\n    \n  &lt;/div&gt;\n\n&lt;/body&gt;\n</pre>\n\n<pre prettyprint>\n  var separator = /\\s*,\\s*/;\n  \n  hm(\"myapp\", {\n    person: {\n      firstName: \"\",\n      lastName: \"\"\n    },\n    handlers: {\n      updatePerson: function (e) {\n        var fullName = $.trim(e.publisher.val());\n        parts = fullName.split(separator);\n        \n        //here \"this\" refer to the subscriber,\n        //but not myapp.handlers        \n        //var subscriber = this; \n        \n        //to avoid confusion, you can also use e.subscribe\n        var subscriber = e.subscriber\n        \n        var person = subscriber;        \n        subscriber.set(\"firstName\", parts[0] || \"\");\n        subscriber.set(\"lastName\", parts[1] || \"\");\n      }\n    }    \n  });  \n</pre>\n\n<h3>Implicit path expression</h3>\n\n<p>If you just want to use model function as handler, and does not have non-function model node as subscriber,  you can use the model function as subscriber, and omit the handler like the following example.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/IyePoGu/2\">\n\n&lt;body ns=\"myapp\"&gt;\n  &lt;div&gt;Your full name (first name, last name):&lt;/div&gt;\n  \n  &lt;input type=\"text\" $keyup=\"handlers.updatePerson\" &gt;\n\n  &lt;div dump=\"person\"&gt;\n    \n  &lt;/div&gt;\n\n&lt;/body&gt;\n</pre>\n\n<pre prettyprint>\n var separator = /\\s*,\\s*/;\n  \n  hm(\"myapp\", {\n    person: {\n      firstName: \"\",\n      lastName: \"\"\n    },\n    handlers: {\n      updatePerson: function (e) {\n        var fullName = $.trim(e.publisher.val());\n        parts = fullName.split(separator);\n        \n        //here \"this\" refer to the subscriber,\n        //but not myapp.handlers        \n        var subscriber = this; \n        var person = subscriber.cd(\"...person\");        \n        \n        person.set(\"firstName\", parts[0] || \"\");\n        person.set(\"lastName\", parts[1] || \"\");        \n      }\n    }\n    \n  });  \n</pre>", "signatures": []},
    {"name": "workflow expression", "namespace": "Unified Subscription.Subscription.Handler.handler expression", "shortDesc": "workflow expression", "longDesc": "<p>\nA workflow expression starts with prefix \"*\" and is followed by a name of <a href=\"#!/?api.apiAction=view&api.selectedEntryName=Unified+Subscription.Subscription.Workflow\">workflow</a>. Some workflow needs a initialize options like the following.\n</p>\n\n<pre prettyprint>\n&lt;div !events=\"path|*workflowName|options\" $events=\"path|*workflowName|options\" &gt;\n</pre>\n\n<p>\nThe following example, shows how to reference workflow in declarative subscriptions.\n</p>\n<pre prettyprint preview=\"_|http://jsbin.com/ogUxIVE/2\">\n\n&lt;div&gt;You've clicked &lt;span text=\"clickCount\"&gt;&lt;/span&gt; time&lt;span !init_afterupdate=\"clickCount|*show|&gt;1\"&gt;s&lt;/span&gt;&lt;/div&gt;\n\n&lt;button $click=\"clickCount|*++\" !afterUpdate=\"clickCount|*enable|&lt;3\"&gt;Click me\n&lt;/button&gt;\n\n&lt;div !init_afterUpdate=\"clickCount|*show|&gt;=3\"&gt;\n\tThat's too many clicks! Please stop before you wear out your fingers.\n\t&lt;button $click=\"clickCount|*0\"&gt;Reset clicks&lt;/button&gt;\n&lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "callbacks", "namespace": "Node", "shortDesc": "callbacks", "longDesc": "", "signatures": []},
    {"name": "dynamic binding", "namespace": "Unified Subscription.Subscription.Declarative.binding", "shortDesc": "dynamic binding", "longDesc": "<p>Dynamic binding does not contain any declarative subscription. Instead it is a function reference. When a dynamic binding is found in markup, this function will be called. Inside the function, we can create subscription programmatically or attached some behavior to DOM element or model nodes. The following is a comparison of two kind of binding\n</p>\n\n<table>\n<tr><td></td><td>composite binding</td><td>dynamic binding</td></tr>\n<tr><td>definition</td><td>string</td><td>function</td></tr>\n<tr><td>can nest other binding</td><td>Yes</td><td>No</td></tr>\n</table>\n\n<p>The following is simple dynamic binding definition and its reference.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/jonuv/1\">\n\nhm.binding(\"dynamicBinding\",  function( elem, path, context, options ) {\n    hm.log(\"dynamicBinding is called, path:\" + path + \n        \" , options:\" + options);\n  };\n</pre>\n\n<pre prettyprint>\n&lt;div dynamic-binding=\"path1|option1\" debug&gt;&lt;/div&gt;\n&lt;div log-panel&gt;&lt;/div&gt;\n</pre>\n\n<p>\nThe elem parameter is the contextual DOM element. The path is model path of the binding.\n</p>\n\n<p>\nThe <code>context</code> parameter can be used to create subscriptions programmatically. It has the following methods:\n</p>\n\n<pre prettyprint>\ncontext.appendSub( subscriber, publisher, eventTypes, handler, options, \n                     delegate ) ;\ncontext.prependSub( subscriber, publisher, eventTypes, handler, options, \n                     delegate );\ncontext.clearSubs();\n</pre>\n\n<p>\nThere are three stage In the process of importing declaration an element. The first one is the parsing stage. In this stage,  hm.js create a subscription list for the element, and a list of dynamic binding list, hm.js push the declarative subscription object into the subscription list, and push the dynamic binding function and arguments (elem, path, context, options) into the dynamic binding list. </p>\n\n<p>The second stage is  dynamic binding invocation stage. In this stage, hm.js call each binding function with the arguments. In side these function, we can use the method shown above to modify the subscription list. The <code>context.prependSub</code> method can prepend a subscription into the list,  the <code>context.appendSub</code> can append a subscription into the list. The <code>context.clearSubs</code> can empty the list.\n</p>\n\n<p>\nThe third stage is subscription creation stage. In this stage, hm.js create subscription defined in the subscription list.\n</p>\n\n<p>In the following, let's take a look how the dynamic binding \"logPanel\"  is implemented. This binding can be used for debugging. Its usage and definition are as following:\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/tuzur/1\">\n\n&lt;div log-panel debug &gt;&lt;/div&gt;\n</pre>\n\n<pre prettyprint>\nhm.binding(\"logPanel\", function (elem, path, context, options) {\n  var $elem = $(elem),\n    $ol = $elem.is(\"ol\") ? $elem : $(\"&lt;ol style='font-family: monospace, serif' /&gt;\").appendTo($elem),\n    ol = $ol[0];\n\n context.appendSub(ol, \"*log\", \"init\", function (e) {\n    var allLogs = e.publisher.get();\n    for (var i = 0; i & lt; allLogs.length; i++) {\n      $ol.append(\"&lt;li&gt;\" + allLogs[i] + \"&lt;/li&gt;\");\n    }\n  });\n\n  context.appendSub(ol, \"*log\", \"afterCreate.1\", function (e) {\n    $ol.append(\"&lt;li&gt;\" + e.originalPublisher.raw() + \"&lt;/li&gt;\");\n  });\n\n  context.appendSub(ol, \"*log\", \"afterCreate\", function (e) {\n    $ol.empty();\n  });\n});\n</pre>\n\n<h3>Special dynamic binding: run-first, run-last</h3>\n<p>We can use dynamic binding to create subscription programmatically or attach other behavior to the DOM element. It is the dynamic binding is reusable for many DOM element,  that is good. If the dynamic binding is just for a specific DOM element, it is easily create too many dynamic binding. To avoid this, we can use the two special dynamic binding <code>run-first</code>, and <code>run-last</code>. </p>\n<p>\nThese two binding can run a function defined in a model node. In the stage of dynamic binding execution,  before other dynamic binding function is executed, the <code>run-first</code> binding function will be executed first. In turn, this function will execute a node function,  <code>run-last</code> binding will be executed last, in turn it will execute a node function. In the following example, <code>run-first</code> create a subscription by <strong>append</strong> a subscription,  then the demo binding run, and the <code>run-last</code> will run last, it create a subscription by <strong>prepending</strong> a subscription. Because the last subscription is prepended, it will be created first.\n</p>\n\n<pre prettyprint preview=\"_|http://jsbin.com/vafer/1\">\n  &lt;input val=\"name\"&gt;\n  \n  &lt;div run-first=\"subscribeMessageChange \"\n       run-last=\"confirmMessageUpdate\"\n       demo\n       debug&gt;\n  &lt;/div&gt;\n  \n  &lt;div log-panel&gt;&lt;/div&gt;\n</pre>\n\n<pre prettyprint>\n   hm.binding(\"demo\", function (elem, path, context, options) {        \n    hm.log(\"demo binding is running\");       \n  });\n    \n  var myapp = hm(\"myapp\", { \n    \n    name: \"John\",      \n    message: function () {      \n      var name = this.get(\"name\");    \n      return name ? \"hello, \" + name : \"\";    \n  \n    },\n    \n    subscribeMessageChange: function( elem, path, context, options ) {    \n      hm.log(\"subscribeMessageChange is 'run-first', appending subscription\");\n      context.appendSub(      \n        elem,       \n        myapp.getPath(\"message\"), \n        \"init afterUpdate\",       \n        \"html\");          \n    },\n    \n    confirmMessageUpdate: function (elem, path, context, options) {          \n      hm.log(\"confirmMessageUpdate is 'run-last', prepending subscription\");      \n      context.prependSub(      \n        elem,       \n        myapp.getPath(\"message\"), \n        \"afterUpdate\",        \n        function (e) {         \n          var yes = confirm(\"do you want to update message\");         \n          if (!yes) {            \n            e.stopImmediatePropagation();         \n          }     \n        });            \n    }    \n  });\n</pre>", "signatures": []},
    {"name": "binding", "namespace": "Unified Subscription.Subscription.Declarative", "shortDesc": "binding", "longDesc": "<p>Instead of using $events and !event attributes, we can use binding attribute to create subscriptions and or attached some behavior to the DOM element or model nodes. The advantage of using binding attribute is that markup is simplified, it is more expressive and reusable.\n\nThere two kind of binding, composite binding, and dynamic binding.  We use the same syntax to apply it to a DOM element . In the following, we use attribute <code>my-binding</code> or <code>data-my-binding</code> to reference binding <code>myBinding</code>.\n</p>\n\n<pre prettyprint>\n&lt;!-- if the binding name is \"myBinding\" --&gt;\n&lt;div my-binding=\"path|options\"&gt;&lt;/div&gt;\n&lt;div data-my-binding=\"path|options\"&gt;&lt;/div&gt;\n\n&lt;!-- if binding does not need a path argument, use the following --&gt;\n&lt;div my-binding&gt;&lt;/div&gt;\n&lt;div data-my-binding&gt;&lt;/div&gt;\n</pre>", "signatures": []},
    {"name": "External Template", "namespace": "Template", "shortDesc": "External Template", "longDesc": "<p>To load external template, firstly we need to convert a template id into the url of template file. If template id ends with \".html\",   the id is the url of the external file. If the id does not end with \".html\" extension, the url of the external file is the top level template id followed by \".html\". The details is as following.</p>\n\n<table>\n<tr><td>template id pattern</td><td>xxx</td><td>xxx.yyy</td></tr>\n<tr><td>no \".html\" suffix</td>\n<td>xxx ==&gt;  ~/xxx.html</td>\n<td>\nxxx.yyy ==&gt;  ~/xxx.html\n</td>\n</tr>\n<tr>\n  <td>\".html\" suffix</td>\n<td>xxx.html  ==&gt;  ~/xxx.html</td>\n<td>\nxxx.yyy.html  ==&gt;  ~/xxx.yyy.html\n</td>\n</tr>\n</table>\n\n</p><code>~</code> is the baseUrl  of resource folder. The default baseUrl is \"\" which is current folder of the page. It can be changed like the following. The baseUrl is relative to the url of current page.\n</p>\n\n\n<pre prettyprint>\nhm.loader.baseUrl( baseUrl );\n</pre>\n\n<p>There are two way to define template.</p>\n\n<h3>One file one template</h3>\n\n<p>In this case, one template file define only one template.  In the following example, the page is composed by multiple templates, each template is contained in a separate html file. \n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/rRfQIp/preview\">\n &lt;body tmpl=\"/|demo.html\"&gt;\n &lt;/body&gt;\n</pre>\n\n<pre prettyprint>\n&lt;!-- content of demo.html\" --&gt;\n &lt;div&gt;\n    &lt;br include=\"/|header.html\"/&gt;\n    &lt;br include=\"/|contacts.html\"/&gt;\n    &lt;br include=\"/|footer.html\"/&gt;\n&lt;/div&gt;\n</pre>\n\n\n<h3>One file multiple templates</h3>\n\n<p>In this case, a file contains multiple templates. Each template is wrapped with &lt;script&gt; tag. If you have an external template \"A\" cause a corresponding template file to be loaded, all the templates in the file are loaded. If you have another template \"B\" which is defined this template file,  it is not required to load the template file again to render template \"B\".\n</p>\n\n<p>Normally, when decided what templates should be put into a file, we normally put the root template and its child templates together. So when the root template is loaded, all its child templates are loaded.In the following we use one file hold multiple template.\n</p>\n\n<pre prettyprint preview=\"/|http://embed.plnkr.co/bvJ5yJ/preview\">\n  &lt;body tmpl=\"/|demo\"&gt;\n    \n  &lt;/body&gt;\n</pre>\n\n<pre prettyprint>\n&lt;!-- content of demo.html\" --&gt;\n&lt;script type=\"jsrender\" id=\"demo\"&gt;\n &lt;div&gt;\n    &lt;br include=\"/|header\"/&gt;\n    &lt;br include=\"/|contacts\"/&gt;\n    &lt;br include=\"/|footer\"/&gt;\n&lt;/div&gt;\n&lt;/script&gt;\n\n&lt;script type=\"jsrender\" id=\"header\"&gt;\n  &lt;header&gt;\n    &lt;h1&gt;Demo Site&lt;/h1&gt;\n  &lt;/header&gt;\n&lt;/script&gt;\n\n&lt;script type=\"jsrender\" id=\"contacts\"&gt;\n&lt;section&gt;\n    &lt;table&gt;\n      &lt;tr&gt;\n        &lt;td&gt;first name&lt;/td&gt;\n        &lt;td&gt;last name&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tbody tmpl=\"app.contacts|contacts.rows\"&gt;\n\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n  &lt;/section&gt;\n&lt;/script&gt;\n\n&lt;script type=\"jsrender\" id=\"contacts.rows\"&gt;\n &lt;tr&gt;\n    &lt;td&gt;\n      {{:firstName}}\n    &lt;/td&gt;\n    &lt;td&gt;\n      {{:lastName}}\n    &lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/script&gt;\n\n&lt;script type=\"jsrender\" id=\"footer\"&gt;\n  &lt;footer&gt;\n    &lt;address&gt;Contact: &lt;a href=\"mailto:wm@example.com\"&gt;Webmaster&lt;/a&gt;&lt;/address&gt;\n  &lt;/footer&gt;\n&lt;/script&gt;\n</pre>\n\n<p>If the default mapping between template id and the url of template file is implemented by the following function,  you can override it to implement your own mapping.</p>\n\n<pre prettyprint>\nhm.template.templateIdToUrl = function (templateId) {\n   //return an url\n};\n</pre>", "signatures": []},
    {"name": "loader", "namespace": "", "shortDesc": "hm.loader", "longDesc": "<p>\nHm.js use <code>hm.loader</code> to dynamically load various assets of an html application, such as JavaScript, CSS, template, data and more. It is a general purpose loader for browser, you can use it it independently without using features of hm.js like model, subscriptions. hm.loader support the following features\n</p>\n\n<ol>\n<li>extensible loader for existing and new types of asset</li>\n<li>dynamically load assets but play well assets loaded statically.</li>\n<li>support assets dependencies and ensure all assets are fetched and processed correctly</li>\n<li>support parallel assets fetching asynchronously while ensure the correct dependencies loading</li>\n<li>support serial asset fetching and processing if necessary</li>\n<li>support url rules for asset</li>\n<li>support dependencies urls for asset</li>\n<li>support asset unloading to free up resource used in browser</li>\n<li>support loading cross-site assets</li>\n</ol>\n\n\n<h3>What is client side asset</h3>\n\n<p>\nFrom the perspective of <code>hm.loader</code>,  asset, resource, file  are interchangeable concept. Basically asset is downloadable content, which can be consumed in browser. It does not limited to JavaScript, CSS, it can be client side template, text file, JSON data, coffee script. An assets has the following attributes\n</p>\n\n<ol>\n<li>url\n<p>Every asset has an url</p>\n</li>\n\n<li>\n  cross-domain vs same-domain\n<p>\nDepending on what url of an asset, the asset may be cross-domain or same-domain relative to the current page, which may implies security restriction, and we need to use different mechanism to load them.\n</p>\n</li>\n\n<li>\ndependencies\n<p>Assets usually work together. If asset A depends on another B, so that asset B must be loaded before loading asset A</p>.\n</li>\n\n<li>\nprocessing \n<p>\nCSS file, JavaScript file, image file, coffee script file, template file, ajax service all return text content. Different processing task need to be used to process them differently in order to make them useful to the html application. \n</p>\n</li>\n\n</ol>\n\n", "signatures": []},
    {"name": "load asset", "namespace": "loader", "shortDesc": "load asset", "longDesc": "<h3>asset id</h3>\n<p>Asset id follow the following pattern</p>\n\n<pre prettyprint>\nvar assetId = \"xxxx.loaderName\";\n\n//for example\n//the following asset id use \"js\" loader\nvar assetId1 = \"http://mysite.com/js/main.js\";\nvar assetId2 = \"main.js\";\n\n//the following asset use \"css\" loader\nvar assetId3 = \"main.css\";\n\n//the following asset use \"template\" loader\nvar assetId4 = \"customer.template\";\n\n</pre>\n\n<p>hm.loader use different loaders to load different assets. The loader name is the extension name in asset id. </p>\n\n<h3>assets expression</h3>\n<p>Normally an asset expression is just a single asset id in string. If you want to load multiple assets in one method call, you can use assets expression. The implementation of assets expression is different\n</p>\n\n<h4>string assets expression</h4>\n<p>\nThis expression is like <code>\"id1, id2, id3, ..., idn\"</code> . Using this expression, we can load multiple assets in parallel, the speed is fast, because we don't care about the dependencies between assets. Because of the network and asynchronous loading, there is no guarantee that the hm.js complete the asset loading in the order specified in the expression.\n</p>\n\n<h4>array asset expression</h4>\n\n<p>\nThis expression is like <code>[id1, id2, id3, ..., idn]</code>. Using this expression, we can load multiple assets in serial. This means after asset id1 is loaded, then load asset id2, after id2 is loaded, then load id2, and so on. This guarantee that hm.loader complete the asset loading in the order specified in the expression.\n</p>\n\n<h4>composite asset expression</h4>\n\n<p>\nThis expression is variation of array assets expression. It is like <code>[assetExpression1, assetExpression2, ..., assetExpressionN]</code>.  Each items in the array is asset expression. It is the combination of both string asset expression and array asset expression\n</p>\n\n<h3>load asset</h3>\n\n<p>The basic syntax to load assets is as following.</p>\n\n<pre prettyprint>\nhm.loader.load([ holdReady,] assetExpression [, inferDependenciesFromIdOrder] );\n//holdReady is false by default\n//inferDependenciesFromIdOrderis false by default, \n//it is only useful when assetExpression is in string asset expression format\n\n//e.g\nhm.load.load(\"main.js\");\nhm.load.load(\"main.js\", true);\nhm.loader.load(true, \"main.js\");\nhm.loader.load(true, \"main.js\", true);\n</pre>\n\n<h4>load single asset</h4>\n\n<p>The following example load a single assets only.</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/HhJGISOlriWhOn36rdLv/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"greeting.js\");\n\n//content of greeting.js\n$(\"body\").append(\"&lt;h1&gt;Hello world&lt;/h1&gt;\");\n</pre>\n\n<h4>holdReady</h4>\n<p>A very common pattern in using jQuery is ready function. If you want to load all your assets first before firing your ready function, you can use <code>holdReady</code> to load your assets. The following example shows this.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/b2jUpfxCQE6tewnmqcMB/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\n$(function () { \n   $(\"body\").append(greeting);  \n});\n\nhm.loader.load(true/* holdReady */, \"greeting.js\");\n\n$(function () {\n   $(greeting).css(\"color\", \"red\").appendTo(\"body\");  \n});\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n\n<h4>inferDependenciesFromIdOrder</h4>\n\n<p>In the following example, the asset expression is string asset expression,  the assets defined in the expression are fetched in parallel, so that the order when the fetches are finished is not guaranteed to be the order when the fetches are started.  The <code>inferDependenciesFromIdOrder</code> is used to ensure that the asset are \"compiled\" into browser by the order they defined in the asset expression. Without the <code>inferDependenciesFromIdOrder</code> flag, the example may or may not work in random fashion. With it, the example is guaranteed to work.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/MqDHWK/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"greeting.js, main.js\", true);\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n\n//main.js\n$(\"body\").append(greeting);\n</pre>\n\n<h4>define dependencies in consumer using <code>hm.loader.depend</code></h4>\n\n<p>In the previous example, the dependencies between main.js and greeting.js is implicit. In these example, the dependencies is explicitly defined using <code>hm.loader.depend</code> method, so that \"main.js\" depends on \"greeting.js\". Because of explicit dependencies,  loading \"main.js\" will automatically  load \"greeting.js\".\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/CjUxcS/preview\">\n//hm.loader.depend(assetId, assetExpression);\nhm.loader.depend(\"main.js\", \"greeting.js\");\n\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.depend(\"main.js\", \"greeting.js\");\nhm.loader.load(\"main.js\");\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n\n//main.js\n$(\"body\").append(greeting);\n</pre>\n\n<h4>define dependencies in provider using annotation</h4>\n\n<p>\nIn the previous example,  we explicitly define dependencies programmatically in the <strong>consumer</strong>'s code. In this example, we explicitly define dependencies declarative without using code using annotation in <strong>provider</strong>'s code.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/h3DW9d/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"main.js\");\n\n//main.js\n//&lt;@depend&gt;greeting.js&lt;/@depend&gt;\n$(\"body\").append(greeting);\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n\n<h4>define dependencies in provider using <code>hm.loader.define</code></h4>\n\n<p>\nThe previous example depend to inspect the content of the provider source file, so it needs to be in the same domain or CROSS-ORIGIN-RESHOURCE-SHARING needs to be supported. If not, we need to specify dependencies programmatically in <strong>provider</strong>'s source file like the following.\n</p>\n\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/2QWrj4/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"main.js\");\n\n//main.js\nhm.loader.define(\"main.js\", \"greeting.js\", function () {\n  $(\"body\").append(greeting);  \n});\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n\n<h4>dynamically load asset which has been statically loaded in its own file</h4>\n\n<p>\nFor performance reason, sometimes we need statically import asset using &lt;script&gt; or &lt;link &gt; tag. If an asset has been statically imported,  when the same asset is to be loaded dynamically again, hm.loader know that it has been imported, and will now load it again. In the following example, \"greeting.js\" has been statically imported. So hm.loader will not load it again, and this can be verified in the network traffic.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/tl6McW/preview\">\n//in html page\n&lt;script src=\"greeting.js\"&gt;&lt;/script&gt;\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"main.js\");\n\n//main.js\nhm.loader.define(\"main.js\", \"greeting.js\", function () {\n  $(\"body\").append(greeting);  \n});\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n\n<h4>dynamically load asset which has been statically loaded in concatenated  file</h4>\n\n<p>\nIn the following example, we concatenate \"greeting.js\" and \"script.js\" together to save one route trip to be server, but code in \"greeting.js\" need to be wrapped with <code>hm.loader.define</code> method.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/Qxc4J0/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.define(\"greeting.js\", function () {\n window.greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n});\n  \n\nhm.loader.load(\"main.js\");\n\n//main.js\nhm.loader.define(\"main.js\", \"greeting.js\", function () {\n  $(\"body\").append(greeting);  \n});\n</pre>\n\n<h4>asset package</h4>\n\n<p>In the following, we package several asset files into a package with a asset id \"main.pack\". A \"pack\" asset is simply a container of one or more assets, its content is defined <code>hm.loader.depend</code>\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/PapPxy/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.depend(\"main.pack\", \"main.js, greeting.js, main.css\");\n\nhm.loader.load(\"main.pack\");\n\n//main.js\n//&lt;@depend&gt;greeting.js&lt;/@depend&gt;\n$(\"body\").append(greeting);\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n<h4>load a asset multiple times</h4>\n\n<p>\nIf an asset is dynamically required or loaded by more than once, it will be actually loaded only once. In the following example, \"greeting.js\" is required by \"main.js\", and it is also dynamically loaded in \"script.js\". But it will be loaded once.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/6C6tksAesFA33TEGg63f/preview\">\n//in html page\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n\n//in script.js\nhm.loader.load(\"greeting.js\");\nhm.loader.load(\"main.js\");\n\n//in main.js\n//&lt;@depend&gt;greeting.js&lt;/@depend&gt;\n$(\"body\").append(greeting);\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n$(\"body\").append(\"&lt;h2&gt;gretting.js has been loaded&lt;/h2&gt;\")\n</pre>\n\n<h4>cached resource</h4>\n\n<p>\nOne of the problem of loading asset dynamically is that, it use lots network round trips. One of the solution is use cache. A common implementation of caching is cache asset for infinite duration and add a version number to asset url, like the following.\n</p>\n\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/v0HKUO/preview\">\n//in html page\n&lt;script&gt;\n //by default key is \"v\"\n// hm.loader.hash(version);\n //hm.loader.hash(\"key\", version);  \n  hm.loader.hash(2);\n  hm.loader.load(\"main.js\");\n&lt;/script&gt;\n\n//in main.js\n//&lt;@depend&gt;greeting.js&lt;/@depend&gt;\n$(\"body\").append(greeting);\n\n//greeting.js\nvar greeting = \"&lt;h1&gt;Hello world&lt;/h1&gt;\";\n</pre>\n<p>We can see that the url is appended with \"?v=2\"\n<image src=\"http://snag.gy/UHQcq.jpg\">\n\n<h4>local dependency injection</h4>\n<p>\nNormally, hm.loader depend a module modify global state as a way to inject dependencies that other modules depends. The reason is that other module does not need to be modified to register itself as dependencies. However, hm.js also partially support local dependencies injection. By default, the <code>hm.loader.load</code> method returns promise which will resolve a value. In other to resolve a value, we need to use an other loader <code>jsl</code> like the following example:\n</p>\n\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/1rlIec/preview\">\n//in html page\n&lt;script&gt;\n  hm.loader.load(\"greeting.jsl\").done(function (greeting) {\n    $(\"body\").append(greeting);  \n  });\n&lt;/script&gt;\n\n//greeting.js\n\"&lt;h1&gt;Hello world&lt;/h1&gt;\"; \n</pre>\n", "signatures": []},
    {"name": "unload asset", "namespace": "loader", "shortDesc": "unload asset", "longDesc": "<p>\nNot only can <code>hm.loader</code> support loading,  it also supports unloading. Each an asset is loaded with <code>hm.loader</code>, the reference counts of the asset and its dependencies will be incremented. Each time an asset is unloaded with, the reference counts of the asset and its dependencies will be decremented. If reference count an asset is 0, then the asset will be really unloaded.\n</p>\n\n<p>\nThe unloading logic of an JavaScript file, can be defined using annotation or using api <code>hm.loader.define</code>, or it can be customized using <code>loader.buildUnload</code>\n</p>\n\n<h3>Define unload using annotation</h3>\n<p>\nIn the following example, the unloading is defined using annotation.\n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/uSWSzq/preview\">\n//index.html \n  &lt;script&gt;\n    $(function () {\n      \n      \n      $(\"#btnLoad\").click(function () {\n        hm.loader.load(\"main.js\");\n        \n        });\n      \n       $(\"#btnUnload\").click(function () {\n        hm.loader.unload(\"main.js\");\n        \n        });\n    });    \n    &lt;/script&gt;\n</pre>\n\n<pre prettyprint>\n//main.js\n//&lt;@depend&gt;greeting.js, greeting.css&lt;/@depend&gt;\n//&lt;@unload&gt;$(\"#container\").empty();&lt;/@unload&gt;\n$(\"#container\").append(greeting);\n</pre>\n\n<h3>Define unload using hm.loader.define</h3>\n<p>\nYou can use <code>hm.loader.define</code> to define an asset with unloading functions like the following example. \n</p>\n\n<pre prettyprint preview=\"_|http://embed.plnkr.co/3cw9dW/preview\">\n//index.html is same as previous example \n\n//main.js\nhm.loader.define(\"main.js\", \"greeting.js, greeting.css\", \n//definition function\nfunction () {\n   $(\"#container\").append(greeting);  \n}, \n//unloading function\nfunction () {\n  $(\"#container\").empty();\n});\n</pre>\n\n<h3>Define unload using <code>loader.unload</code></h3>\n<p>If you have one kind of assets which share the same unloading logic, you can use the loader.unload method to unload the assets</p>\n\n<pre prettyprint preview=\"_|../samples/loader.unload/index.html\">\n\n//loader/mod.js\n(function() {\n  hm.loader( \"mod\", \"js\", {\n    load: {\n      compile: function( assetId, sourceCode ) {\n        var init = eval( sourceCode );\n        init( assetId );\n      }\n    },\n    unload: function( assetId ) {\n      $( document.getElementById( assetId ) ).remove();\n    }\n  } );\n})();\n\n//js/hello.js\n(function( containerId ) {\n  var message = \"&lt;h1&gt;hello world!&lt;/h1&gt;\";\n  var content = $( \"&lt;div id='\" + containerId + \"'&gt;&lt;/div&gt;\" ).append( message );\n  $( \"body\" ).append( content );\n});\n\n//index.html\n    $( function() {\n      $( \"#btnLoad\" ).click( function() {\n        hm.loader.load( \"js/hello.mod\" );\n\n      } );\n      $( \"#btnUnload\" ).click( function() {\n        hm.loader.unload( \"js/hello.mod\" );\n\n      } );\n    } );\n</pre>\n\n<h3>Define unload using <code>loader.load.buildUnload</code></h3>\n\n<p>\nSimilar to the <code>loader.unload</code>, <code>loader.load.buildUnload</code> can also create unload logics. However, the unload logics is parsed from source file.\n</p>\n\n<pre prettyprint preview=\"_|../samples/loader.load.buildUnload/index.html\">\n\n//loader/mod.js\n(function() {\n  var rUnload = /&lt;unload1&gt;([\\w\\W]+?)&lt;\\/unload1&gt;/i;\n  hm.loader( \"mod\", \"js\", {\n    load: {\n      buildUnload: function( sourceCode, assetId ) {\n        var unloadStatements = rUnload.exec( sourceCode );\n        return unloadStatements &&\n               unloadStatements[1] &&\n               new Function( unloadStatements[1] );\n      }\n    }\n  } );\n})();\n\n//js/main.js\n//&lt;unload1&gt;$(\"#container\").empty();&lt;/unload1&gt;\n$(\"#container\").append(\"&lt;h1&gt;hello world!&lt;/h1&gt;\");\n\n\n//index.html\n      $( \"#btnLoad\" ).click( function() {\n        hm.loader.load( \"js/hello.mod\" );\n\n      } );\n      $( \"#btnUnload\" ).click( function() {\n        hm.loader.unload( \"js/hello.mod\" );\n\n      } );\n    } );\n</pre>", "signatures": []},
    {"name": "create loader", "namespace": "loader", "shortDesc": "create loader", "longDesc": "<p>The following is skeleton of a loader. A loader has a couple of member. Only the the load method is required, other members are optional. A loader can be also defined with base loader whose members will be inherited and extended. \n</p>\n\n<pre prettyprint>\n\nhm.loader(\"myLoader\", \"baseLoader\", {\n //required\n load: function () { assetId) {},\n //load: \"nameOfCommonLoadTask\",\n\n //optional, to calculate the url of and asset\n url: function (assetId) {},\n //url: \"nameofCommonUrlTask\"\n\n //optional, return the dependency of an asset, \n //they must be loaded before assetId\n depend: function (assetId) {},\n //depend: \"nameOfCommonRequireTask\"\n\n //optional, to unload asset\n unload: function (assetId) {},\n  //load: \"nameOfCommonUnloadTask\"\n\n //optional, it is used when hm.loader try to convert the assetId to an url\n fileExt: \"extension\"\n\n});\n</pre>\n\n<h3>loader.load(assetId)  (mandatory)</h3>\n\n<p>This method has load the asset that associated with an asset id, because the loading is asynchronous, it return a promise. When the promise is finished, it resolved a value.\n</p>\n<h3>loader.url(assetId)  (optional)</h3>\n\n<p>\nThis method convert an asset id into the url of the asset. By default, the id is url of asset, but if you organize your asset in some convention, your might use a shorter id and this method to convert an id into a full url.\n</p>\n\n\n<h3>loader.depend(assetId)  (optional)</h3>\n\n<p>\nThis method return the dependencies of an asset. The dependencies can be documented in multiple way. This is one of them. If you asset can be implied from assetId, you can implement this method.\n</p>\n\n<h3>loader.unload(assetId)  (optional)</h3>\n\n<p>\n<code>hm.loader</code> optionally support the unloading of an asset. The method is delegated to the unload method of actual loader.\n</p>\n\n<h2>common loader methods</h2>\n\n<p>\nA method of the a loader can be a function like above or it can be a name of common loader methods. There a couple common methods like below.\n</p>\n\n<image src=\"http://snag.gy/REZRp.jpg\">\n\n<p>\nYou can add your common loader method. The following add a common loader method of load named \"myLoadMethod\".\n</p>\n\n<pre prettyprint>\nhm.loader.methods.load.myLoadMethod = function (assetId) {};\n</pre>\n", "signatures": []},
    {"name": "load filters", "namespace": "loader.create loader", "shortDesc": "load filters", "longDesc": "<p>The load method is the most complex member of an asset loader. It is the only required member of an asset loader. You can implement the method directly. You can implement the load filters which are smaller unit of the loading process. Because different loader has different attributes,  the loading process can be broken down into smaller units to handle each attribute, here these unit are called filters.  The following is a high level breakdown of the load process.</p>\n\n<ol>\n<li>Detect if the asset has been statically loaded, if true, stop. Static loading means loading asset using embedded tag like &lt;link&gt; &lt;script &gt; to load css, JavaScript. Dynamic loading means loading asset use hm.loader. <code>hm.loader</code> can work with statically loading together to provide the best performance to user.\n</li>\n\n<li>\nCheck if the asset is in the same domain of the page, or if it is cross-site asset. If it is cross-site asset, load asset using cross-site loading method. Done.\n</li>\n\n<li>\nCheck if loader implement compile method, if not implemented load asset using cross-site loading method. Done\n</li>\n\n<li>\nDownload the source code or content of the asset, this is asynchronous process, it can be ajax call, it can be websocket.\n</li>\n\n<li>\nExtract the dependencies information of the asset embedded in the source code if they are available. \nDocumenting dependences information in source code is only one means, but there are other means.</li>\n\n\n<li>\nCheck if the dependencies of the asset exists. If exists, load these dependent assets first, then continue the next step.\n</li>\n\n<li>\nCall loader's compile method to compile source code to make the source code available at client side. The compile method is different from loader to loader. The default behavior of compile method of JavaScript loader is global eval. If the loader is template loader or css loader, the behavior should be different.\n</li>\n\n</ol>\n\n<p>\nEach task in the above process is implemented by a filter. The following is skeleton of the load method which is implemented by several filters.\n</p>\n\n<pre prettyprint>\nloader.load = {\n\n  //required\n  staticLoaded: function (assetId) {\n   //return true or false;\n   },\n\n  //optional, default is \"getTextByAjax\"\n  getSource: function (asset Id) {\n     //return a promise which will resolve some text \n   },\n\n  //optional, default is \"globalEval\"\n  compile: function (assetId, sourceCode)  {\n     //return any value\n    },\n\n  //optional, default is \"getScript\"\n   crossSiteLoad: function (assetId) {\n      //return a promise which resolve nothing\n    },\n\n  //optional, default is \"parseDependTag\"\n   buildUnload: function (sourceCode, assetId) {\n       //return  a function which can used to unload the asset\n    },\n\n  //optional, default is \"parseUnloadTag\"\n   buildDependencies: function (assetId, sourceCode) {\n     //return a function which can used to build the \n    //dependencies of an asset\n  }\n\n};\n</pre>\n\n<p>\nA load filter can be in a function or it can the name of common load filters. <code>hm.loader</code> already provide a couple of common load filters like below.\n</p>\n\n<image src=\"http://snag.gy/OXaN6.jpg\">\n\n\n<p>\nAnd you can add your own common filters. The following create a compile filter named \"mycompile\". \n</p>\n\n<pre prettyprint>\nhm.loader.loadFilters.compile.mycompile = \n  function (assetId, sourceCode) {};\n</pre>\n\n<p>\nIn the following, we will create a asset loader to load markdown file. After the loader is created, we will load an asset \"readme.md\", after the asset is loaded, we append them to the page body. The file structure is organized as following. Please note that, you don't have to statically include the dependencies such as js/showdown.js or loader/md.js using script tag in the page, although you can.\n</p>\n\n<image src=\"http://snag.gy/ZwEBQ.jpg\">\n\n\n<pre prettyprint preview=\"_|../../samples/markdown/index.html\">\n\n&lt;!-- index.html file --&gt;\n&lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;          \n&lt;script src=\"http://code.semanticsworks.com/assets/js/hm.debug.js\"&gt;&lt;/script&gt;\n&lt;script&gt;                                                                    \n\thm.loader.load( \"readme.md\" ).done( function( html ) {                     \n\t\t$( \"body\" ).append( html );                                               \n\t} );                                                                       \n&lt;/script&gt;                                                                                                                                 \n</pre>\n\n<pre prettyprint>\n//md.js file\n//&lt;@depend&gt;js/showdown.js&lt;/@depend&gt;\n(function() {\n\n\tvar converter = new Showdown.converter();\n\n\thm.loader( \"md\", {\n\n\t\tload: {\n\n\t\t\tstaticLoaded: \"returnFalse\",\n\t\t\tcompile: function( assetId, sourceCode ) {\n\t\t\t\treturn converter.makeHtml( sourceCode );\n\t\t\t}\n\t\t}\n\n\t} );\n})();\n\n</pre>\n<p>The readme.md file is as following</p>\n<pre prettyprint>\nLoad filters\n---------------\n\nThere are five kind of load filters.\n\n  - staticLoaded\n  - getSource\n  - compile\n  - crossSiteLoad\n  - buildUnload\n  - buildDependencies\n</pre>\n\n\n\n", "signatures": []},
    {"name": "modify loader", "namespace": "loader", "shortDesc": "modify loader", "longDesc": "<p>\nTo modify an existing loader, you can use use the sample method which create a loader. The following modify an existing loader \"jsl\"\n</p>\n\n\n<pre prettyprint preview=\"_|../../samples/modify_loader/index.html\">\n\n&lt;!-- html file --&gt;\n&lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;          \n&lt;script src=\"http://code.semanticsworks.com/assets/js/hm.debug.js\"&gt;&lt;/script&gt;\n&lt;script&gt;                                                                    \n\thm.loader(\"jsl\", \"jsl\", {                                                  \n\t\turl: \"folder\"                                                             \n\t});                                                                        \n                                                                            \n\thm.loader.load(\"greeting.jsl\" ).done(function (greeting) {                 \n\t\t$(\"body\" ).append(greeting);                                              \n\t});                                                                        \n&lt;/script&gt;                                                                   \nad&gt;                                                                                              \n</pre>\n\n<p>\nThe <code>folder</code> method is built-in common url methods. It assume each resource is placed into a folder with the same name of a loader. The following is file structure of the example.\n</p>\n\n<image src=\"http://snag.gy/B6Z0J.jpg\">\n", "signatures": []}
]